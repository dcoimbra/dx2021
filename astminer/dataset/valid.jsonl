{"project": "7zip", "file": "Rar5Decoder.cpp", "func": "static inline unsigned SlotToLen(CBitDecoder &_bitStream, unsigned slot)\n{\n  if (slot < 8)\n    return slot + 2;\n  unsigned numBits = (slot >> 2) - 1;\n  return 2 + ((4 | (slot & 3)) << numBits) + _bitStream.ReadBits9(numBits);\n}\n", "label": "compress"}
{"project": "7zip", "file": "Rar5Decoder.cpp", "func": "HRESULT CDecoder::DecodeLZ()\n{\n  CBitDecoder _bitStream;\n  _bitStream._stream = _inStream;\n  _bitStream._bufBase = _inputBuf;\n  _bitStream.Init();\n\n  UInt32 rep0 = _reps[0];\n\n  UInt32 remLen = 0;\n\n  size_t limit;\n  {\n    size_t rem = _winSize - _winPos;\n    if (rem > kWriteStep)\n      rem = kWriteStep;\n    limit = _winPos + rem;\n  }\n  \n  for (;;)\n  {\n    if (_winPos >= limit)\n    {\n      RINOK(WriteBuf());\n      if (_unpackSize_Defined && _writtenFileSize > _unpackSize)\n        break; // return S_FALSE;\n      \n      {\n        size_t rem = _winSize - _winPos;\n        \n        if (rem == 0)\n        {\n          _winPos = 0;\n          rem = _winSize;\n        }\n        if (rem > kWriteStep)\n          rem = kWriteStep;\n        limit = _winPos + rem;\n      }\n\n      if (remLen != 0)\n      {\n        size_t winPos = _winPos;\n        size_t winMask = _winMask;\n        size_t pos = (winPos - (size_t)rep0 - 1) & winMask;\n        \n        Byte *win = _window;\n        do\n        {\n          if (winPos >= limit)\n            break;\n          win[winPos] = win[pos];\n          winPos++;\n          pos = (pos + 1) & winMask;\n        }\n        while (--remLen != 0);\n        \n        _lzSize += winPos - _winPos;\n        _winPos = winPos;\n        continue;\n      }\n    }\n\n    if (_bitStream._buf >= _bitStream._bufCheck2)\n    {\n      if (_bitStream.InputEofError())\n        break; // return S_FALSE;\n      if (_bitStream._buf >= _bitStream._bufCheck)\n        _bitStream.Prepare2();\n\n      UInt64 processed = _bitStream.GetProcessedSize_Round();\n      if (processed >= _bitStream._blockEnd)\n      {\n        if (processed > _bitStream._blockEnd)\n          break; // return S_FALSE;\n        {\n          unsigned bits7 = _bitStream.GetProcessedBits7();\n          if (bits7 > _bitStream._blockEndBits7)\n            break; // return S_FALSE;\n          if (bits7 == _bitStream._blockEndBits7)\n          {\n            if (_isLastBlock)\n            {\n              _reps[0] = rep0;\n              \n              if (_bitStream.InputEofError())\n                break;\n              \n              /*\n              // packSize can be 15 bytes larger for encrypted archive\n              if (_packSize_Defined && _packSize < _bitStream.GetProcessedSize())\n                break;\n              */\n              \n              return _bitStream._hres;\n              // break;\n            }\n            RINOK(ReadTables(_bitStream));\n            continue;\n          }\n        }\n      }\n\n      // that check is not required, but it can help, if there is BUG in another code\n      if (!_tableWasFilled)\n        break; // return S_FALSE;\n    }\n\n    UInt32 sym = m_MainDecoder.Decode(&_bitStream);\n    \n    if (sym < 256)\n    {\n      size_t winPos = _winPos;\n      _window[winPos] = (Byte)sym;\n      _winPos = winPos + 1;\n      _lzSize++;\n      continue;\n    }\n   \n    UInt32 len;\n\n    if (sym < kSymbolRep + kNumReps)\n    {\n      if (sym >= kSymbolRep)\n      {\n        if (sym != kSymbolRep)\n        {\n          UInt32 dist;\n          if (sym == kSymbolRep + 1)\n            dist = _reps[1];\n          else\n          {\n            if (sym == kSymbolRep + 2)\n              dist = _reps[2];\n            else\n            {\n              dist = _reps[3];\n              _reps[3] = _reps[2];\n            }\n            _reps[2] = _reps[1];\n          }\n          _reps[1] = rep0;\n          rep0 = dist;\n        }\n        \n        const UInt32 sym2 = m_LenDecoder.Decode(&_bitStream);\n        if (sym2 >= kLenTableSize)\n          break; // return S_FALSE;\n        len = SlotToLen(_bitStream, sym2);\n      }\n      else\n      {\n        if (sym == 256)\n        {\n          RINOK(AddFilter(_bitStream));\n          continue;\n        }\n        else // if (sym == 257)\n        {\n          len = _lastLen;\n          // if (len = 0), we ignore that symbol, like original unRAR code, but it can mean error in stream.\n          // if (len == 0) return S_FALSE;\n          if (len == 0)\n            continue;\n        }\n      }\n    }\n    else if (sym >= kMainTableSize)\n      break; // return S_FALSE;\n    else\n    {\n      _reps[3] = _reps[2];\n      _reps[2] = _reps[1];\n      _reps[1] = rep0;\n      len = SlotToLen(_bitStream, sym - (kSymbolRep + kNumReps));\n      \n      rep0 = m_DistDecoder.Decode(&_bitStream);\n      \n      if (rep0 >= 4)\n      {\n        if (rep0 >= _numCorrectDistSymbols)\n          break; // return S_FALSE;\n        unsigned numBits = (rep0 >> 1) - 1;\n        rep0 = (2 | (rep0 & 1)) << numBits;\n        \n        if (numBits < kNumAlignBits)\n          rep0 += _bitStream.ReadBits9(numBits);\n        else\n        {\n          len += (numBits >= 7);\n          len += (numBits >= 12);\n          len += (numBits >= 17);\n        \n          if (_useAlignBits)\n          {\n            // if (numBits > kNumAlignBits)\n              rep0 += (_bitStream.ReadBits32(numBits - kNumAlignBits) << kNumAlignBits);\n            UInt32 a = m_AlignDecoder.Decode(&_bitStream);\n            if (a >= kAlignTableSize)\n              break; // return S_FALSE;\n            rep0 += a;\n          }\n          else\n            rep0 += _bitStream.ReadBits32(numBits);\n        }\n      }\n    }\n\n    _lastLen = len;\n\n    if (rep0 >= _lzSize)\n      _lzError = true;\n    \n    {\n      UInt32 lenCur = len;\n      size_t winPos = _winPos;\n      size_t pos = (winPos - (size_t)rep0 - 1) & _winMask;\n      {\n        size_t rem = limit - winPos;\n        // size_t rem = _winSize - winPos;\n\n        if (lenCur > rem)\n        {\n          lenCur = (UInt32)rem;\n          remLen = len - lenCur;\n        }\n      }\n      \n      Byte *win = _window;\n      _lzSize += lenCur;\n      _winPos = winPos + lenCur;\n      if (_winSize - pos >= lenCur)\n      {\n        const Byte *src = win + pos;\n        Byte *dest = win + winPos;\n        do\n          *dest++ = *src++;\n        while (--lenCur != 0);\n      }\n      else\n      {\n        do\n        {\n          win[winPos] = win[pos];\n          winPos++;\n          pos = (pos + 1) & _winMask;\n        }\n        while (--lenCur != 0);\n      }\n    }\n  }\n  \n  if (_bitStream._hres != S_OK)\n    return _bitStream._hres;\n\n  return S_FALSE;\n}\n", "label": "compress"}
{"project": "7zip", "file": "Rar5Decoder.cpp", "func": "HRESULT CDecoder::CodeReal()\n{\n  _unsupportedFilter = false;\n  _lzError = false;\n  _writeError = false;\n\n  if (!_isSolid || !_wasInit)\n  {\n    size_t clearSize = _winSize;\n    if (_lzSize < _winSize)\n      clearSize = (size_t)_lzSize;\n    memset(_window, 0, clearSize);\n\n    _wasInit = true;\n    _lzSize = 0;\n    _lzWritten = 0;\n    _winPos = 0;\n    \n    for (unsigned i = 0; i < kNumReps; i++)\n      _reps[i] = (UInt32)0 - 1;\n\n    _lastLen = 0;\n    _tableWasFilled = false;\n  }\n\n  _isLastBlock = false;\n\n  InitFilters();\n\n  _filterEnd = 0;\n  _writtenFileSize = 0;\n\n  _lzFileStart = _lzSize;\n  _lzWritten = _lzSize;\n  \n  HRESULT res = DecodeLZ();\n\n  HRESULT res2 = S_OK;\n  if (!_writeError && res != E_OUTOFMEMORY)\n    res2 = WriteBuf();\n\n  /*\n  if (res == S_OK)\n    if (InputEofError())\n      res = S_FALSE;\n  */\n\n  if (res == S_OK)\n  {\n    _solidAllowed = true;\n    res = res2;\n  }\n     \n  if (res == S_OK && _unpackSize_Defined && _writtenFileSize != _unpackSize)\n    return S_FALSE;\n  return res;\n}\n", "label": "compress"}
{"project": "7zip", "file": "Rar5Decoder.cpp", "func": "STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,\n    const UInt64 * /* inSize */, const UInt64 *outSize, ICompressProgressInfo *progress)\n{\n  try\n  {\n    if (_isSolid && !_solidAllowed)\n      return S_FALSE;\n    _solidAllowed = false;\n\n    if (_dictSizeLog >= sizeof(size_t) * 8)\n      return E_NOTIMPL;\n\n    if (!_isSolid)\n      _lzEnd = 0;\n    else\n    {\n      if (_lzSize < _lzEnd)\n      {\n        if (_window)\n        {\n          UInt64 rem = _lzEnd - _lzSize;\n          if (rem >= _winSize)\n            memset(_window, 0, _winSize);\n          else\n          {\n            size_t pos = (size_t)_lzSize & _winSize;\n            size_t rem2 = _winSize - pos;\n            if (rem2 > rem)\n              rem2 = (size_t)rem;\n            memset(_window + pos, 0, rem2);\n            rem -= rem2;\n            memset(_window, 0, (size_t)rem);\n          }\n        }\n        _lzEnd &= ((((UInt64)1) << 33) - 1);\n        _lzSize = _lzEnd;\n        _winPos = (size_t)(_lzSize & _winSize);\n      }\n      _lzEnd = _lzSize;\n    }\n\n    size_t newSize;\n    {\n      unsigned newSizeLog = _dictSizeLog;\n      if (newSizeLog < kWinSize_Log_Min)\n        newSizeLog = kWinSize_Log_Min;\n      newSize = (size_t)1 << newSizeLog;\n      _numCorrectDistSymbols = newSizeLog * 2;\n    }\n\n    // If dictionary was reduced, we use allocated dictionary block\n    // for compatibility with original unRAR decoder.\n\n    if (_window && newSize < _winSizeAllocated)\n      _winSize = _winSizeAllocated;\n    else if (!_window || _winSize != newSize)\n    {\n      if (!_isSolid)\n      {\n        ::MidFree(_window);\n        _window = NULL;\n        _winSizeAllocated = 0;\n      }\n\n      Byte *win;\n\n      {\n        win = (Byte *)::MidAlloc(newSize);\n        if (!win)\n          return E_OUTOFMEMORY;\n        memset(win, 0, newSize);\n      }\n      \n      if (_isSolid && _window)\n      {\n        // original unRAR claims:\n        // \"Archiving code guarantees that win size does not grow in the same solid stream\",\n        // but the original unRAR decoder still supports such grow case.\n        \n        Byte *winOld = _window;\n        size_t oldSize = _winSize;\n        size_t newMask = newSize - 1;\n        size_t oldMask = _winSize - 1;\n        size_t winPos = _winPos;\n        for (size_t i = 1; i <= oldSize; i++)\n          win[(winPos - i) & newMask] = winOld[(winPos - i) & oldMask];\n        ::MidFree(_window);\n      }\n      \n      _window = win;\n      _winSizeAllocated = newSize;\n      _winSize = newSize;\n    }\n\n    _winMask = _winSize - 1;\n    _winPos &= _winMask;\n\n    if (!_inputBuf)\n    {\n      _inputBuf = (Byte *)::MidAlloc(kInputBufSize);\n      if (!_inputBuf)\n        return E_OUTOFMEMORY;\n    }\n\n    _inStream = inStream;\n    _outStream = outStream;\n\n    /*\n    _packSize = 0;\n    _packSize_Defined = (inSize != NULL);\n    if (_packSize_Defined)\n      _packSize = *inSize;\n    */\n    \n    _unpackSize = 0;\n    _unpackSize_Defined = (outSize != NULL);\n    if (_unpackSize_Defined)\n      _unpackSize = *outSize;\n\n    if ((Int64)_unpackSize >= 0)\n      _lzEnd += _unpackSize;\n    else\n      _lzEnd = 0;\n    \n    _progress = progress;\n    \n    HRESULT res = CodeReal();\n    \n    if (res != S_OK)\n      return res;\n    if (_lzError)\n      return S_FALSE;\n    if (_unsupportedFilter)\n      return E_NOTIMPL;\n    return S_OK;\n  }\n  // catch(const CInBufferException &e)  { return e.ErrorCode; }\n  // catch(...) { return S_FALSE; }\n  catch(...) { return E_OUTOFMEMORY; }\n  // CNewException is possible here. But probably CNewException is caused\n  // by error in data stream.\n}\n", "label": "compress"}
{"project": "7zip", "file": "Rar5Decoder.cpp", "func": "STDMETHODIMP CDecoder::SetDecoderProperties2(const Byte *data, UInt32 size)\n{\n  if (size != 2)\n    return E_NOTIMPL;\n  _dictSizeLog = (Byte)((data[0] & 0xF) + 17);\n  _isSolid = ((data[1] & 1) != 0);\n  return S_OK;\n}\n", "label": "compress"}
{"project": "7zip", "file": "ShrinkDecoder.cpp", "func": "HRESULT CDecoder::CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,\n    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)\n{\n  NBitl::CBaseDecoder<CInBuffer> inBuffer;\n  COutBuffer outBuffer;\n\n  if (!inBuffer.Create(kBufferSize))\n    return E_OUTOFMEMORY;\n  if (!outBuffer.Create(kBufferSize))\n    return E_OUTOFMEMORY;\n\n  inBuffer.SetStream(inStream);\n  inBuffer.Init();\n\n  outBuffer.SetStream(outStream);\n  outBuffer.Init();\n\n  {\n    for (unsigned i = 0; i < kNumItems; i++)\n      _parents[i] = kEmpty;\n  }\n\n  UInt64 outPrev = 0, inPrev = 0;\n  unsigned numBits = kNumMinBits;\n  unsigned head = 257;\n  int lastSym = -1;\n  Byte lastChar = 0;\n  bool moreOut = false;\n\n  HRESULT res = S_FALSE;\n\n  for (;;)\n  {\n    _inProcessed = inBuffer.GetProcessedSize();\n    const UInt64 nowPos = outBuffer.GetProcessedSize();\n\n    bool eofCheck = false;\n\n    if (outSize && nowPos >= *outSize)\n    {\n      if (!_fullStreamMode || moreOut)\n      {\n        res = S_OK;\n        break;\n      }\n      eofCheck = true;\n      // Is specSym(=256) allowed after end of stream ?\n      // Do we need to read it here ?\n    }\n\n    if (progress)\n    {\n      if (nowPos - outPrev >= (1 << 20) || _inProcessed - inPrev >= (1 << 20))\n      {\n        outPrev = nowPos;\n        inPrev = _inProcessed;\n        res = progress->SetRatioInfo(&_inProcessed, &nowPos);\n        if (res != SZ_OK)\n        {\n          // break;\n          return res;\n        }\n      }\n    }\n\n    UInt32 sym = inBuffer.ReadBits(numBits);\n\n    if (inBuffer.ExtraBitsWereRead())\n    {\n      res = S_OK;\n      break;\n    }\n    \n    if (sym == 256)\n    {\n      sym = inBuffer.ReadBits(numBits);\n\n      if (inBuffer.ExtraBitsWereRead())\n        break;\n\n      if (sym == 1)\n      {\n        if (numBits >= kNumMaxBits)\n          break;\n        numBits++;\n        continue;\n      }\n      if (sym != 2)\n      {\n        break;\n        // continue; // info-zip just ignores such code\n      }\n      {\n        /*\n        ---------- Free leaf nodes ----------\n        Note : that code can mark _parents[lastSym] as free, and next\n        inserted node will be Orphan in that case.\n        */\n\n        unsigned i;\n        for (i = 256; i < kNumItems; i++)\n          _stack[i] = 0;\n        for (i = 257; i < kNumItems; i++)\n        {\n          unsigned par = _parents[i];\n          if (par != kEmpty)\n            _stack[par] = 1;\n        }\n        for (i = 257; i < kNumItems; i++)\n          if (_stack[i] == 0)\n            _parents[i] = kEmpty;\n        head = 257;\n        continue;\n      }\n    }\n\n    if (eofCheck)\n    {\n      // It's can be error case.\n      // That error can be detected later in (*inSize != _inProcessed) check.\n      res = S_OK;\n      break;\n    }\n\n    bool needPrev = false;\n    if (head < kNumItems && lastSym >= 0)\n    {\n      while (head < kNumItems && _parents[head] != kEmpty)\n        head++;\n      if (head < kNumItems)\n      {\n        /*\n        if (head == lastSym), it updates Orphan to self-linked Orphan and creates two problems:\n            1) we must check _stack[i++] overflow in code that walks tree nodes.\n            2) self-linked node can not be removed. So such self-linked nodes can occupy all _parents items.\n        */\n        needPrev = true;\n        _parents[head] = (UInt16)lastSym;\n        _suffixes[head] = (Byte)lastChar;\n        head++;\n      }\n    }\n\n    lastSym = sym;\n    unsigned cur = sym;\n    unsigned i = 0;\n    \n    while (cur >= 256)\n    {\n      _stack[i++] = _suffixes[cur];\n      cur = _parents[cur];\n      // don't change that code:\n      // Orphan Check and self-linked Orphan check (_stack overflow check);\n      if (cur == kEmpty || i >= kNumItems)\n        break;\n    }\n    \n    if (cur == kEmpty || i >= kNumItems)\n      break;\n\n    _stack[i++] = (Byte)cur;\n    lastChar = (Byte)cur;\n\n    if (needPrev)\n      _suffixes[(size_t)head - 1] = (Byte)cur;\n\n    if (outSize)\n    {\n      const UInt64 limit = *outSize - nowPos;\n      if (i > limit)\n      {\n        moreOut = true;\n        i = (unsigned)limit;\n      }\n    }\n\n    do\n      outBuffer.WriteByte(_stack[--i]);\n    while (i);\n  }\n  \n  RINOK(outBuffer.Flush());\n\n  if (res == S_OK)\n    if (_fullStreamMode)\n    {\n      if (moreOut)\n        res = S_FALSE;\n      const UInt64 nowPos = outBuffer.GetProcessedSize();\n      if (outSize && *outSize != nowPos)\n        res = S_FALSE;\n      if (inSize && *inSize != _inProcessed)\n        res = S_FALSE;\n    }\n  \n  return res;\n}\n", "label": "compress"}
{"project": "7zip", "file": "ShrinkDecoder.cpp", "func": "STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,\n    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)\n{\n  try { return CodeReal(inStream, outStream, inSize, outSize, progress); }\n  // catch(const CInBufferException &e) { return e.ErrorCode; }\n  // catch(const COutBufferException &e) { return e.ErrorCode; }\n  catch(const CSystemException &e) { return e.ErrorCode; }\n  catch(...) { return S_FALSE; }\n}\n", "label": "compress"}
{"project": "7zip", "file": "ShrinkDecoder.cpp", "func": "STDMETHODIMP CDecoder::SetFinishMode(UInt32 finishMode)\n{\n  _fullStreamMode = (finishMode != 0);\n  return S_OK;\n}\n", "label": "compress"}
{"project": "7zip", "file": "ShrinkDecoder.cpp", "func": "STDMETHODIMP CDecoder::GetInStreamProcessedSize(UInt64 *value)\n{\n  *value = _inProcessed;\n  return S_OK;\n}\n", "label": "compress"}
{"project": "7zip", "file": "XpressDecoder.cpp", "func": "  UInt32 GetValue(unsigned numBits) const\n  {\n    return (Value >> (BitPos - numBits)) & ((1 << numBits) - 1);\n  }\n", "label": "compress"}
{"project": "7zip", "file": "XpressDecoder.cpp", "func": "  void MovePos(unsigned numBits)\n  {\n    BitPos -= numBits;\n  }\n", "label": "compress"}
{"project": "7zip", "file": "XpressDecoder.cpp", "func": "HRESULT Decode(const Byte *in, size_t inSize, Byte *out, size_t outSize)\n{\n  NCompress::NHuffman::CDecoder<kNumHuffBits, kNumSyms> huff;\n  \n  if (inSize < kNumSyms / 2 + 4)\n    return S_FALSE;\n  {\n    Byte levels[kNumSyms];\n    for (unsigned i = 0; i < kNumSyms / 2; i++)\n    {\n      Byte b = in[i];\n      levels[(size_t)i * 2] = (Byte)(b & 0xF);\n      levels[(size_t)i * 2 + 1] = (Byte)(b >> 4);\n    }\n    if (!huff.BuildFull(levels))\n      return S_FALSE;\n  }\n\n\n  CBitStream bs;\n\n  const Byte *lim = in + inSize - 1;\n\n  in += kNumSyms / 2;\n  bs.Value = (GetUi16(in) << 16) | GetUi16(in + 2);\n  in += 4;\n  bs.BitPos = 32;\n\n  size_t pos = 0;\n\n  for (;;)\n  {\n    // printf(\"\\n%d\", pos);\n    UInt32 sym = huff.DecodeFull(&bs);\n    // printf(\" sym = %d\", sym);\n    BIT_STREAM_NORMALIZE\n\n    if (pos >= outSize)\n      return (sym == 256 && in == lim + 1) ? S_OK : S_FALSE;\n\n    if (sym < 256)\n      out[pos++] = (Byte)sym;\n    else\n    {\n      sym -= 256;\n      UInt32 dist = sym >> kNumLenBits;\n      UInt32 len = sym & kLenMask;\n      \n      if (len == kLenMask)\n      {\n        if (in > lim)\n          return S_FALSE;\n        len = *in++;\n        if (len == 0xFF)\n        {\n          if (in >= lim)\n            return S_FALSE;\n          len = GetUi16(in);\n          in += 2;\n        }\n        else\n          len += kLenMask;\n      }\n\n      bs.BitPos -= dist;\n      dist = (UInt32)1 << dist;\n      dist += ((bs.Value >> bs.BitPos) & (dist - 1));\n\n      BIT_STREAM_NORMALIZE\n      \n      if (len + 3 > outSize - pos)\n        return S_FALSE;\n      if (dist > pos)\n        return S_FALSE;\n\n      Byte *dest = out + pos;\n      const Byte *src = dest - dist;\n      pos += len + 3;\n      len += 1;\n      *dest++ = *src++;\n      *dest++ = *src++;\n      do\n        *dest++ = *src++;\n      while (--len);\n    }\n  }\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzDecoder.cpp", "func": "static HRESULT SResToHRESULT_Code(SRes res) throw()\n{\n  if (res < 0)\n    return res;\n  switch (res)\n  {\n    case SZ_OK: return S_OK;\n    case SZ_ERROR_MEM: return E_OUTOFMEMORY;\n    case SZ_ERROR_UNSUPPORTED: return E_NOTIMPL;\n  }\n  return S_FALSE;\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzDecoder.cpp", "func": "HRESULT CDecoder::Decode(ISequentialInStream *seqInStream, ISequentialOutStream *outStream,\n    const UInt64 *outSizeLimit, bool finishStream, ICompressProgressInfo *progress)\n{\n  MainDecodeSRes = S_OK;\n  MainDecodeSRes_wasUsed = false;\n  XzStatInfo_Clear(&Stat);\n\n  if (!xz)\n  {\n    xz = XzDecMt_Create(&g_Alloc, &g_MidAlloc);\n    if (!xz)\n      return E_OUTOFMEMORY;\n  }\n\n  CXzDecMtProps props;\n  XzDecMtProps_Init(&props);\n\n  int isMT = False;\n\n  #ifndef _7ZIP_ST\n  {\n    props.numThreads = 1;\n    UInt32 numThreads = _numThreads;\n\n    if (_tryMt && numThreads > 1)\n    {\n      size_t memUsage = (size_t)_memUsage;\n      if (memUsage != _memUsage)\n        memUsage = (size_t)0 - 1;\n      props.memUseMax = memUsage;\n      isMT = (numThreads > 1);\n    }\n\n    props.numThreads = numThreads;\n  }\n  #endif\n\n  CSeqInStreamWrap inWrap;\n  CSeqOutStreamWrap outWrap;\n  CCompressProgressWrap progressWrap;\n\n  inWrap.Init(seqInStream);\n  outWrap.Init(outStream);\n  progressWrap.Init(progress);\n\n  SRes res = XzDecMt_Decode(xz,\n      &props,\n      outSizeLimit, finishStream,\n      &outWrap.vt,\n      &inWrap.vt,\n      &Stat,\n      &isMT,\n      progress ? &progressWrap.vt : NULL);\n\n  MainDecodeSRes = res;\n\n  #ifndef _7ZIP_ST\n  // _tryMt = isMT;\n  #endif\n\n  RET_IF_WRAP_ERROR(outWrap.Res, res, SZ_ERROR_WRITE)\n  RET_IF_WRAP_ERROR(progressWrap.Res, res, SZ_ERROR_PROGRESS)\n  RET_IF_WRAP_ERROR_CONFIRMED(inWrap.Res, res, SZ_ERROR_READ)\n\n  // return E_OUTOFMEMORY;\n\n  MainDecodeSRes_wasUsed = true;\n\n  if (res == SZ_OK && finishStream)\n  {\n    /*\n    if (inSize && *inSize != Stat.PhySize)\n      res = SZ_ERROR_DATA;\n    */\n    if (outSizeLimit && *outSizeLimit != outWrap.Processed)\n      res = SZ_ERROR_DATA;\n  }\n\n  return SResToHRESULT_Code(res);\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzDecoder.cpp", "func": "HRESULT CComDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,\n    const UInt64 * /* inSize */, const UInt64 *outSize, ICompressProgressInfo *progress)\n{\n  return Decode(inStream, outStream, outSize, _finishStream, progress);\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzDecoder.cpp", "func": "STDMETHODIMP CComDecoder::SetFinishMode(UInt32 finishMode)\n{\n  _finishStream = (finishMode != 0);\n  return S_OK;\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzDecoder.cpp", "func": "STDMETHODIMP CComDecoder::GetInStreamProcessedSize(UInt64 *value)\n{\n  *value = Stat.InSize;\n  return S_OK;\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzDecoder.cpp", "func": "STDMETHODIMP CComDecoder::SetNumberOfThreads(UInt32 numThreads)\n{\n  _numThreads = numThreads;\n  return S_OK;\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzDecoder.cpp", "func": "STDMETHODIMP CComDecoder::SetMemLimit(UInt64 memUsage)\n{\n  _memUsage = memUsage;\n  return S_OK;\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzEncoder.cpp", "func": "void CEncoder::InitCoderProps()\n{\n  XzProps_Init(&xzProps);\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzEncoder.cpp", "func": "static int FilterIdFromName(const wchar_t *name)\n{\n  for (unsigned i = 0; i < ARRAY_SIZE(g_NamePairs); i++)\n  {\n    const CMethodNamePair &pair = g_NamePairs[i];\n    if (StringsAreEqualNoCase_Ascii(name, pair.Name))\n      return (int)pair.Id;\n  }\n  return -1;\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzEncoder.cpp", "func": "HRESULT CEncoder::SetCheckSize(UInt32 checkSizeInBytes)\n{\n  unsigned id;\n  switch (checkSizeInBytes)\n  {\n    case  0: id = XZ_CHECK_NO; break;\n    case  4: id = XZ_CHECK_CRC32; break;\n    case  8: id = XZ_CHECK_CRC64; break;\n    case 32: id = XZ_CHECK_SHA256; break;\n    default: return E_INVALIDARG;\n  }\n  xzProps.checkId = id;\n  return S_OK;\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzEncoder.cpp", "func": "HRESULT CEncoder::SetCoderProp(PROPID propID, const PROPVARIANT &prop)\n{\n  if (propID == NCoderPropID::kNumThreads)\n  {\n    if (prop.vt != VT_UI4)\n      return E_INVALIDARG;\n    xzProps.numTotalThreads = (int)(prop.ulVal);\n    return S_OK;\n  }\n\n  if (propID == NCoderPropID::kCheckSize)\n  {\n    if (prop.vt != VT_UI4)\n      return E_INVALIDARG;\n    return SetCheckSize(prop.ulVal);\n  }\n\n  if (propID == NCoderPropID::kBlockSize2)\n  {\n    if (prop.vt == VT_UI4)\n      xzProps.blockSize = prop.ulVal;\n    else if (prop.vt == VT_UI8)\n      xzProps.blockSize = prop.uhVal.QuadPart;\n    else\n      return E_INVALIDARG;\n    return S_OK;\n  }\n\n  if (propID == NCoderPropID::kReduceSize)\n  {\n    if (prop.vt == VT_UI8)\n      xzProps.reduceSize = prop.uhVal.QuadPart;\n    else\n      return E_INVALIDARG;\n    return S_OK;\n  }\n \n  if (propID == NCoderPropID::kFilter)\n  {\n    if (prop.vt == VT_UI4)\n    {\n      UInt32 id32 = prop.ulVal;\n      if (id32 == XZ_ID_Delta)\n        return E_INVALIDARG;\n      xzProps.filterProps.id = prop.ulVal;\n    }\n    else\n    {\n      if (prop.vt != VT_BSTR)\n        return E_INVALIDARG;\n      \n      const wchar_t *name = prop.bstrVal;\n      const wchar_t *end;\n\n      UInt32 id32 = ConvertStringToUInt32(name, &end);\n      \n      if (end != name)\n        name = end;\n      else\n      {\n        if (IsString1PrefixedByString2_NoCase_Ascii(name, \"Delta\"))\n        {\n          name += 5; // strlen(\"Delta\");\n          id32 = XZ_ID_Delta;\n        }\n        else\n        {\n          int filterId = FilterIdFromName(prop.bstrVal);\n          if (filterId < 0 /* || filterId == XZ_ID_LZMA2 */)\n            return E_INVALIDARG;\n          id32 = filterId;\n        }\n      }\n      \n      if (id32 == XZ_ID_Delta)\n      {\n        wchar_t c = *name;\n        if (c != '-' && c != ':')\n          return E_INVALIDARG;\n        name++;\n        UInt32 delta = ConvertStringToUInt32(name, &end);\n        if (end == name || *end != 0 || delta == 0 || delta > 256)\n          return E_INVALIDARG;\n        xzProps.filterProps.delta = delta;\n      }\n      \n      xzProps.filterProps.id = id32;\n    }\n    \n    return S_OK;\n  }\n\n  return NLzma2::SetLzma2Prop(propID, prop, xzProps.lzma2Props);\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzEncoder.cpp", "func": "STDMETHODIMP CEncoder::SetCoderProperties(const PROPID *propIDs,\n    const PROPVARIANT *coderProps, UInt32 numProps)\n{\n  XzProps_Init(&xzProps);\n\n  for (UInt32 i = 0; i < numProps; i++)\n  {\n    RINOK(SetCoderProp(propIDs[i], coderProps[i]));\n  }\n  \n  return S_OK;\n  // return SResToHRESULT(XzEnc_SetProps(_encoder, &xzProps));\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzEncoder.cpp", "func": "STDMETHODIMP CEncoder::SetCoderPropertiesOpt(const PROPID *propIDs,\n    const PROPVARIANT *coderProps, UInt32 numProps)\n{\n  for (UInt32 i = 0; i < numProps; i++)\n  {\n    const PROPVARIANT &prop = coderProps[i];\n    PROPID propID = propIDs[i];\n    if (propID == NCoderPropID::kExpectedDataSize)\n      if (prop.vt == VT_UI8)\n        XzEnc_SetDataSize(_encoder, prop.uhVal.QuadPart);\n  }\n  return S_OK;\n}\n", "label": "compress"}
{"project": "7zip", "file": "XzEncoder.cpp", "func": "STDMETHODIMP CEncoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,\n    const UInt64 * /* inSize */, const UInt64 * /* outSize */, ICompressProgressInfo *progress)\n{\n  CSeqInStreamWrap inWrap;\n  CSeqOutStreamWrap outWrap;\n  CCompressProgressWrap progressWrap;\n\n  inWrap.Init(inStream);\n  outWrap.Init(outStream);\n  progressWrap.Init(progress);\n\n  SRes res = XzEnc_SetProps(_encoder, &xzProps);\n  if (res == SZ_OK)\n    res = XzEnc_Encode(_encoder, &outWrap.vt, &inWrap.vt, progress ? &progressWrap.vt : NULL);\n\n  // SRes res = Xz_Encode(&outWrap.vt, &inWrap.vt, &xzProps, progress ? &progressWrap.vt : NULL);\n\n  RET_IF_WRAP_ERROR(inWrap.Res, res, SZ_ERROR_READ)\n  RET_IF_WRAP_ERROR(outWrap.Res, res, SZ_ERROR_WRITE)\n  RET_IF_WRAP_ERROR(progressWrap.Res, res, SZ_ERROR_PROGRESS)\n\n  return SResToHRESULT(res);\n}\n", "label": "compress"}
{"project": "7zip", "file": "ZDecoder.cpp", "func": "void CDecoder::Free()\n{\n  MyFree(_parents); _parents = 0;\n  MyFree(_suffixes); _suffixes = 0;\n  MyFree(_stack); _stack = 0;\n}\n", "label": "compress"}
{"project": "7zip", "file": "ZDecoder.cpp", "func": "HRESULT CDecoder::CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,\n    const UInt64 * /* inSize */, const UInt64 * /* outSize */, ICompressProgressInfo *progress)\n{\n  CInBuffer inBuffer;\n  COutBuffer outBuffer;\n\n  PackSize = 0;\n  \n  if (!inBuffer.Create(kBufferSize))\n    return E_OUTOFMEMORY;\n  inBuffer.SetStream(inStream);\n  inBuffer.Init();\n\n  if (!outBuffer.Create(kBufferSize))\n    return E_OUTOFMEMORY;\n  outBuffer.SetStream(outStream);\n  outBuffer.Init();\n\n  Byte buf[kNumMaxBits + 4];\n  {\n    if (inBuffer.ReadBytes(buf, 3) < 3)\n      return S_FALSE;\n    if (buf[0] != 0x1F || buf[1] != 0x9D)\n      return S_FALSE;;\n  }\n  Byte prop = buf[2];\n\n  if ((prop & 0x60) != 0)\n    return S_FALSE;\n  unsigned maxbits = prop & kNumBitsMask;\n  if (maxbits < kNumMinBits || maxbits > kNumMaxBits)\n    return S_FALSE;\n  UInt32 numItems = 1 << maxbits;\n  // Speed optimization: blockSymbol can contain unused velue.\n\n  if (maxbits != _numMaxBits || _parents == 0 || _suffixes == 0 || _stack == 0)\n  {\n    Free();\n    _parents = (UInt16 *)MyAlloc(numItems * sizeof(UInt16)); if (_parents == 0) return E_OUTOFMEMORY;\n    _suffixes = (Byte *)MyAlloc(numItems * sizeof(Byte)); if (_suffixes == 0) return E_OUTOFMEMORY;\n    _stack = (Byte *)MyAlloc(numItems * sizeof(Byte)); if (_stack == 0) return E_OUTOFMEMORY;\n    _numMaxBits = maxbits;\n  }\n\n  UInt64 prevPos = 0;\n  UInt32 blockSymbol = ((prop & kBlockModeMask) != 0) ? 256 : ((UInt32)1 << kNumMaxBits);\n  unsigned numBits = kNumMinBits;\n  UInt32 head = (blockSymbol == 256) ? 257 : 256;\n  bool needPrev = false;\n  unsigned bitPos = 0;\n  unsigned numBufBits = 0;\n\n  _parents[256] = 0; // virus protection\n  _suffixes[256] = 0;\n  HRESULT res = S_OK;\n\n  for (;;)\n  {\n    if (numBufBits == bitPos)\n    {\n      numBufBits = (unsigned)inBuffer.ReadBytes(buf, numBits) * 8;\n      bitPos = 0;\n      UInt64 nowPos = outBuffer.GetProcessedSize();\n      if (progress && nowPos - prevPos >= (1 << 13))\n      {\n        prevPos = nowPos;\n        UInt64 packSize = inBuffer.GetProcessedSize();\n        RINOK(progress->SetRatioInfo(&packSize, &nowPos));\n      }\n    }\n    unsigned bytePos = bitPos >> 3;\n    UInt32 symbol = buf[bytePos] | ((UInt32)buf[(size_t)bytePos + 1] << 8) | ((UInt32)buf[(size_t)bytePos + 2] << 16);\n    symbol >>= (bitPos & 7);\n    symbol &= (1 << numBits) - 1;\n    bitPos += numBits;\n    if (bitPos > numBufBits)\n      break;\n    if (symbol >= head)\n    {\n      res = S_FALSE;\n      break;\n    }\n    if (symbol == blockSymbol)\n    {\n      numBufBits = bitPos = 0;\n      numBits = kNumMinBits;\n      head = 257;\n      needPrev = false;\n      continue;\n    }\n    UInt32 cur = symbol;\n    unsigned i = 0;\n    while (cur >= 256)\n    {\n      _stack[i++] = _suffixes[cur];\n      cur = _parents[cur];\n    }\n    _stack[i++] = (Byte)cur;\n    if (needPrev)\n    {\n      _suffixes[(size_t)head - 1] = (Byte)cur;\n      if (symbol == head - 1)\n        _stack[0] = (Byte)cur;\n    }\n    do\n      outBuffer.WriteByte((_stack[--i]));\n    while (i > 0);\n    if (head < numItems)\n    {\n      needPrev = true;\n      _parents[head++] = (UInt16)symbol;\n      if (head > ((UInt32)1 << numBits))\n      {\n        if (numBits < maxbits)\n        {\n          numBufBits = bitPos = 0;\n          numBits++;\n        }\n      }\n    }\n    else\n      needPrev = false;\n  }\n  PackSize = inBuffer.GetProcessedSize();\n  HRESULT res2 = outBuffer.Flush();\n  return (res == S_OK) ? res2 : res;\n}\n", "label": "compress"}
{"project": "7zip", "file": "ZDecoder.cpp", "func": "STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,\n    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)\n{\n  try { return CodeReal(inStream, outStream, inSize, outSize, progress); }\n  catch(const CInBufferException &e) { return e.ErrorCode; }\n  catch(const COutBufferException &e) { return e.ErrorCode; }\n  catch(...) { return S_FALSE; }\n}\n", "label": "compress"}
{"project": "7zip", "file": "ZDecoder.cpp", "func": "bool CheckStream(const Byte *data, size_t size)\n{\n  if (size < 3)\n    return false;\n  if (data[0] != 0x1F || data[1] != 0x9D)\n    return false;\n  Byte prop = data[2];\n  if ((prop & 0x60) != 0)\n    return false;\n  unsigned maxbits = prop & kNumBitsMask;\n  if (maxbits < kNumMinBits || maxbits > kNumMaxBits)\n    return false;\n  UInt32 numItems = 1 << maxbits;\n  UInt32 blockSymbol = ((prop & kBlockModeMask) != 0) ? 256 : ((UInt32)1 << kNumMaxBits);\n  unsigned numBits = kNumMinBits;\n  UInt32 head = (blockSymbol == 256) ? 257 : 256;\n  unsigned bitPos = 0;\n  unsigned numBufBits = 0;\n  Byte buf[kNumMaxBits + 4];\n  data += 3;\n  size -= 3;\n  // printf(\"\\n\\n\");\n  for (;;)\n  {\n    if (numBufBits == bitPos)\n    {\n      unsigned num = (numBits < size) ? numBits : (unsigned)size;\n      memcpy(buf, data, num);\n      data += num;\n      size -= num;\n      numBufBits = num * 8;\n      bitPos = 0;\n    }\n    unsigned bytePos = bitPos >> 3;\n    UInt32 symbol = buf[bytePos] | ((UInt32)buf[bytePos + 1] << 8) | ((UInt32)buf[bytePos + 2] << 16);\n    symbol >>= (bitPos & 7);\n    symbol &= (1 << numBits) - 1;\n    bitPos += numBits;\n    if (bitPos > numBufBits)\n    {\n      // printf(\"  OK\", symbol);\n      return true;\n    }\n    // printf(\"%3X \", symbol);\n    if (symbol >= head)\n      return false;\n    if (symbol == blockSymbol)\n    {\n      numBufBits = bitPos = 0;\n      numBits = kNumMinBits;\n      head = 257;\n      continue;\n    }\n    if (head < numItems)\n    {\n      head++;\n      if (head > ((UInt32)1 << numBits))\n      {\n        if (numBits < maxbits)\n        {\n          numBufBits = bitPos = 0;\n          numBits++;\n        }\n      }\n    }\n  }\n}\n", "label": "compress"}
{"project": "7zip", "file": "ZlibDecoder.cpp", "func": "UInt32 Adler32_Update(UInt32 adler, const Byte *buf, size_t size)\n{\n  UInt32 a = adler & 0xFFFF;\n  UInt32 b = (adler >> 16) & 0xFFFF;\n  while (size > 0)\n  {\n    unsigned curSize = (size > ADLER_LOOP_MAX) ? ADLER_LOOP_MAX : (unsigned )size;\n    unsigned i;\n    for (i = 0; i < curSize; i++)\n    {\n      a += buf[i];\n      b += a;\n    }\n    buf += curSize;\n    size -= curSize;\n    a %= ADLER_MOD;\n    b %= ADLER_MOD;\n  }\n  return (b << 16) + a;\n}\n", "label": "compress"}
{"project": "7zip", "file": "ZlibDecoder.cpp", "func": "STDMETHODIMP COutStreamWithAdler::Write(const void *data, UInt32 size, UInt32 *processedSize)\n{\n  HRESULT result = S_OK;\n  if (_stream)\n    result = _stream->Write(data, size, &size);\n  _adler = Adler32_Update(_adler, (const Byte *)data, size);\n  _size += size;\n  if (processedSize)\n    *processedSize = size;\n  return result;\n}\n", "label": "compress"}
{"project": "7zip", "file": "ZlibDecoder.cpp", "func": "STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,\n    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)\n{\n  DEFLATE_TRY_BEGIN\n  if (!AdlerStream)\n    AdlerStream = AdlerSpec = new COutStreamWithAdler;\n  if (!DeflateDecoder)\n  {\n    DeflateDecoderSpec = new NDeflate::NDecoder::CCOMCoder;\n    DeflateDecoderSpec->ZlibMode = true;\n    DeflateDecoder = DeflateDecoderSpec;\n  }\n\n  if (inSize && *inSize < 2)\n    return S_FALSE;\n  Byte buf[2];\n  RINOK(ReadStream_FALSE(inStream, buf, 2));\n  if (!IsZlib(buf))\n    return S_FALSE;\n\n  AdlerSpec->SetStream(outStream);\n  AdlerSpec->Init();\n  \n  UInt64 inSize2 = 0;\n  if (inSize)\n    inSize2 = *inSize - 2;\n\n  HRESULT res = DeflateDecoder->Code(inStream, AdlerStream, inSize ? &inSize2 : NULL, outSize, progress);\n  AdlerSpec->ReleaseStream();\n\n  if (res == S_OK)\n  {\n    const Byte *p = DeflateDecoderSpec->ZlibFooter;\n    UInt32 adler = ((UInt32)p[0] << 24) | ((UInt32)p[1] << 16) | ((UInt32)p[2] << 8) | p[3];\n    if (adler != AdlerSpec->GetAdler())\n      return S_FALSE;\n  }\n  return res;\n  DEFLATE_TRY_END\n}\n", "label": "compress"}
{"project": "7zip", "file": "ZlibEncoder.cpp", "func": "STDMETHODIMP CInStreamWithAdler::Read(void *data, UInt32 size, UInt32 *processedSize)\n{\n  HRESULT result = _stream->Read(data, size, &size);\n  _adler = Adler32_Update(_adler, (const Byte *)data, size);\n  _size += size;\n  if (processedSize != NULL)\n    *processedSize = size;\n  return result;\n}\n", "label": "compress"}
{"project": "7zip", "file": "ZlibEncoder.cpp", "func": "void CEncoder::Create()\n{\n  if (!DeflateEncoder)\n    DeflateEncoder = DeflateEncoderSpec = new NDeflate::NEncoder::CCOMCoder;\n}\n", "label": "compress"}
{"project": "7zip", "file": "ZlibEncoder.cpp", "func": "STDMETHODIMP CEncoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,\n    const UInt64 *inSize, const UInt64 * /* outSize */, ICompressProgressInfo *progress)\n{\n  DEFLATE_TRY_BEGIN\n  if (!AdlerStream)\n    AdlerStream = AdlerSpec = new CInStreamWithAdler;\n  Create();\n\n  {\n    Byte buf[2] = { 0x78, 0xDA };\n    RINOK(WriteStream(outStream, buf, 2));\n  }\n\n  AdlerSpec->SetStream(inStream);\n  AdlerSpec->Init();\n  HRESULT res = DeflateEncoder->Code(AdlerStream, outStream, inSize, NULL, progress);\n  AdlerSpec->ReleaseStream();\n\n  RINOK(res);\n\n  {\n    UInt32 a = AdlerSpec->GetAdler();\n    Byte buf[4] = { (Byte)(a >> 24), (Byte)(a >> 16), (Byte)(a >> 8), (Byte)(a) };\n    return WriteStream(outStream, buf, 4);\n  }\n  DEFLATE_TRY_END\n}\n", "label": "compress"}
{"project": "7zip", "file": "ZipStrong.cpp", "func": "static void DeriveKey2(const Byte *digest, Byte c, Byte *dest)\n{\n  Byte buf[64];\n  memset(buf, c, 64);\n  for (unsigned i = 0; i < NSha1::kDigestSize; i++)\n    buf[i] ^= digest[i];\n  NSha1::CContext sha;\n  sha.Init();\n  sha.Update(buf, 64);\n  sha.Final(dest);\n}\n", "label": "crypto"}
{"project": "7zip", "file": "ZipStrong.cpp", "func": "static void DeriveKey(NSha1::CContext &sha, Byte *key)\n{\n  Byte digest[NSha1::kDigestSize];\n  sha.Final(digest);\n  Byte temp[NSha1::kDigestSize * 2];\n  DeriveKey2(digest, 0x36, temp);\n  DeriveKey2(digest, 0x5C, temp + NSha1::kDigestSize);\n  memcpy(key, temp, 32);\n}\n", "label": "crypto"}
{"project": "7zip", "file": "ZipStrong.cpp", "func": "void CKeyInfo::SetPassword(const Byte *data, UInt32 size)\n{\n  NSha1::CContext sha;\n  sha.Init();\n  sha.Update(data, size);\n  DeriveKey(sha, MasterKey);\n}\n", "label": "crypto"}
{"project": "7zip", "file": "ZipStrong.cpp", "func": "STDMETHODIMP CBaseCoder::CryptoSetPassword(const Byte *data, UInt32 size)\n{\n  _key.SetPassword(data, size);\n  return S_OK;\n}\n", "label": "crypto"}
{"project": "7zip", "file": "ZipStrong.cpp", "func": "STDMETHODIMP CBaseCoder::Init()\n{\n  return S_OK;\n}\n", "label": "crypto"}
{"project": "7zip", "file": "ZipStrong.cpp", "func": "HRESULT CDecoder::ReadHeader(ISequentialInStream *inStream, UInt32 crc, UInt64 unpackSize)\n{\n  Byte temp[4];\n  RINOK(ReadStream_FALSE(inStream, temp, 2));\n  _ivSize = GetUi16(temp);\n  if (_ivSize == 0)\n  {\n    memset(_iv, 0, 16);\n    SetUi32(_iv + 0, crc);\n    SetUi64(_iv + 4, unpackSize);\n    _ivSize = 12;\n  }\n  else if (_ivSize == 16)\n  {\n    RINOK(ReadStream_FALSE(inStream, _iv, _ivSize));\n  }\n  else\n    return E_NOTIMPL;\n  RINOK(ReadStream_FALSE(inStream, temp, 4));\n  _remSize = GetUi32(temp);\n  // const UInt32 kAlign = 16;\n  if (_remSize < 16 || _remSize > (1 << 18))\n    return E_NOTIMPL;\n  if (_remSize > _bufAligned.Size())\n  {\n    _bufAligned.AllocAtLeast(_remSize);\n    if (!(Byte *)_bufAligned)\n      return E_OUTOFMEMORY;\n  }\n  return ReadStream_FALSE(inStream, _bufAligned, _remSize);\n}\n", "label": "crypto"}
{"project": "7zip", "file": "ZipStrong.cpp", "func": "HRESULT CDecoder::Init_and_CheckPassword(bool &passwOK)\n{\n  passwOK = false;\n  if (_remSize < 16)\n    return E_NOTIMPL;\n  Byte *p = _bufAligned;\n  UInt16 format = GetUi16(p);\n  if (format != 3)\n    return E_NOTIMPL;\n  UInt16 algId = GetUi16(p + 2);\n  if (algId < kAES128)\n    return E_NOTIMPL;\n  algId -= kAES128;\n  if (algId > 2)\n    return E_NOTIMPL;\n  UInt16 bitLen = GetUi16(p + 4);\n  UInt16 flags = GetUi16(p + 6);\n  if (algId * 64 + 128 != bitLen)\n    return E_NOTIMPL;\n  _key.KeySize = 16 + algId * 8;\n  bool cert = ((flags & 2) != 0);\n\n  if ((flags & 0x4000) != 0)\n  {\n    // Use 3DES for rd data\n    return E_NOTIMPL;\n  }\n\n  if (cert)\n  {\n    return E_NOTIMPL;\n  }\n  else\n  {\n    if ((flags & 1) == 0)\n      return E_NOTIMPL;\n  }\n\n  UInt32 rdSize = GetUi16(p + 8);\n\n  if (rdSize + 16 > _remSize)\n    return E_NOTIMPL;\n\n  const unsigned kPadSize = kAesPadAllign; // is equal to blockSize of cipher for rd\n\n  /*\n  if (cert)\n  {\n    if ((rdSize & 0x7) != 0)\n      return E_NOTIMPL;\n  }\n  else\n  */\n  {\n    // PKCS7 padding\n    if (rdSize < kPadSize)\n      return E_NOTIMPL;\n    if ((rdSize & (kPadSize - 1)) != 0)\n      return E_NOTIMPL;\n  }\n\n  memmove(p, p + 10, rdSize);\n  const Byte *p2 = p + rdSize + 10;\n  UInt32 reserved = GetUi32(p2);\n  p2 += 4;\n  \n  /*\n  if (cert)\n  {\n    UInt32 numRecipients = reserved;\n\n    if (numRecipients == 0)\n      return E_NOTIMPL;\n\n    {\n      UInt32 hashAlg = GetUi16(p2);\n      hashAlg = hashAlg;\n      UInt32 hashSize = GetUi16(p2 + 2);\n      hashSize = hashSize;\n      p2 += 4;\n\n      reserved = reserved;\n      // return E_NOTIMPL;\n\n      for (unsigned r = 0; r < numRecipients; r++)\n      {\n        UInt32 specSize = GetUi16(p2);\n        p2 += 2;\n        p2 += specSize;\n      }\n    }\n  }\n  else\n  */\n  {\n    if (reserved != 0)\n      return E_NOTIMPL;\n  }\n\n  UInt32 validSize = GetUi16(p2);\n  p2 += 2;\n  const size_t validOffset = p2 - p;\n  if ((validSize & 0xF) != 0 || validOffset + validSize != _remSize)\n    return E_NOTIMPL;\n\n  {\n    RINOK(SetKey(_key.MasterKey, _key.KeySize));\n    RINOK(SetInitVector(_iv, 16));\n    RINOK(Init());\n    Filter(p, rdSize);\n\n    rdSize -= kPadSize;\n    for (unsigned i = 0; i < kPadSize; i++)\n      if (p[(size_t)rdSize + i] != kPadSize)\n        return S_OK; // passwOK = false;\n  }\n\n  Byte fileKey[32];\n  NSha1::CContext sha;\n  sha.Init();\n  sha.Update(_iv, _ivSize);\n  sha.Update(p, rdSize);\n  DeriveKey(sha, fileKey);\n  \n  RINOK(SetKey(fileKey, _key.KeySize));\n  RINOK(SetInitVector(_iv, 16));\n  Init();\n\n  memmove(p, p + validOffset, validSize);\n  Filter(p, validSize);\n\n  if (validSize < 4)\n    return E_NOTIMPL;\n  validSize -= 4;\n  if (GetUi32(p + validSize) != CrcCalc(p, validSize))\n    return S_OK;\n  passwOK = true;\n  return S_OK;\n}\n", "label": "crypto"}
{"project": "7zip", "file": "SplitDialog.cpp", "func": "bool CSplitDialog::OnButtonClicked(int buttonID, HWND buttonHWND)\n{\n  switch (buttonID)\n  {\n    case IDB_SPLIT_PATH:\n      OnButtonSetPath();\n      return true;\n  }\n  return CModalDialog::OnButtonClicked(buttonID, buttonHWND);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SplitDialog.cpp", "func": "void CSplitDialog::OnButtonSetPath()\n{\n  UString currentPath;\n  _pathCombo.GetText(currentPath);\n  // UString title = \"Specify a location for output folder\";\n  UString title = LangString(IDS_SET_FOLDER);\n\n  UString resultPath;\n  if (!MyBrowseForFolder(*this, title, currentPath, resultPath))\n    return;\n  NFile::NName::NormalizeDirPathPrefix(resultPath);\n  _pathCombo.SetCurSel(-1);\n  _pathCombo.SetText(resultPath);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SplitDialog.cpp", "func": "void CSplitDialog::OnOK()\n{\n  _pathCombo.GetText(Path);\n  UString volumeString;\n  _volumeCombo.GetText(volumeString);\n  volumeString.Trim();\n  if (!ParseVolumeSizes(volumeString, VolumeSizes) || VolumeSizes.Size() == 0)\n  {\n    ::MessageBoxW(*this, LangString(IDS_INCORRECT_VOLUME_SIZE), L\"7-Zip\", MB_ICONERROR);\n    return;\n  }\n  CModalDialog::OnOK();\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SplitUtils.cpp", "func": "bool ParseVolumeSizes(const UString &s, CRecordVector<UInt64> &values)\n{\n  values.Clear();\n  bool prevIsNumber = false;\n  for (unsigned i = 0; i < s.Len();)\n  {\n    wchar_t c = s[i++];\n    if (c == L' ')\n      continue;\n    if (c == L'-')\n      return true;\n    if (prevIsNumber)\n    {\n      prevIsNumber = false;\n      unsigned numBits = 0;\n      switch (MyCharLower_Ascii(c))\n      {\n        case 'b': continue;\n        case 'k': numBits = 10; break;\n        case 'm': numBits = 20; break;\n        case 'g': numBits = 30; break;\n        case 't': numBits = 40; break;\n      }\n      if (numBits != 0)\n      {\n        UInt64 &val = values.Back();\n        if (val >= ((UInt64)1 << (64 - numBits)))\n          return false;\n        val <<= numBits;\n\n        for (; i < s.Len(); i++)\n          if (s[i] == L' ')\n            break;\n        continue;\n      }\n    }\n    i--;\n    const wchar_t *start = s.Ptr(i);\n    const wchar_t *end;\n    UInt64 val = ConvertStringToUInt64(start, &end);\n    if (start == end)\n      return false;\n    if (val == 0)\n      return false;\n    values.Add(val);\n    prevIsNumber = true;\n    i += (unsigned)(end - start);\n  }\n  return true;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SplitUtils.cpp", "func": "void AddVolumeItems(NWindows::NControl::CComboBox &combo)\n{\n  for (unsigned i = 0; i < ARRAY_SIZE(k_Sizes); i++)\n    combo.AddString(CSysString(k_Sizes[i]));\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SplitUtils.cpp", "func": "UInt64 GetNumberOfVolumes(UInt64 size, const CRecordVector<UInt64> &volSizes)\n{\n  if (size == 0 || volSizes.Size() == 0)\n    return 1;\n  FOR_VECTOR (i, volSizes)\n  {\n    UInt64 volSize = volSizes[i];\n    if (volSize >= size)\n      return i + 1;\n    size -= volSize;\n  }\n  UInt64 volSize = volSizes.Back();\n  if (volSize == 0)\n    return (UInt64)(Int64)-1;\n  return volSizes.Size() + (size - 1) / volSize + 1;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "StringUtils.cpp", "func": "void SplitStringToTwoStrings(const UString &src, UString &dest1, UString &dest2)\n{\n  dest1.Empty();\n  dest2.Empty();\n  bool quoteMode = false;\n  for (unsigned i = 0; i < src.Len(); i++)\n  {\n    const wchar_t c = src[i];\n    if (c == '\\\"')\n      quoteMode = !quoteMode;\n    else if (c == ' ' && !quoteMode)\n    {\n      dest2 = src.Ptr(i + 1);\n      return;\n    }\n    else\n      dest1 += c;\n  }\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "StringUtils.cpp", "func": "void SplitString(const UString &srcString, UStringVector &destStrings)\n{\n  destStrings.Clear();\n  unsigned len = srcString.Len();\n  if (len == 0)\n    return;\n  UString s;\n  for (unsigned i = 0; i < len; i++)\n  {\n    wchar_t c = srcString[i];\n    if (c == ' ')\n    {\n      if (!s.IsEmpty())\n      {\n        destStrings.Add(s);\n        s.Empty();\n      }\n    }\n    else\n      s += c;\n  }\n  if (!s.IsEmpty())\n    destStrings.Add(s);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SysIconUtils.cpp", "func": "int GetIconIndexForCSIDL(int csidl)\n{\n  LPITEMIDLIST pidl = 0;\n  SHGetSpecialFolderLocation(NULL, csidl, &pidl);\n  if (pidl)\n  {\n    SHFILEINFO shellInfo;\n    SHGetFileInfo(LPCTSTR(pidl), FILE_ATTRIBUTE_NORMAL,\n      &shellInfo, sizeof(shellInfo),\n      SHGFI_PIDL | SHGFI_SYSICONINDEX);\n    IMalloc  *pMalloc;\n    SHGetMalloc(&pMalloc);\n    if (pMalloc)\n    {\n      pMalloc->Free(pidl);\n      pMalloc->Release();\n    }\n    return shellInfo.iIcon;\n  }\n  return 0;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SysIconUtils.cpp", "func": "static DWORD_PTR MySHGetFileInfoW(LPCWSTR pszPath, DWORD attrib, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags)\n{\n  #ifdef _UNICODE\n  return SHGetFileInfo\n  #else\n  if (g_SHGetFileInfoInit.shGetFileInfoW == 0)\n    return 0;\n  return g_SHGetFileInfoInit.shGetFileInfoW\n  #endif\n  (pszPath, attrib, psfi, cbFileInfo, uFlags);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SysIconUtils.cpp", "func": "DWORD_PTR GetRealIconIndex(CFSTR path, DWORD attrib, int &iconIndex)\n{\n  #ifndef _UNICODE\n  if (!g_IsNT)\n  {\n    SHFILEINFO shellInfo;\n    DWORD_PTR res = ::SHGetFileInfo(fs2fas(path), FILE_ATTRIBUTE_NORMAL | attrib, &shellInfo,\n      sizeof(shellInfo), SHGFI_USEFILEATTRIBUTES | SHGFI_SYSICONINDEX);\n    iconIndex = shellInfo.iIcon;\n    return res;\n  }\n  else\n  #endif\n  {\n    SHFILEINFOW shellInfo;\n    DWORD_PTR res = ::MySHGetFileInfoW(fs2us(path), FILE_ATTRIBUTE_NORMAL | attrib, &shellInfo,\n      sizeof(shellInfo), SHGFI_USEFILEATTRIBUTES | SHGFI_SYSICONINDEX);\n    iconIndex = shellInfo.iIcon;\n    return res;\n  }\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SysIconUtils.cpp", "func": "static int FindInSorted_Attrib(const CRecordVector<CAttribIconPair> &vect, DWORD attrib, int &insertPos)\n{\n  unsigned left = 0, right = vect.Size();\n  while (left != right)\n  {\n    unsigned mid = (left + right) / 2;\n    DWORD midAttrib = vect[mid].Attrib;\n    if (attrib == midAttrib)\n      return mid;\n    if (attrib < midAttrib)\n      right = mid;\n    else\n      left = mid + 1;\n  }\n  insertPos = left;\n  return -1;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SysIconUtils.cpp", "func": "static int FindInSorted_Ext(const CObjectVector<CExtIconPair> &vect, const wchar_t *ext, int &insertPos)\n{\n  unsigned left = 0, right = vect.Size();\n  while (left != right)\n  {\n    unsigned mid = (left + right) / 2;\n    int compare = MyStringCompareNoCase(ext, vect[mid].Ext);\n    if (compare == 0)\n      return mid;\n    if (compare < 0)\n      right = mid;\n    else\n      left = mid + 1;\n  }\n  insertPos = left;\n  return -1;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SysIconUtils.cpp", "func": "int CExtToIconMap::GetIconIndex(DWORD attrib, const wchar_t *fileName /*, UString *typeName */)\n{\n  int dotPos = -1;\n  unsigned i;\n  for (i = 0;; i++)\n  {\n    wchar_t c = fileName[i];\n    if (c == 0)\n      break;\n    if (c == '.')\n      dotPos = i;\n  }\n\n  /*\n  if (MyStringCompareNoCase(fileName, L\"$Recycle.Bin\") == 0)\n  {\n    char s[256];\n    sprintf(s, \"SPEC i = %3d, attr = %7x\", _attribMap.Size(), attrib);\n    OutputDebugStringA(s);\n    OutputDebugStringW(fileName);\n  }\n  */\n\n  if ((attrib & FILE_ATTRIBUTE_DIRECTORY) != 0 || dotPos < 0)\n  {\n    int insertPos = 0;\n    int index = FindInSorted_Attrib(_attribMap, attrib, insertPos);\n    if (index >= 0)\n    {\n      // if (typeName) *typeName = _attribMap[index].TypeName;\n      return _attribMap[index].IconIndex;\n    }\n    CAttribIconPair pair;\n    GetRealIconIndex(\n        #ifdef UNDER_CE\n        FTEXT(\"\\\\\")\n        #endif\n        FTEXT(\"__DIR__\")\n        , attrib, pair.IconIndex\n        // , pair.TypeName\n        );\n\n    /*\n    char s[256];\n    sprintf(s, \"i = %3d, attr = %7x\", _attribMap.Size(), attrib);\n    OutputDebugStringA(s);\n    */\n\n    pair.Attrib = attrib;\n    _attribMap.Insert(insertPos, pair);\n    // if (typeName) *typeName = pair.TypeName;\n    return pair.IconIndex;\n  }\n\n  const wchar_t *ext = fileName + dotPos + 1;\n  int insertPos = 0;\n  int index = FindInSorted_Ext(_extMap, ext, insertPos);\n  if (index >= 0)\n  {\n    const CExtIconPair &pa = _extMap[index];\n    // if (typeName) *typeName = pa.TypeName;\n    return pa.IconIndex;\n  }\n\n  for (i = 0;; i++)\n  {\n    wchar_t c = ext[i];\n    if (c == 0)\n      break;\n    if (c < L'0' || c > L'9')\n      break;\n  }\n  if (i != 0 && ext[i] == 0)\n  {\n    // GetRealIconIndex is too slow for big number of split extensions: .001, .002, .003\n    if (!SplitIconIndex_Defined)\n    {\n      GetRealIconIndex(\n          #ifdef UNDER_CE\n          FTEXT(\"\\\\\")\n          #endif\n          FTEXT(\"__FILE__.001\"), 0, SplitIconIndex);\n      SplitIconIndex_Defined = true;\n    }\n    return SplitIconIndex;\n  }\n\n  CExtIconPair pair;\n  pair.Ext = ext;\n  GetRealIconIndex(us2fs(fileName + dotPos), attrib, pair.IconIndex);\n  _extMap.Insert(insertPos, pair);\n  // if (typeName) *typeName = pair.TypeName;\n  return pair.IconIndex;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SystemPage.cpp", "func": "CSysString CModifiedExtInfo::GetString() const\n{\n  if (State == kExtState_7Zip)\n    return TEXT(\"7-Zip\");\n  if (State == kExtState_Clear)\n    return TEXT(\"\");\n  if (Other7Zip)\n    return TEXT(\"[7-Zip]\");\n  return ProgramKey;\n};\n", "label": "FileManager"}
{"project": "7zip", "file": "SystemPage.cpp", "func": "int CSystemPage::AddIcon(const UString &iconPath, int iconIndex)\n{\n  if (iconPath.IsEmpty())\n    return -1;\n  if (iconIndex == -1)\n    iconIndex = 0;\n  \n  HICON hicon;\n  \n  #ifdef UNDER_CE\n  ExtractIconExW(iconPath, iconIndex, NULL, &hicon, 1);\n  if (!hicon)\n  #else\n  // we expand path from REG_EXPAND_SZ registry item.\n  UString path;\n  DWORD size = MAX_PATH + 10;\n  DWORD needLen = ::ExpandEnvironmentStringsW(iconPath, path.GetBuf(size + 2), size);\n  path.ReleaseBuf_CalcLen(size);\n  if (needLen == 0 || needLen >= size)\n    path = iconPath;\n  int num = ExtractIconExW(path, iconIndex, NULL, &hicon, 1);\n  if (num != 1 || !hicon)\n  #endif\n    return -1;\n  \n  _imageList.AddIcon(hicon);\n  DestroyIcon(hicon);\n  return _numIcons++;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SystemPage.cpp", "func": "void CSystemPage::RefreshListItem(unsigned group, unsigned listIndex)\n{\n  const CAssoc &assoc = _items[GetRealIndex(listIndex)];\n  _listView.SetSubItem(listIndex, group + 1, assoc.Pair[group].GetString());\n  LVITEMW newItem;\n  memset(&newItem, 0, sizeof(newItem));\n  newItem.iItem = listIndex;\n  newItem.mask = LVIF_IMAGE;\n  newItem.iImage = assoc.GetIconIndex();\n  _listView.SetItem(&newItem);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SystemPage.cpp", "func": "void CSystemPage::ChangeState(unsigned group, const CUIntVector &indices)\n{\n  if (indices.IsEmpty())\n    return;\n\n  bool thereAreClearItems = false;\n  unsigned counters[3] = { 0, 0, 0 };\n  \n  unsigned i;\n  for (i = 0; i < indices.Size(); i++)\n  {\n    const CModifiedExtInfo &mi = _items[GetRealIndex(indices[i])].Pair[group];\n    int state = kExtState_7Zip;\n    if (mi.State == kExtState_7Zip)\n      state = kExtState_Clear;\n    else if (mi.State == kExtState_Clear)\n    {\n      thereAreClearItems = true;\n      if (mi.Other)\n        state = kExtState_Other;\n    }\n    counters[state]++;\n  }\n\n  int state = kExtState_Clear;\n  if (counters[kExtState_Other] != 0)\n    state = kExtState_Other;\n  else if (counters[kExtState_7Zip] != 0)\n    state = kExtState_7Zip;\n  \n  for (i = 0; i < indices.Size(); i++)\n  {\n    unsigned listIndex = indices[i];\n    CAssoc &assoc = _items[GetRealIndex(listIndex)];\n    CModifiedExtInfo &mi = assoc.Pair[group];\n    bool change = false;\n    \n    switch (state)\n    {\n      case kExtState_Clear: change = true; break;\n      case kExtState_Other: change = mi.Other; break;\n      default: change = !(mi.Other && thereAreClearItems); break;\n    }\n    \n    if (change)\n    {\n      mi.State = state;\n      RefreshListItem(group, listIndex);\n    }\n  }\n  \n  _needSave = true;\n  Changed();\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SystemPage.cpp", "func": "bool CSystemPage::OnInit()\n{\n  _needSave = false;\n\n  LangSetDlgItems(*this, kLangIDs, ARRAY_SIZE(kLangIDs));\n\n  _listView.Attach(GetItem(IDL_SYSTEM_ASSOCIATE));\n  _listView.SetUnicodeFormat();\n  DWORD newFlags = LVS_EX_FULLROWSELECT;\n  _listView.SetExtendedListViewStyle(newFlags, newFlags);\n\n  _numIcons = 0;\n  _imageList.Create(16, 16, ILC_MASK | ILC_COLOR32, 0, 0);\n\n  _listView.SetImageList(_imageList, LVSIL_SMALL);\n\n  _listView.InsertColumn(0, LangString(IDS_PROP_FILE_TYPE), 72);\n\n  UString s;\n\n  #if NUM_EXT_GROUPS == 1\n    s = \"Program\";\n  #else\n    #ifndef UNDER_CE\n      const unsigned kSize = 256;\n      BOOL res;\n\n      DWORD size = kSize;\n\n      #ifndef _UNICODE\n      if (!g_IsNT)\n      {\n        AString s2;\n        res = GetUserNameA(s2.GetBuf(size), &size);\n        s2.ReleaseBuf_CalcLen(MyMin((unsigned)size, kSize));\n        s = GetUnicodeString(s2);\n      }\n      else\n      #endif\n      {\n        res = GetUserNameW(s.GetBuf(size), &size);\n        s.ReleaseBuf_CalcLen(MyMin((unsigned)size, kSize));\n      }\n    \n      if (!res)\n    #endif\n        s = \"Current User\";\n  #endif\n\n  LV_COLUMNW ci;\n  ci.mask = LVCF_TEXT | LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;\n  ci.cx = 128;\n  ci.fmt = LVCFMT_CENTER;\n  ci.pszText = (WCHAR *)(const WCHAR *)s;\n  ci.iSubItem = 1;\n  _listView.InsertColumn(1, &ci);\n\n  #if NUM_EXT_GROUPS > 1\n  {\n    LangString(IDS_SYSTEM_ALL_USERS, s);\n    ci.pszText = (WCHAR *)(const WCHAR *)s;\n    ci.iSubItem = 2;\n    _listView.InsertColumn(2, &ci);\n  }\n  #endif\n\n  _extDB.Read();\n  _items.Clear();\n\n  FOR_VECTOR (i, _extDB.Exts)\n  {\n    const CExtPlugins &extInfo = _extDB.Exts[i];\n\n    LVITEMW item;\n    item.iItem = i;\n    item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;\n    item.lParam = i;\n    item.iSubItem = 0;\n    // ListView always uses internal iImage that is 0 by default?\n    // so we always use LVIF_IMAGE.\n    item.iImage = -1;\n    item.pszText = (wchar_t *)(const wchar_t *)(LPCWSTR)extInfo.Ext;\n\n    CAssoc assoc;\n    const CPluginToIcon &plug = extInfo.Plugins[0];\n    assoc.SevenZipImageIndex = AddIcon(plug.IconPath, plug.IconIndex);\n\n    CSysString texts[NUM_EXT_GROUPS];\n    unsigned g;\n    for (g = 0; g < NUM_EXT_GROUPS; g++)\n    {\n      CModifiedExtInfo &mi = assoc.Pair[g];\n      mi.ReadFromRegistry(GetHKey(g), GetSystemString(extInfo.Ext));\n      mi.SetState(plug.IconPath);\n      mi.ImageIndex = AddIcon(mi.IconPath, mi.IconIndex);\n      texts[g] = mi.GetString();\n    }\n    item.iImage = assoc.GetIconIndex();\n    int itemIndex = _listView.InsertItem(&item);\n    for (g = 0; g < NUM_EXT_GROUPS; g++)\n      _listView.SetSubItem(itemIndex, 1 + g, texts[g]);\n    _items.Add(assoc);\n  }\n  \n  if (_listView.GetItemCount() > 0)\n    _listView.SetItemState(0, LVIS_FOCUSED, LVIS_FOCUSED);\n\n  return CPropertyPage::OnInit();\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SystemPage.cpp", "func": "static UString GetProgramCommand()\n{\n  UString s ('\\\"');\n  s += fs2us(NDLL::GetModuleDirPrefix());\n  s += \"7zFM.exe\\\" \\\"%1\\\"\";\n  return s;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SystemPage.cpp", "func": "LONG CSystemPage::OnApply()\n{\n  if (!_needSave)\n    return PSNRET_NOERROR;\n\n  const UString command = GetProgramCommand();\n  \n  LONG res = 0;\n\n  FOR_VECTOR (listIndex, _extDB.Exts)\n  {\n    unsigned realIndex = GetRealIndex(listIndex);\n    const CExtPlugins &extInfo = _extDB.Exts[realIndex];\n    CAssoc &assoc = _items[realIndex];\n\n    for (unsigned g = 0; g < NUM_EXT_GROUPS; g++)\n    {\n      CModifiedExtInfo &mi = assoc.Pair[g];\n      HKEY key = GetHKey(g);\n      \n      if (mi.OldState != mi.State)\n      {\n        LONG res2 = 0;\n        \n        if (mi.State == kExtState_7Zip)\n        {\n          UString title = extInfo.Ext;\n          title += \" Archive\";\n          const CPluginToIcon &plug = extInfo.Plugins[0];\n          res2 = NRegistryAssoc::AddShellExtensionInfo(key, GetSystemString(extInfo.Ext),\n              title, command, plug.IconPath, plug.IconIndex);\n        }\n        else if (mi.State == kExtState_Clear)\n          res2 = NRegistryAssoc::DeleteShellExtensionInfo(key, GetSystemString(extInfo.Ext));\n        \n        if (res == 0)\n          res = res2;\n        if (res2 == 0)\n          mi.OldState = mi.State;\n        \n        mi.State = mi.OldState;\n        RefreshListItem(g, listIndex);\n      }\n    }\n  }\n  \n  #ifndef UNDER_CE\n  SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);\n  #endif\n\n  WasChanged = true;\n\n  _needSave = false;\n  \n  if (res != 0)\n    MessageBoxW(*this, NError::MyFormatMessage(res), L\"7-Zip\", MB_ICONERROR);\n  \n  return PSNRET_NOERROR;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SystemPage.cpp", "func": "void CSystemPage::OnNotifyHelp()\n{\n  ShowHelpWindow(kSystemTopic);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SystemPage.cpp", "func": "bool CSystemPage::OnButtonClicked(int buttonID, HWND buttonHWND)\n{\n  switch (buttonID)\n  {\n    /*\n    case IDC_SYSTEM_SELECT_ALL:\n      _listView.SelectAll();\n      return true;\n    */\n    case IDB_SYSTEM_CURRENT:\n    case IDB_SYSTEM_ALL:\n      ChangeState(buttonID == IDB_SYSTEM_CURRENT ? 0 : 1);\n      return true;\n  }\n  return CPropertyPage::OnButtonClicked(buttonID, buttonHWND);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SystemPage.cpp", "func": "bool CSystemPage::OnNotify(UINT controlID, LPNMHDR lParam)\n{\n  if (lParam->hwndFrom == HWND(_listView))\n  {\n    switch (lParam->code)\n    {\n      case NM_RETURN:\n      {\n        ChangeState(0);\n        return true;\n      }\n\n      case NM_CLICK:\n      {\n        #ifdef UNDER_CE\n        NMLISTVIEW *item = (NMLISTVIEW *)lParam;\n        #else\n        NMITEMACTIVATE *item = (NMITEMACTIVATE *)lParam;\n        if (item->uKeyFlags == 0)\n        #endif\n        {\n          if (item->iItem >= 0)\n          {\n            // unsigned realIndex = GetRealIndex(item->iItem);\n            if (item->iSubItem >= 1 && item->iSubItem <= 2)\n            {\n              CUIntVector indices;\n              indices.Add(item->iItem);\n              ChangeState(item->iSubItem < 2 ? 0 : 1, indices);\n            }\n          }\n        }\n        break;\n      }\n      \n      case LVN_KEYDOWN:\n      {\n        if (OnListKeyDown(LPNMLVKEYDOWN(lParam)))\n          return true;\n        break;\n      }\n      \n      /*\n      case NM_RCLICK:\n      case NM_DBLCLK:\n      case LVN_BEGINRDRAG:\n        // PostMessage(kRefreshpluginsListMessage, 0);\n        PostMessage(kUpdateDatabase, 0);\n        break;\n      */\n    }\n  }\n  return CPropertyPage::OnNotify(controlID, lParam);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SystemPage.cpp", "func": "void CSystemPage::ChangeState(unsigned group)\n{\n  CUIntVector indices;\n  \n  int itemIndex = -1;\n  while ((itemIndex = _listView.GetNextSelectedItem(itemIndex)) != -1)\n    indices.Add(itemIndex);\n  \n  if (indices.IsEmpty())\n    FOR_VECTOR (i, _items)\n      indices.Add(i);\n  \n  ChangeState(group, indices);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "SystemPage.cpp", "func": "bool CSystemPage::OnListKeyDown(LPNMLVKEYDOWN keyDownInfo)\n{\n  bool ctrl = IsKeyDown(VK_CONTROL);\n  bool alt = IsKeyDown(VK_MENU);\n\n  if (alt)\n    return false;\n\n  if ((ctrl && keyDownInfo->wVKey == 'A')\n      || (!ctrl && keyDownInfo->wVKey == VK_MULTIPLY))\n  {\n    _listView.SelectAll();\n    return true;\n  }\n\n  switch (keyDownInfo->wVKey)\n  {\n    case VK_SPACE:\n    case VK_ADD:\n    case VK_SUBTRACT:\n    case VK_SEPARATOR:\n    case VK_DIVIDE:\n\n    #ifndef UNDER_CE\n    case VK_OEM_PLUS:\n    case VK_OEM_MINUS:\n    #endif\n\n      if (!ctrl)\n      {\n        ChangeState(keyDownInfo->wVKey == VK_SPACE ? 0 : 1);\n        return true;\n      }\n      break;\n  }\n\n  return false;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "TextPairs.cpp", "func": "static bool IsSeparatorChar(wchar_t c)\n{\n  return (c == ' ' || c == '\\t');\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "TextPairs.cpp", "func": "static void RemoveCr(UString &s)\n{\n  s.RemoveChar(L'\\x0D');\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "TextPairs.cpp", "func": "static UString GetIDString(const wchar_t *srcString, unsigned &finishPos)\n{\n  UString result;\n  bool quotes = false;\n  for (finishPos = 0;;)\n  {\n    wchar_t c = srcString[finishPos];\n    if (c == 0)\n      break;\n    finishPos++;\n    bool isSeparatorChar = IsSeparatorChar(c);\n    if (c == kNewLineChar || (isSeparatorChar && !quotes)\n        || (c == kQuoteChar && quotes))\n      break;\n    else if (c == kQuoteChar)\n      quotes = true;\n    else\n      result += c;\n  }\n  result.Trim();\n  RemoveCr(result);\n  return result;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "TextPairs.cpp", "func": "static UString GetValueString(const wchar_t *srcString, unsigned &finishPos)\n{\n  UString result;\n  for (finishPos = 0;;)\n  {\n    wchar_t c = srcString[finishPos];\n    if (c == 0)\n      break;\n    finishPos++;\n    if (c == kNewLineChar)\n      break;\n    result += c;\n  }\n  result.Trim();\n  RemoveCr(result);\n  return result;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "TextPairs.cpp", "func": "static bool GetTextPairs(const UString &srcString, CObjectVector<CTextPair> &pairs)\n{\n  pairs.Clear();\n  unsigned pos = 0;\n  \n  if (srcString.Len() > 0)\n  {\n    if (srcString[0] == kBOM)\n      pos++;\n  }\n  while (pos < srcString.Len())\n  {\n    unsigned finishPos;\n    UString id = GetIDString((const wchar_t *)srcString + pos, finishPos);\n    pos += finishPos;\n    if (id.IsEmpty())\n      continue;\n    UString value = GetValueString((const wchar_t *)srcString + pos, finishPos);\n    pos += finishPos;\n    if (!id.IsEmpty())\n    {\n      CTextPair pair;\n      pair.ID = id;\n      pair.Value = value;\n      pairs.Add(pair);\n    }\n  }\n  return true;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "TextPairs.cpp", "func": "int CPairsStorage::FindID(const UString &id, int &insertPos) const\n{\n  int left = 0, right = Pairs.Size();\n  while (left != right)\n  {\n    int mid = (left + right) / 2;\n    int compResult = ComparePairIDs(id, Pairs[mid].ID);\n    if (compResult == 0)\n      return mid;\n    if (compResult < 0)\n      right = mid;\n    else\n      left = mid + 1;\n  }\n  insertPos = left;\n  return -1;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "TextPairs.cpp", "func": "int CPairsStorage::FindID(const UString &id) const\n{\n  int pos;\n  return FindID(id, pos);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "TextPairs.cpp", "func": "void CPairsStorage::AddPair(const CTextPair &pair)\n{\n  int insertPos;\n  int pos = FindID(pair.ID, insertPos);\n  if (pos >= 0)\n    Pairs[pos] = pair;\n  else\n    Pairs.Insert(insertPos, pair);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "TextPairs.cpp", "func": "void CPairsStorage::DeletePair(const UString &id)\n{\n  int pos = FindID(id);\n  if (pos >= 0)\n    Pairs.Delete(pos);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "TextPairs.cpp", "func": "bool CPairsStorage::GetValue(const UString &id, UString &value) const\n{\n  value.Empty();\n  int pos = FindID(id);\n  if (pos < 0)\n    return false;\n  value = Pairs[pos].Value;\n  return true;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "TextPairs.cpp", "func": "UString CPairsStorage::GetValue(const UString &id) const\n{\n  int pos = FindID(id);\n  if (pos < 0)\n    return UString();\n  return Pairs[pos].Value;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "TextPairs.cpp", "func": "bool CPairsStorage::ReadFromString(const UString &text)\n{\n  bool result = ::GetTextPairs(text, Pairs);\n  if (result)\n    Sort();\n  else\n    Pairs.Clear();\n  return result;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "TextPairs.cpp", "func": "void CPairsStorage::SaveToString(UString &text) const\n{\n  FOR_VECTOR (i, Pairs)\n  {\n    const CTextPair &pair = Pairs[i];\n    bool multiWord = (pair.ID.Find(L' ') >= 0);\n    if (multiWord)\n      text += '\\\"';\n    text += pair.ID;\n    if (multiWord)\n      text += '\\\"';\n    text += ' ';\n    text += pair.Value;\n    text += '\\x0D';\n    text.Add_LF();\n  }\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::ScanProgress(UInt64 /* numFolders */, UInt64 numFiles, UInt64 totalSize, const wchar_t *path, Int32 /* isDir */)\n{\n  return ProgressDialog->Sync.ScanProgress(numFiles, totalSize, us2fs(path));\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::ScanError(const wchar_t *path, HRESULT errorCode)\n{\n  ProgressDialog->Sync.AddError_Code_Name(errorCode, path);\n  return S_OK;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::SetNumFiles(UInt64 numFiles)\n{\n  return ProgressDialog->Sync.Set_NumFilesTotal(numFiles);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::SetTotal(UInt64 size)\n{\n  ProgressDialog->Sync.Set_NumBytesTotal(size);\n  return S_OK;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::SetCompleted(const UInt64 *completed)\n{\n  return ProgressDialog->Sync.Set_NumBytesCur(completed);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::SetRatioInfo(const UInt64 *inSize, const UInt64 *outSize)\n{\n  ProgressDialog->Sync.Set_Ratio(inSize, outSize);\n  return S_OK;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::CompressOperation(const wchar_t *name)\n{\n  return SetOperation_Base(NUpdateNotifyOp::kAdd, name, false);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::DeleteOperation(const wchar_t *name)\n{\n  return SetOperation_Base(NUpdateNotifyOp::kDelete, name, false);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::OperationResult(Int32 /* operationResult */)\n{\n  ProgressDialog->Sync.Set_NumFilesCur(++NumFiles);\n  return S_OK;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "HRESULT CUpdateCallback100Imp::ReportExtractResult(Int32 opRes, Int32 isEncrypted, const wchar_t *name)\n{\n  if (opRes != NArchive::NExtract::NOperationResult::kOK)\n  {\n    UString s;\n    SetExtractErrorMessage(opRes, isEncrypted, name, s);\n    ProgressDialog->Sync.AddError_Message(s);\n  }\n  return S_OK;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "HRESULT CUpdateCallback100Imp::ReportUpdateOperation(UInt32 notifyOp, const wchar_t *name, Int32 isDir)\n{\n  return SetOperation_Base(notifyOp, name, IntToBool(isDir));\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::UpdateErrorMessage(const wchar_t *message)\n{\n  ProgressDialog->Sync.AddError_Message(message);\n  return S_OK;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "HRESULT CUpdateCallback100Imp::OpenFileError(const wchar_t *path, HRESULT errorCode)\n{\n  ProgressDialog->Sync.AddError_Code_Name(errorCode, path);\n  return S_OK;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::ReadingFileError(const wchar_t *path, HRESULT errorCode)\n{\n  ProgressDialog->Sync.AddError_Code_Name(errorCode, path);\n  return S_OK;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::CryptoGetTextPassword2(Int32 *passwordIsDefined, BSTR *password)\n{\n  *password = NULL;\n  *passwordIsDefined = BoolToInt(PasswordIsDefined);\n  if (!PasswordIsDefined)\n    return S_OK;\n  return StringToBstr(Password, password);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::SetTotal(const UInt64 * /* files */, const UInt64 * /* bytes */)\n{\n  return S_OK;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::SetCompleted(const UInt64 * /* files */, const UInt64 * /* bytes */)\n{\n  return ProgressDialog->Sync.CheckStop();\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallback100.cpp", "func": "STDMETHODIMP CUpdateCallback100Imp::CryptoGetTextPassword(BSTR *password)\n{\n  *password = NULL;\n  if (!PasswordIsDefined)\n  {\n    RINOK(ShowAskPasswordDialog())\n  }\n  return StringToBstr(Password, password);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "void CListViewInfo::Save(const UString &id) const\n{\n  const UInt32 dataSize = kListViewHeaderSize + kColumnInfoSize * Columns.Size();\n  CByteArr buf(dataSize);\n\n  Set32(buf, kListViewVersion);\n  Set32(buf + 4, SortID);\n  SetBool(buf + 8, Ascending);\n  FOR_VECTOR (i, Columns)\n  {\n    const CColumnInfo &column = Columns[i];\n    Byte *p = buf + kListViewHeaderSize + i * kColumnInfoSize;\n    Set32(p, column.PropID);\n    SetBool(p + 4, column.IsVisible);\n    Set32(p + 8, column.Width);\n  }\n  {\n    NSynchronization::CCriticalSectionLock lock(g_CS);\n    CKey key;\n    key.Create(HKEY_CURRENT_USER, kCulumnsKeyName);\n    key.SetValue(GetSystemString(id), (const Byte *)buf, dataSize);\n  }\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "void CListViewInfo::Read(const UString &id)\n{\n  Clear();\n  CByteBuffer buf;\n  UInt32 size;\n  {\n    NSynchronization::CCriticalSectionLock lock(g_CS);\n    CKey key;\n    if (key.Open(HKEY_CURRENT_USER, kCulumnsKeyName, KEY_READ) != ERROR_SUCCESS)\n      return;\n    if (key.QueryValue(GetSystemString(id), buf, size) != ERROR_SUCCESS)\n      return;\n  }\n  if (size < kListViewHeaderSize)\n    return;\n  UInt32 version;\n  Get32(buf, version);\n  if (version != kListViewVersion)\n    return;\n  Get32(buf + 4, SortID);\n  GetBool(buf + 8, Ascending);\n\n  IsLoaded = true;\n\n  size -= kListViewHeaderSize;\n  if (size % kColumnInfoSize != 0)\n    return;\n  unsigned numItems = size / kColumnInfoSize;\n  Columns.ClearAndReserve(numItems);\n  for (unsigned i = 0; i < numItems; i++)\n  {\n    CColumnInfo column;\n    const Byte *p = buf + kListViewHeaderSize + i * kColumnInfoSize;\n    Get32(p, column.PropID);\n    GetBool(p + 4, column.IsVisible);\n    Get32(p + 8, column.Width);\n    Columns.AddInReserved(column);\n  }\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "void CWindowInfo::Save() const\n{\n  NSynchronization::CCriticalSectionLock lock(g_CS);\n  CKey key;\n  key.Create(HKEY_CURRENT_USER, kCUBasePath);\n  {\n    Byte buf[kWindowPositionHeaderSize];\n    Set32(buf,      rect.left);\n    Set32(buf +  4, rect.top);\n    Set32(buf +  8, rect.right);\n    Set32(buf + 12, rect.bottom);\n    SetBool(buf + 16, maximized);\n    key.SetValue(kPositionValueName, buf, kWindowPositionHeaderSize);\n  }\n  {\n    Byte buf[kPanelsInfoHeaderSize];\n    Set32(buf,      numPanels);\n    Set32(buf +  4, currentPanel);\n    Set32(buf +  8, splitterPos);\n    key.SetValue(kPanelsInfoValueName, buf, kPanelsInfoHeaderSize);\n  }\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "static bool QueryBuf(CKey &key, LPCTSTR name, CByteBuffer &buf, UInt32 dataSize)\n{\n  UInt32 size;\n  return key.QueryValue(name, buf, size) == ERROR_SUCCESS && size == dataSize;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "void CWindowInfo::Read(bool &windowPosDefined, bool &panelInfoDefined)\n{\n  windowPosDefined = false;\n  panelInfoDefined = false;\n  NSynchronization::CCriticalSectionLock lock(g_CS);\n  CKey key;\n  if (key.Open(HKEY_CURRENT_USER, kCUBasePath, KEY_READ) != ERROR_SUCCESS)\n    return;\n  CByteBuffer buf;\n  if (QueryBuf(key, kPositionValueName, buf, kWindowPositionHeaderSize))\n  {\n    Get32(buf,      rect.left);\n    Get32(buf +  4, rect.top);\n    Get32(buf +  8, rect.right);\n    Get32(buf + 12, rect.bottom);\n    GetBool(buf + 16, maximized);\n    windowPosDefined = true;\n  }\n  if (QueryBuf(key, kPanelsInfoValueName, buf, kPanelsInfoHeaderSize))\n  {\n    Get32(buf,      numPanels);\n    Get32(buf +  4, currentPanel);\n    Get32(buf +  8, splitterPos);\n    panelInfoDefined = true;\n  }\n  return;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "void SaveUi32Val(const TCHAR *name, UInt32 value)\n{\n  CKey key;\n  key.Create(HKEY_CURRENT_USER, kCUBasePath);\n  key.SetValue(name, value);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "bool ReadUi32Val(const TCHAR *name, UInt32 &value)\n{\n  CKey key;\n  if (key.Open(HKEY_CURRENT_USER, kCUBasePath, KEY_READ) != ERROR_SUCCESS)\n    return false;\n  return key.QueryValue(name, value) == ERROR_SUCCESS;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "void SaveToolbarsMask(UInt32 toolbarMask)\n{\n  SaveUi32Val(kToolbars, toolbarMask);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "UInt32 ReadToolbarsMask()\n{\n  UInt32 mask;\n  if (!ReadUi32Val(kToolbars, mask))\n    return kDefaultToolbarMask;\n  return mask;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "void CListMode::Save() const\n{\n  UInt32 t = 0;\n  for (int i = 0; i < 2; i++)\n    t |= ((Panels[i]) & 0xFF) << (i * 8);\n  SaveUi32Val(kListMode, t);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "void CListMode::Read()\n{\n  Init();\n  UInt32 t;\n  if (!ReadUi32Val(kListMode, t))\n    return;\n  for (int i = 0; i < 2; i++)\n  {\n    Panels[i] = (t & 0xFF);\n    t >>= 8;\n  }\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "static UString GetPanelPathName(UInt32 panelIndex)\n{\n  UString s (kPanelPathValueName);\n  s.Add_UInt32(panelIndex);\n  return s;\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "void SavePanelPath(UInt32 panel, const UString &path)\n{\n  NSynchronization::CCriticalSectionLock lock(g_CS);\n  CKey key;\n  key.Create(HKEY_CURRENT_USER, kCUBasePath);\n  key.SetValue(GetPanelPathName(panel), path);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "bool ReadPanelPath(UInt32 panel, UString &path)\n{\n  NSynchronization::CCriticalSectionLock lock(g_CS);\n  CKey key;\n  if (key.Open(HKEY_CURRENT_USER, kCUBasePath, KEY_READ) != ERROR_SUCCESS)\n    return false;\n  return (key.QueryValue(GetPanelPathName(panel), path) == ERROR_SUCCESS);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "static void SaveStringList(LPCTSTR valueName, const UStringVector &folders)\n{\n  NSynchronization::CCriticalSectionLock lock(g_CS);\n  CKey key;\n  key.Create(HKEY_CURRENT_USER, kCUBasePath);\n  key.SetValue_Strings(valueName, folders);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "static void ReadStringList(LPCTSTR valueName, UStringVector &folders)\n{\n  folders.Clear();\n  NSynchronization::CCriticalSectionLock lock(g_CS);\n  CKey key;\n  if (key.Open(HKEY_CURRENT_USER, kCUBasePath, KEY_READ) == ERROR_SUCCESS)\n    key.GetValue_Strings(valueName, folders);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "ViewSettings.cpp", "func": "void AddUniqueStringToHeadOfList(UStringVector &list, const UString &s)\n{\n  for (unsigned i = 0; i < list.Size();)\n    if (s.IsEqualTo_NoCase(list[i]))\n      list.Delete(i);\n    else\n      i++;\n  list.Insert(0, s);\n}\n", "label": "FileManager"}
{"project": "7zip", "file": "UpdateCallbackGUI.cpp", "func": "HRESULT CUpdateCallbackGUI::WriteSfx(const wchar_t * /* name */, UInt64 /* size */)\n{\n  CProgressSync &sync = ProgressDialog->Sync;\n  sync.Set_Status(L\"WriteSfx\");\n  return S_OK;\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateCallbackGUI.cpp", "func": "HRESULT CUpdateCallbackGUI::Open_Finished()\n{\n  // ClosePercents();\n  return S_OK;\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateCallbackGUI2.cpp", "func": "void CUpdateCallbackGUI2::Init()\n{\n  NumFiles = 0;\n\n  _lang_Removing = LangString(IDS_PROGRESS_REMOVE);\n  _lang_Ops.Clear();\n  for (unsigned i = 0; i < ARRAY_SIZE(k_UpdNotifyLangs); i++)\n    _lang_Ops.Add(LangString(k_UpdNotifyLangs[i]));\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateCallbackGUI2.cpp", "func": "HRESULT CUpdateCallbackGUI2::SetOperation_Base(UInt32 notifyOp, const wchar_t *name, bool isDir)\n{\n  const UString *s = NULL;\n  if (notifyOp < _lang_Ops.Size())\n    s = &(_lang_Ops[(unsigned)notifyOp]);\n  else\n    s = &_emptyString;\n\n  return ProgressDialog->Sync.Set_Status2(*s, name, isDir);\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateCallbackGUI2.cpp", "func": "HRESULT CUpdateCallbackGUI2::ShowAskPasswordDialog()\n{\n  CPasswordDialog dialog;\n  ProgressDialog->WaitCreating();\n  if (dialog.Create(*ProgressDialog) != IDOK)\n    return E_ABORT;\n  Password = dialog.Password;\n  PasswordIsDefined = true;\n  return S_OK;\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateGUI.cpp", "func": "HRESULT CThreadUpdating::ProcessVirt()\n{\n  CUpdateErrorInfo ei;\n  HRESULT res = UpdateArchive(codecs, *formatIndices, *cmdArcPath,\n      *WildcardCensor, *Options,\n      ei, UpdateCallbackGUI, UpdateCallbackGUI, needSetPath);\n  FinalMessage.ErrorMessage.Message = ei.Message.Ptr();\n  ErrorPaths = ei.FileNames;\n  if (ei.SystemError != S_OK && ei.SystemError != E_FAIL && ei.SystemError != E_ABORT)\n    return ei.SystemError;\n  return res;\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateGUI.cpp", "func": "static void AddProp(CObjectVector<CProperty> &properties, const char *name, const UString &value)\n{\n  CProperty prop;\n  prop.Name = name;\n  prop.Value = value;\n  properties.Add(prop);\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateGUI.cpp", "func": "static void AddProp(CObjectVector<CProperty> &properties, const char *name, UInt32 value)\n{\n  char tmp[32];\n  ConvertUInt64ToString(value, tmp);\n  AddProp(properties, name, UString(tmp));\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateGUI.cpp", "func": "static void AddProp(CObjectVector<CProperty> &properties, const char *name, bool value)\n{\n  AddProp(properties, name, UString(value ? \"on\": \"off\"));\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateGUI.cpp", "func": "static bool IsThereMethodOverride(bool is7z, const UString &propertiesString)\n{\n  UStringVector strings;\n  SplitString(propertiesString, strings);\n  FOR_VECTOR (i, strings)\n  {\n    const UString &s = strings[i];\n    if (is7z)\n    {\n      const wchar_t *end;\n      UInt64 n = ConvertStringToUInt64(s, &end);\n      if (n == 0 && *end == L'=')\n        return true;\n    }\n    else\n    {\n      if (s.Len() > 0)\n        if (s[0] == L'm' && s[1] == L'=')\n          return true;\n    }\n  }\n  return false;\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateGUI.cpp", "func": "static void ParseAndAddPropertires(CObjectVector<CProperty> &properties,\n    const UString &propertiesString)\n{\n  UStringVector strings;\n  SplitString(propertiesString, strings);\n  FOR_VECTOR (i, strings)\n  {\n    const UString &s = strings[i];\n    CProperty property;\n    int index = s.Find(L'=');\n    if (index < 0)\n      property.Name = s;\n    else\n    {\n      property.Name.SetFrom(s, index);\n      property.Value = s.Ptr(index + 1);\n    }\n    properties.Add(property);\n  }\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateGUI.cpp", "func": "static UString GetNumInBytesString(UInt64 v)\n{\n  char s[32];\n  ConvertUInt64ToString(v, s);\n  size_t len = MyStringLen(s);\n  s[len++] = 'B';\n  s[len] = '\\0';\n  return UString(s);\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateGUI.cpp", "func": "static void SetOutProperties(\n    CObjectVector<CProperty> &properties,\n    bool is7z,\n    UInt32 level,\n    bool setMethod,\n    const UString &method,\n    UInt32 dictionary,\n    bool orderMode,\n    UInt32 order,\n    bool solidIsSpecified, UInt64 solidBlockSize,\n    bool multiThreadIsAllowed, UInt32 numThreads,\n    const UString &encryptionMethod,\n    bool encryptHeadersIsAllowed, bool encryptHeaders,\n    bool /* sfxMode */)\n{\n  if (level != (UInt32)(Int32)-1)\n    AddProp(properties, \"x\", (UInt32)level);\n  if (setMethod)\n  {\n    if (!method.IsEmpty())\n      AddProp(properties, is7z ? \"0\": \"m\", method);\n    if (dictionary != (UInt32)(Int32)-1)\n    {\n      AString name;\n      if (is7z)\n        name = \"0\";\n      name += (orderMode ? \"mem\" : \"d\");\n      AddProp(properties, name, GetNumInBytesString(dictionary));\n    }\n    if (order != (UInt32)(Int32)-1)\n    {\n      AString name;\n      if (is7z)\n        name = \"0\";\n      name += (orderMode ? \"o\" : \"fb\");\n      AddProp(properties, name, (UInt32)order);\n    }\n  }\n    \n  if (!encryptionMethod.IsEmpty())\n    AddProp(properties, \"em\", encryptionMethod);\n\n  if (encryptHeadersIsAllowed)\n    AddProp(properties, \"he\", encryptHeaders);\n  if (solidIsSpecified)\n    AddProp(properties, \"s\", GetNumInBytesString(solidBlockSize));\n  if (multiThreadIsAllowed)\n    AddProp(properties, \"mt\", numThreads);\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateGUI.cpp", "func": "static int FindActionSet(const NUpdateArchive::CActionSet &actionSet)\n{\n  for (unsigned i = 0; i < ARRAY_SIZE(g_UpdateMode_Pairs); i++)\n    if (actionSet.IsEqualTo(*g_UpdateMode_Pairs[i].ActionSet))\n      return i;\n  return -1;\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateGUI.cpp", "func": "static int FindUpdateMode(NCompressDialog::NUpdateMode::EEnum mode)\n{\n  for (unsigned i = 0; i < ARRAY_SIZE(g_UpdateMode_Pairs); i++)\n    if (mode == g_UpdateMode_Pairs[i].UpdateMode)\n      return i;\n  return -1;\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateGUI.cpp", "func": "static HRESULT ShowDialog(\n    CCodecs *codecs,\n    const CObjectVector<NWildcard::CCensorPath> &censor,\n    CUpdateOptions &options,\n    CUpdateCallbackGUI *callback, HWND hwndParent)\n{\n  if (options.Commands.Size() != 1)\n    throw \"It must be one command\";\n  /*\n  FString currentDirPrefix;\n  #ifndef UNDER_CE\n  {\n    if (!MyGetCurrentDirectory(currentDirPrefix))\n      return E_FAIL;\n    NName::NormalizeDirPathPrefix(currentDirPrefix);\n  }\n  #endif\n  */\n\n  bool oneFile = false;\n  NFind::CFileInfo fileInfo;\n  UString name;\n  \n  /*\n  if (censor.Pairs.Size() > 0)\n  {\n    const NWildcard::CPair &pair = censor.Pairs[0];\n    if (pair.Head.IncludeItems.Size() > 0)\n    {\n      const NWildcard::CItem &item = pair.Head.IncludeItems[0];\n      if (item.ForFile)\n      {\n        name = pair.Prefix;\n        FOR_VECTOR (i, item.PathParts)\n        {\n          if (i > 0)\n            name.Add_PathSepar();\n          name += item.PathParts[i];\n        }\n        if (fileInfo.Find(us2fs(name)))\n        {\n          if (censor.Pairs.Size() == 1 && pair.Head.IncludeItems.Size() == 1)\n            oneFile = !fileInfo.IsDir();\n        }\n      }\n    }\n  }\n  */\n  if (censor.Size() > 0)\n  {\n    const NWildcard::CCensorPath &cp = censor[0];\n    if (cp.Include)\n    {\n      {\n        if (fileInfo.Find(us2fs(cp.Path)))\n        {\n          if (censor.Size() == 1)\n            oneFile = !fileInfo.IsDir();\n        }\n      }\n    }\n  }\n\n  \n  #if defined(_WIN32) && !defined(UNDER_CE)\n  CCurrentDirRestorer curDirRestorer;\n  #endif\n  CCompressDialog dialog;\n  NCompressDialog::CInfo &di = dialog.Info;\n  dialog.ArcFormats = &codecs->Formats;\n\n  if (options.MethodMode.Type_Defined)\n    di.FormatIndex = options.MethodMode.Type.FormatIndex;\n  \n  FOR_VECTOR (i, codecs->Formats)\n  {\n    const CArcInfoEx &ai = codecs->Formats[i];\n    if (!ai.UpdateEnabled)\n      continue;\n    if (!oneFile && ai.Flags_KeepName())\n      continue;\n    if ((int)i != di.FormatIndex)\n      if (ai.Name.IsEqualTo_Ascii_NoCase(\"swfc\"))\n        if (!oneFile || name.Len() < 4 || !StringsAreEqualNoCase_Ascii(name.RightPtr(4), \".swf\"))\n          continue;\n    dialog.ArcIndices.Add(i);\n  }\n  if (dialog.ArcIndices.IsEmpty())\n  {\n    ShowErrorMessage(L\"No Update Engines\");\n    return E_FAIL;\n  }\n\n  // di.ArchiveName = options.ArchivePath.GetFinalPath();\n  di.ArcPath = options.ArchivePath.GetPathWithoutExt();\n  dialog.OriginalFileName = fs2us(fileInfo.Name);\n\n  di.PathMode = options.PathMode;\n    \n  // di.CurrentDirPrefix = currentDirPrefix;\n  di.SFXMode = options.SfxMode;\n  di.OpenShareForWrite = options.OpenShareForWrite;\n  di.DeleteAfterCompressing = options.DeleteAfterCompressing;\n\n  di.SymLinks = options.SymLinks;\n  di.HardLinks = options.HardLinks;\n  di.AltStreams = options.AltStreams;\n  di.NtSecurity = options.NtSecurity;\n  \n  if (callback->PasswordIsDefined)\n    di.Password = callback->Password;\n    \n  di.KeepName = !oneFile;\n\n  NUpdateArchive::CActionSet &actionSet = options.Commands.Front().ActionSet;\n \n  {\n    int index = FindActionSet(actionSet);\n    if (index < 0)\n      return E_NOTIMPL;\n    di.UpdateMode = g_UpdateMode_Pairs[(unsigned)index].UpdateMode;\n  }\n\n  if (dialog.Create(hwndParent) != IDOK)\n    return E_ABORT;\n\n  options.DeleteAfterCompressing = di.DeleteAfterCompressing;\n\n  options.SymLinks = di.SymLinks;\n  options.HardLinks = di.HardLinks;\n  options.AltStreams = di.AltStreams;\n  options.NtSecurity = di.NtSecurity;\n \n  #if defined(_WIN32) && !defined(UNDER_CE)\n  curDirRestorer.NeedRestore = dialog.CurrentDirWasChanged;\n  #endif\n  \n  options.VolumesSizes = di.VolumeSizes;\n  /*\n  if (di.VolumeSizeIsDefined)\n  {\n    MyMessageBox(L\"Splitting to volumes is not supported\");\n    return E_FAIL;\n  }\n  */\n\n \n  {\n    int index = FindUpdateMode(di.UpdateMode);\n    if (index < 0)\n      return E_FAIL;\n    actionSet = *g_UpdateMode_Pairs[index].ActionSet;\n  }\n\n  options.PathMode = di.PathMode;\n\n  const CArcInfoEx &archiverInfo = codecs->Formats[di.FormatIndex];\n  callback->PasswordIsDefined = (!di.Password.IsEmpty());\n  if (callback->PasswordIsDefined)\n    callback->Password = di.Password;\n\n  options.MethodMode.Properties.Clear();\n\n  bool is7z = archiverInfo.Name.IsEqualTo_Ascii_NoCase(\"7z\");\n  bool methodOverride = IsThereMethodOverride(is7z, di.Options);\n\n  SetOutProperties(\n      options.MethodMode.Properties,\n      is7z,\n      di.Level,\n      !methodOverride,\n      di.Method,\n      di.Dictionary,\n      di.OrderMode, di.Order,\n      di.SolidIsSpecified, di.SolidBlockSize,\n      di.MultiThreadIsAllowed, di.NumThreads,\n      di.EncryptionMethod,\n      di.EncryptHeadersIsAllowed, di.EncryptHeaders,\n      di.SFXMode);\n  \n  options.OpenShareForWrite = di.OpenShareForWrite;\n  ParseAndAddPropertires(options.MethodMode.Properties, di.Options);\n\n  if (di.SFXMode)\n    options.SfxMode = true;\n  options.MethodMode.Type = COpenType();\n  options.MethodMode.Type_Defined = true;\n  options.MethodMode.Type.FormatIndex = di.FormatIndex;\n\n  options.ArchivePath.VolExtension = archiverInfo.GetMainExt();\n  if (di.SFXMode)\n    options.ArchivePath.BaseExtension = kSFXExtension;\n  else\n    options.ArchivePath.BaseExtension = options.ArchivePath.VolExtension;\n  options.ArchivePath.ParseFromPath(di.ArcPath, k_ArcNameMode_Smart);\n\n  NWorkDir::CInfo workDirInfo;\n  workDirInfo.Load();\n  options.WorkingDir.Empty();\n  if (workDirInfo.Mode != NWorkDir::NMode::kCurrent)\n  {\n    FString fullPath;\n    MyGetFullPathName(us2fs(di.ArcPath), fullPath);\n    FString namePart;\n    options.WorkingDir = GetWorkDir(workDirInfo, fullPath, namePart);\n    CreateComplexDir(options.WorkingDir);\n  }\n  return S_OK;\n}\n", "label": "GUI"}
{"project": "7zip", "file": "UpdateGUI.cpp", "func": "HRESULT UpdateGUI(\n    CCodecs *codecs,\n    const CObjectVector<COpenType> &formatIndices,\n    const UString &cmdArcPath,\n    NWildcard::CCensor &censor,\n    CUpdateOptions &options,\n    bool showDialog,\n    bool &messageWasDisplayed,\n    CUpdateCallbackGUI *callback,\n    HWND hwndParent)\n{\n  messageWasDisplayed = false;\n  bool needSetPath  = true;\n  if (showDialog)\n  {\n    RINOK(ShowDialog(codecs, censor.CensorPaths, options, callback, hwndParent));\n    needSetPath = false;\n  }\n  if (options.SfxMode && options.SfxModule.IsEmpty())\n  {\n    options.SfxModule = NWindows::NDLL::GetModuleDirPrefix();\n    options.SfxModule += kDefaultSfxModule;\n  }\n\n  CThreadUpdating tu;\n\n  tu.needSetPath = needSetPath;\n\n  tu.codecs = codecs;\n  tu.formatIndices = &formatIndices;\n  tu.cmdArcPath = &cmdArcPath;\n\n  tu.UpdateCallbackGUI = callback;\n  tu.UpdateCallbackGUI->ProgressDialog = &tu;\n  tu.UpdateCallbackGUI->Init();\n\n  UString title = LangString(IDS_PROGRESS_COMPRESSING);\n\n  /*\n  if (hwndParent != 0)\n  {\n    tu.ProgressDialog.MainWindow = hwndParent;\n    // tu.ProgressDialog.MainTitle = fileName;\n    tu.ProgressDialog.MainAddTitle = title + L' ';\n  }\n  */\n\n  tu.WildcardCensor = &censor;\n  tu.Options = &options;\n  tu.IconID = IDI_ICON;\n\n  RINOK(tu.Create(title, hwndParent));\n\n  messageWasDisplayed = tu.ThreadFinishedOK && tu.MessagesDisplayed;\n  return tu.Result;\n}\n", "label": "GUI"}
{"project": "esp-idf", "file": "httpd_uri.c", "func": "static httpd_uri_t* httpd_find_uri_handler(struct httpd_data *hd,\n                                           const char *uri, size_t uri_len,\n                                           httpd_method_t method,\n                                           httpd_err_code_t *err)\n{\n    if (err) {\n        *err = HTTPD_404_NOT_FOUND;\n    }\n\n    for (int i = 0; i < hd->config.max_uri_handlers; i++) {\n        if (!hd->hd_calls[i]) {\n            break;\n        }\n        ESP_LOGD(TAG, LOG_FMT(\"[%d] = %s\"), i, hd->hd_calls[i]->uri);\n\n        /* Check if custom URI matching function is set,\n         * else use simple string compare */\n        if (hd->config.uri_match_fn ?\n            hd->config.uri_match_fn(hd->hd_calls[i]->uri, uri, uri_len) :\n            httpd_uri_match_simple(hd->hd_calls[i]->uri, uri, uri_len)) {\n            /* URIs match. Now check if method is supported */\n            if (hd->hd_calls[i]->method == method) {\n                /* Match found! */\n                if (err) {\n                    /* Unset any error that may\n                     * have been set earlier */\n                    *err = 0;\n                }\n                return hd->hd_calls[i];\n            }\n            /* URI found but method not allowed.\n             * If URI is found later then this\n             * error must be set to 0 */\n            if (err) {\n                *err = HTTPD_405_METHOD_NOT_ALLOWED;\n            }\n        }\n    }\n    return NULL;\n}\n", "label": "network"}
{"project": "esp-idf", "file": "httpd_uri.c", "func": "esp_err_t httpd_register_uri_handler(httpd_handle_t handle,\n                                     const httpd_uri_t *uri_handler)\n{\n    if (handle == NULL || uri_handler == NULL) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    struct httpd_data *hd = (struct httpd_data *) handle;\n\n    /* Make sure another handler with matching URI and method\n     * is not already registered. This will also catch cases\n     * when a registered URI wildcard pattern already accounts\n     * for the new URI being registered */\n    if (httpd_find_uri_handler(handle, uri_handler->uri,\n                               strlen(uri_handler->uri),\n                               uri_handler->method, NULL) != NULL) {\n        ESP_LOGW(TAG, LOG_FMT(\"handler %s with method %d already registered\"),\n                 uri_handler->uri, uri_handler->method);\n        return ESP_ERR_HTTPD_HANDLER_EXISTS;\n    }\n\n    for (int i = 0; i < hd->config.max_uri_handlers; i++) {\n        if (hd->hd_calls[i] == NULL) {\n            hd->hd_calls[i] = malloc(sizeof(httpd_uri_t));\n            if (hd->hd_calls[i] == NULL) {\n                /* Failed to allocate memory */\n                return ESP_ERR_HTTPD_ALLOC_MEM;\n            }\n\n            /* Copy URI string */\n            hd->hd_calls[i]->uri = strdup(uri_handler->uri);\n            if (hd->hd_calls[i]->uri == NULL) {\n                /* Failed to allocate memory */\n                free(hd->hd_calls[i]);\n                return ESP_ERR_HTTPD_ALLOC_MEM;\n            }\n\n            /* Copy remaining members */\n            hd->hd_calls[i]->method   = uri_handler->method;\n            hd->hd_calls[i]->handler  = uri_handler->handler;\n            hd->hd_calls[i]->user_ctx = uri_handler->user_ctx;\n#ifdef CONFIG_HTTPD_WS_SUPPORT\n            hd->hd_calls[i]->is_websocket = uri_handler->is_websocket;\n            hd->hd_calls[i]->handle_ws_control_frames = uri_handler->handle_ws_control_frames;\n            if (uri_handler->supported_subprotocol) {\n                hd->hd_calls[i]->supported_subprotocol = strdup(uri_handler->supported_subprotocol);\n            } else {\n                hd->hd_calls[i]->supported_subprotocol = NULL;\n            }\n#endif\n            ESP_LOGD(TAG, LOG_FMT(\"[%d] installed %s\"), i, uri_handler->uri);\n            return ESP_OK;\n        }\n        ESP_LOGD(TAG, LOG_FMT(\"[%d] exists %s\"), i, hd->hd_calls[i]->uri);\n    }\n    ESP_LOGW(TAG, LOG_FMT(\"no slots left for registering handler\"));\n    return ESP_ERR_HTTPD_HANDLERS_FULL;\n}\n", "label": "network"}
{"project": "esp-idf", "file": "httpd_uri.c", "func": "esp_err_t httpd_unregister_uri_handler(httpd_handle_t handle,\n                                       const char *uri, httpd_method_t method)\n{\n    if (handle == NULL || uri == NULL) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    struct httpd_data *hd = (struct httpd_data *) handle;\n    for (int i = 0; i < hd->config.max_uri_handlers; i++) {\n        if (!hd->hd_calls[i]) {\n            break;\n        }\n        if ((hd->hd_calls[i]->method == method) &&       // First match methods\n            (strcmp(hd->hd_calls[i]->uri, uri) == 0)) {  // Then match URI string\n            ESP_LOGD(TAG, LOG_FMT(\"[%d] removing %s\"), i, hd->hd_calls[i]->uri);\n\n            free((char*)hd->hd_calls[i]->uri);\n            free(hd->hd_calls[i]);\n            hd->hd_calls[i] = NULL;\n\n            /* Shift the remaining non null handlers in the array\n             * forward by 1 so that order of insertion is maintained */\n            for (i += 1; i < hd->config.max_uri_handlers; i++) {\n                if (!hd->hd_calls[i]) {\n                    break;\n                }\n                hd->hd_calls[i-1] = hd->hd_calls[i];\n            }\n            /* Nullify the following non null entry */\n            hd->hd_calls[i-1] = NULL;\n            return ESP_OK;\n        }\n    }\n    ESP_LOGW(TAG, LOG_FMT(\"handler %s with method %d not found\"), uri, method);\n    return ESP_ERR_NOT_FOUND;\n}\n", "label": "network"}
{"project": "esp-idf", "file": "httpd_uri.c", "func": "esp_err_t httpd_unregister_uri(httpd_handle_t handle, const char *uri)\n{\n    if (handle == NULL || uri == NULL) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    struct httpd_data *hd = (struct httpd_data *) handle;\n    bool found = false;\n\n    int i = 0, j = 0; // For keeping count of removed entries\n    for (; i < hd->config.max_uri_handlers; i++) {\n        if (!hd->hd_calls[i]) {\n            break;\n        }\n        if (strcmp(hd->hd_calls[i]->uri, uri) == 0) {   // Match URI strings\n            ESP_LOGD(TAG, LOG_FMT(\"[%d] removing %s\"), i, uri);\n\n            free((char*)hd->hd_calls[i]->uri);\n            free(hd->hd_calls[i]);\n            hd->hd_calls[i] = NULL;\n            found = true;\n\n            j++; // Update count of removed entries\n        } else {\n            /* Shift the remaining non null handlers in the array\n             * forward by j so that order of insertion is maintained */\n            hd->hd_calls[i-j] = hd->hd_calls[i];\n        }\n    }\n    /* Nullify the following non null entries */\n    for (int k = (i - j); k < i; k++) {\n        hd->hd_calls[k] = NULL;\n    }\n\n    if (!found) {\n        ESP_LOGW(TAG, LOG_FMT(\"no handler found for URI %s\"), uri);\n    }\n    return (found ? ESP_OK : ESP_ERR_NOT_FOUND);\n}\n", "label": "network"}
{"project": "esp-idf", "file": "httpd_uri.c", "func": "void httpd_unregister_all_uri_handlers(struct httpd_data *hd)\n{\n    for (unsigned i = 0; i < hd->config.max_uri_handlers; i++) {\n        if (!hd->hd_calls[i]) {\n            break;\n        }\n        ESP_LOGD(TAG, LOG_FMT(\"[%d] removing %s\"), i, hd->hd_calls[i]->uri);\n\n        free((char*)hd->hd_calls[i]->uri);\n        free(hd->hd_calls[i]);\n        hd->hd_calls[i] = NULL;\n    }\n}\n", "label": "network"}
{"project": "esp-idf", "file": "httpd_uri.c", "func": "esp_err_t httpd_uri(struct httpd_data *hd)\n{\n    httpd_uri_t            *uri = NULL;\n    httpd_req_t            *req = &hd->hd_req;\n    struct http_parser_url *res = &hd->hd_req_aux.url_parse_res;\n\n    /* For conveying URI not found/method not allowed */\n    httpd_err_code_t err = 0;\n\n    ESP_LOGD(TAG, LOG_FMT(\"request for %s with type %d\"), req->uri, req->method);\n\n    /* URL parser result contains offset and length of path string */\n    if (res->field_set & (1 << UF_PATH)) {\n        uri = httpd_find_uri_handler(hd, req->uri + res->field_data[UF_PATH].off,\n                                     res->field_data[UF_PATH].len, req->method, &err);\n    }\n\n    /* If URI with method not found, respond with error code */\n    if (uri == NULL) {\n        switch (err) {\n            case HTTPD_404_NOT_FOUND:\n                ESP_LOGW(TAG, LOG_FMT(\"URI '%s' not found\"), req->uri);\n                return httpd_req_handle_err(req, HTTPD_404_NOT_FOUND);\n            case HTTPD_405_METHOD_NOT_ALLOWED:\n                ESP_LOGW(TAG, LOG_FMT(\"Method '%d' not allowed for URI '%s'\"),\n                         req->method, req->uri);\n                return httpd_req_handle_err(req, HTTPD_405_METHOD_NOT_ALLOWED);\n            default:\n                return ESP_FAIL;\n        }\n    }\n\n    /* Attach user context data (passed during URI registration) into request */\n    req->user_ctx = uri->user_ctx;\n\n    /* Final step for a WebSocket handshake verification */\n#ifdef CONFIG_HTTPD_WS_SUPPORT\n    struct httpd_req_aux   *aux = req->aux;\n    if (uri->is_websocket && aux->ws_handshake_detect && uri->method == HTTP_GET) {\n        ESP_LOGD(TAG, LOG_FMT(\"Responding WS handshake to sock %d\"), aux->sd->fd);\n        esp_err_t ret = httpd_ws_respond_server_handshake(&hd->hd_req, uri->supported_subprotocol);\n        if (ret != ESP_OK) {\n            return ret;\n        }\n\n        aux->sd->ws_handshake_done = true;\n        aux->sd->ws_handler = uri->handler;\n        aux->sd->ws_control_frames = uri->handle_ws_control_frames;\n        aux->sd->ws_user_ctx = uri->user_ctx;\n    }\n#endif\n\n    /* Invoke handler */\n    if (uri->handler(req) != ESP_OK) {\n        /* Handler returns error, this socket should be closed */\n        ESP_LOGW(TAG, LOG_FMT(\"uri handler execution failed\"));\n        return ESP_FAIL;\n    }\n    return ESP_OK;\n}\n", "label": "network"}
{"project": "esp-idf", "file": "ctrl_sock.c", "func": "int cs_create_ctrl_sock(int port)\n{\n    int fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n    if (fd < 0) {\n        return -1;\n    }\n\n    int ret;\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(port);\n    inet_aton(\"127.0.0.1\", &addr.sin_addr);\n    ret = bind(fd, (struct sockaddr *)&addr, sizeof(addr));\n    if (ret < 0) {\n        close(fd);\n        return -1;\n    }\n    return fd;\n}\n", "label": "network"}
{"project": "esp-idf", "file": "ctrl_sock.c", "func": "void cs_free_ctrl_sock(int fd)\n{\n    close(fd);\n}\n", "label": "network"}
{"project": "esp-idf", "file": "ctrl_sock.c", "func": "int cs_send_to_ctrl_sock(int send_fd, int port, void *data, unsigned int data_len)\n{\n    int ret;\n    struct sockaddr_in to_addr;\n    to_addr.sin_family = AF_INET;\n    to_addr.sin_port = htons(port);\n    inet_aton(\"127.0.0.1\", &to_addr.sin_addr);\n    ret = sendto(send_fd, data, data_len, 0, (struct sockaddr *)&to_addr, sizeof(to_addr));\n\n    if (ret < 0) {\n        return -1;\n    }\n    return ret;\n}\n", "label": "network"}
{"project": "esp-idf", "file": "ctrl_sock.c", "func": "int cs_recv_from_ctrl_sock(int fd, void *data, unsigned int data_len)\n{\n    int ret;\n    ret = recvfrom(fd, data, data_len, 0, NULL, NULL);\n\n    if (ret < 0) {\n        return -1;\n    }\n    return ret;\n}\n", "label": "network"}
{"project": "esp-idf", "file": "test_http_server.c", "func": "esp_err_t null_func(httpd_req_t *req)\n{\n    return ESP_OK;\n}\n", "label": "network"}
{"project": "esp-idf", "file": "test_http_server.c", "func": "httpd_uri_t handler_limit_uri (char* path)\n{\n    httpd_uri_t uri = {\n        .uri      = path,\n        .method   = HTTP_GET,\n        .handler  = null_func,\n        .user_ctx = NULL,\n    };\n    return uri;\n};\n", "label": "network"}
{"project": "esp-idf", "file": "test_http_server.c", "func": "static inline unsigned num_digits(unsigned x)\n{\n    unsigned digits = 1;\n    while ((x = x/10) != 0) {\n        digits++;\n    }\n    return digits;\n}\n", "label": "network"}
{"project": "esp-idf", "file": "test_http_server.c", "func": "void test_handler_limit(httpd_handle_t hd)\n{\n    int i;\n    char x[HTTPD_TEST_MAX_URI_HANDLERS+1][num_digits(HTTPD_TEST_MAX_URI_HANDLERS)+1];\n    httpd_uri_t uris[HTTPD_TEST_MAX_URI_HANDLERS+1];\n\n    for (i = 0; i < HTTPD_TEST_MAX_URI_HANDLERS + 1; i++) {\n        sprintf(x[i],\"%d\",i);\n        uris[i] = handler_limit_uri(x[i]);\n    }\n\n    /* Register multiple instances of the same handler for MAX URI Handlers */\n    for (i = 0; i < HTTPD_TEST_MAX_URI_HANDLERS; i++) {\n        TEST_ASSERT(httpd_register_uri_handler(hd, &uris[i]) == ESP_OK);\n    }\n\n    /* Register the MAX URI + 1 Handlers should fail */\n    TEST_ASSERT(httpd_register_uri_handler(hd, &uris[HTTPD_TEST_MAX_URI_HANDLERS]) != ESP_OK);\n\n    /* Unregister the one of the Handler should pass */\n    TEST_ASSERT(httpd_unregister_uri_handler(hd, uris[0].uri, uris[0].method) == ESP_OK);\n\n    /* Unregister non added Handler should fail */\n    TEST_ASSERT(httpd_unregister_uri_handler(hd, uris[0].uri, uris[0].method) != ESP_OK);\n\n    /* Register the MAX URI Handler should pass */\n    TEST_ASSERT(httpd_register_uri_handler(hd, &uris[0]) == ESP_OK);\n\n    /* Reregister same instance of handler should fail */\n    TEST_ASSERT(httpd_register_uri_handler(hd, &uris[0]) != ESP_OK);\n\n    /* Register the MAX URI + 1 Handlers should fail */\n    TEST_ASSERT(httpd_register_uri_handler(hd, &uris[HTTPD_TEST_MAX_URI_HANDLERS]) != ESP_OK);\n\n    /* Unregister the same handler for MAX URI Handlers */\n    for (i = 0; i < HTTPD_TEST_MAX_URI_HANDLERS; i++) {\n        TEST_ASSERT(httpd_unregister_uri_handler(hd, uris[i].uri, uris[i].method) == ESP_OK);\n    }\n    basic_sanity = false;\n}\n", "label": "network"}
{"project": "esp-idf", "file": "test_http_server.c", "func": "httpd_handle_t test_httpd_start(uint16_t id)\n{\n    httpd_handle_t hd;\n    httpd_config_t config = HTTPD_DEFAULT_CONFIG();\n    config.max_uri_handlers = HTTPD_TEST_MAX_URI_HANDLERS;\n    config.server_port += id;\n    config.ctrl_port += id;\n    TEST_ASSERT(httpd_start(&hd, &config) == ESP_OK)\n    return hd;\n}\n", "label": "network"}
{"project": "esp-idf", "file": "test_http_server.c", "func": "TEST_CASE(\"Leak Test\", \"[HTTP SERVER]\")\n{\n    httpd_handle_t hd[SERVER_INSTANCES];\n    unsigned task_count;\n    bool res = true;\n\n    test_case_uses_tcpip();\n\n    task_count = uxTaskGetNumberOfTasks();\n    printf(\"Initial task count: %d\\n\", task_count);\n\n    pre_start_mem = esp_get_free_heap_size();\n\n    for (int i = 0; i < SERVER_INSTANCES; i++) {\n        hd[i] = test_httpd_start(i);\n        vTaskDelay(10);\n        unsigned num_tasks = uxTaskGetNumberOfTasks();\n        task_count++;\n        if (num_tasks != task_count) {\n            printf(\"Incorrect task count (starting): %d expected %d\\n\",\n                   num_tasks, task_count);\n            res = false;\n        }\n    }\n\n    for (int i = 0; i < SERVER_INSTANCES; i++) {\n        if (httpd_stop(hd[i]) != ESP_OK) {\n            printf(\"Failed to stop httpd task %d\\n\", i);\n            res = false;\n        }\n        vTaskDelay(10);\n        unsigned num_tasks = uxTaskGetNumberOfTasks();\n        task_count--;\n        if (num_tasks != task_count) {\n            printf(\"Incorrect task count (stopping): %d expected %d\\n\",\n                   num_tasks, task_count);\n            res = false;\n        }\n    }\n    post_stop_mem = esp_get_free_heap_size();\n    TEST_ASSERT(res == true);\n}\n", "label": "network"}
{"project": "esp-idf", "file": "test_http_server.c", "func": "TEST_CASE(\"Basic Functionality Tests\", \"[HTTP SERVER]\")\n{\n    httpd_handle_t hd;\n    httpd_config_t config = HTTPD_DEFAULT_CONFIG();\n\n    test_case_uses_tcpip();\n\n    TEST_ASSERT(httpd_start(&hd, &config) == ESP_OK);\n    test_handler_limit(hd);\n    TEST_ASSERT(httpd_stop(hd) == ESP_OK);\n}\n", "label": "network"}
{"project": "esp-idf", "file": "test_http_server.c", "func": "TEST_CASE(\"URI Wildcard Matcher Tests\", \"[HTTP SERVER]\")\n{\n    struct uritest {\n        const char *template;\n        const char *uri;\n        bool matches;\n    };\n\n    struct uritest uris[] = {\n        {\"/\", \"/\", true},\n        {\"\", \"\", true},\n        {\"/\", \"\", false},\n        {\"/wrong\", \"/\", false},\n        {\"/\", \"/wrong\", false},\n        {\"/asdfghjkl/qwertrtyyuiuioo\", \"/asdfghjkl/qwertrtyyuiuioo\", true},\n        {\"/path\", \"/path\", true},\n        {\"/path\", \"/path/\", false},\n        {\"/path/\", \"/path\", false},\n\n        {\"?\", \"\", false}, // this is not valid, but should not crash\n        {\"?\", \"sfsdf\", false},\n\n        {\"/path/?\", \"/pa\", false},\n        {\"/path/?\", \"/path\", true},\n        {\"/path/?\", \"/path/\", true},\n        {\"/path/?\", \"/path/alalal\", false},\n\n        {\"/path/*\", \"/path\", false},\n        {\"/path/*\", \"/\", false},\n        {\"/path/*\", \"/path/\", true},\n        {\"/path/*\", \"/path/blabla\", true},\n\n        {\"*\", \"\", true},\n        {\"*\", \"/\", true},\n        {\"*\", \"/aaa\", true},\n\n        {\"/path/?*\", \"/pat\", false},\n        {\"/path/?*\", \"/pathb\", false},\n        {\"/path/?*\", \"/pathxx\", false},\n        {\"/path/?*\", \"/pathblabla\", false},\n        {\"/path/?*\", \"/path\", true},\n        {\"/path/?*\", \"/path/\", true},\n        {\"/path/?*\", \"/path/blabla\", true},\n\n        {\"/path/*?\", \"/pat\", false},\n        {\"/path/*?\", \"/pathb\", false},\n        {\"/path/*?\", \"/pathxx\", false},\n        {\"/path/*?\", \"/path\", true},\n        {\"/path/*?\", \"/path/\", true},\n        {\"/path/*?\", \"/path/blabla\", true},\n\n        {\"/path/*/xxx\", \"/path/\", false},\n        {\"/path/*/xxx\", \"/path/*/xxx\", true},\n        {}\n    };\n\n    struct uritest *ut = &uris[0];\n\n    while(ut->template != 0) {\n        bool match = httpd_uri_match_wildcard(ut->template, ut->uri, strlen(ut->uri));\n        TEST_ASSERT(match == ut->matches);\n        ut++;\n    }\n}\n", "label": "network"}
{"project": "esp-idf", "file": "test_http_server.c", "func": "TEST_CASE(\"Max Allowed Sockets Test\", \"[HTTP SERVER]\")\n{\n    test_case_uses_tcpip();\n\n    httpd_handle_t hd;\n    httpd_config_t config = HTTPD_DEFAULT_CONFIG();\n\n    /* Starting server with default config options should pass */\n    TEST_ASSERT(httpd_start(&hd, &config) == ESP_OK);\n    TEST_ASSERT(httpd_stop(hd) == ESP_OK);\n\n    /* Default value of max_open_sockets is already set as per\n     * maximum limit imposed by LWIP. Increasing this beyond the\n     * maximum allowed value, without increasing LWIP limit,\n     * should fail */\n    config.max_open_sockets += 1;\n    TEST_ASSERT(httpd_start(&hd, &config) != ESP_OK);\n}\n", "label": "network"}
{"project": "esp-idf", "file": "tls_mbedtls.c", "func": "int tls_connection_set_params(void *tls_ctx, struct tls_connection *conn,\n\t\t\t      const struct tls_connection_params *params)\n{\n\tint ret = 0;\n\ttls_context_t *tls = (tls_context_t *)os_zalloc(sizeof(tls_context_t));\n\n\tif (!tls) {\n\t\twpa_printf(MSG_ERROR, \"failed to allocate tls context\");\n\t\treturn -1;\n\t}\n\tif (!params) {\n\t\twpa_printf(MSG_ERROR, \"configuration is null\");\n\t\tret = -1;\n\t\tgoto err;\n\t}\n\n\tret = tls_create_mbedtls_handle(conn, params, tls);\n\tif (ret < 0) {\n\t\twpa_printf(MSG_ERROR, \"failed to create ssl handle\");\n\t\tgoto err;\n\t}\n\tmbedtls_ssl_set_bio(&tls->ssl, conn, tls_mbedtls_write, tls_mbedtls_read, NULL);\n\tconn->tls = (tls_context_t *)tls;\n\n\treturn ret;\nerr:\n\tos_free(tls);\n\treturn ret;\n}\n", "label": "crypto"}
{"project": "esp-idf", "file": "tls_mbedtls.c", "func": "int tls_global_set_params(void *tls_ctx,\n\t\t\t  const struct tls_connection_params *params)\n{\n\twpa_printf(MSG_INFO, \"TLS: Global parameters not supported\");\n\treturn -1;\n}\n", "label": "crypto"}
{"project": "esp-idf", "file": "tls_mbedtls.c", "func": "int tls_connection_set_session_ticket_cb(void *tls_ctx,\n\t\t\t\t\t struct tls_connection *conn,\n\t\t\t\t\t tls_session_ticket_cb cb,\n\t\t\t\t\t void *ctx)\n{\n\twpa_printf(MSG_ERROR, \"TLS: %s not supported\", __func__);\n\treturn -1;\n}\n", "label": "crypto"}
{"project": "esp-idf", "file": "tls_mbedtls.c", "func": "static int tls_connection_prf(void *tls_ctx, struct tls_connection *conn,\n\t\t       const char *label, int server_random_first,\n\t\t       u8 *out, size_t out_len)\n{\n\tint ret;\n\tu8 seed[2 * TLS_RANDOM_LEN];\n\tmbedtls_ssl_context *ssl = &conn->tls->ssl;\n\n\tif (!ssl) {\n\t\twpa_printf(MSG_ERROR, \"TLS: %s, session ingo is null\", __func__);\n\t\treturn -1;\n\t}\n\tif (ssl->MBEDTLS_PRIVATE(state) != MBEDTLS_SSL_HANDSHAKE_OVER) {\n\t\twpa_printf(MSG_ERROR, \"TLS: %s, incorrect tls state=%d\", __func__, ssl->MBEDTLS_PRIVATE(state));\n\t\treturn -1;\n\t}\n\n\tif (server_random_first) {\n\t\tos_memcpy(seed, conn->randbytes + TLS_RANDOM_LEN, TLS_RANDOM_LEN);\n\t\tos_memcpy(seed + TLS_RANDOM_LEN, conn->randbytes, TLS_RANDOM_LEN);\n\t} else {\n\t\tos_memcpy(seed, conn->randbytes, 2 * TLS_RANDOM_LEN);\n\t}\n\n\twpa_hexdump_key(MSG_MSGDUMP, \"random\", seed, 2 * TLS_RANDOM_LEN);\n\twpa_hexdump_key(MSG_MSGDUMP, \"master\", ssl->MBEDTLS_PRIVATE(session)->MBEDTLS_PRIVATE(master), TLS_MASTER_SECRET_LEN);\n\n\tret = mbedtls_ssl_tls_prf(conn->tls_prf_type, conn->master_secret, TLS_MASTER_SECRET_LEN,\n\t\t\t\tlabel, seed, 2 * TLS_RANDOM_LEN, out, out_len);\n\n\tif (ret < 0) {\n\t\twpa_printf(MSG_ERROR, \"prf failed, ret=%d\\n\", ret);\n\t}\n\twpa_hexdump_key(MSG_MSGDUMP, \"key\", out, out_len);\n\n\treturn ret;\n}\n", "label": "crypto"}
{"project": "esp-idf", "file": "tls_mbedtls.c", "func": "int tls_connection_export_key(void *tls_ctx, struct tls_connection *conn,\n\t\t\t      const char *label, const u8 *context,\n\t\t\t      size_t context_len, u8 *out, size_t out_len)\n{\n\treturn tls_connection_prf(tls_ctx, conn, label, 0, out, out_len);\n}\n", "label": "crypto"}
{"project": "esp-idf", "file": "tls_mbedtls.c", "func": "int tls_connection_get_eap_fast_key(void *tls_ctx, struct tls_connection *conn,\n\t\t\t\t    u8 *out, size_t out_len)\n{\n\twpa_printf(MSG_INFO, \"TLS: tls_connection_get_eap_fast_key not supported, please unset mbedtls crypto and try again\");\n\treturn -1;\n}\n", "label": "crypto"}
{"project": "esp-idf", "file": "tls_mbedtls.c", "func": "int tls_connection_client_hello_ext(void *tls_ctx, struct tls_connection *conn,\n\t\t\t\t    int ext_type, const u8 *data,\n\t\t\t\t    size_t data_len)\n{\n\twpa_printf(MSG_INFO, \"TLS: tls_connection_client_hello_ext not supported, please unset mbedtls crypto and try again\");\n\treturn -1;\n}\n", "label": "crypto"}
{"project": "esp-idf", "file": "tls_mbedtls.c", "func": "int tls_connection_shutdown(void *tls_ctx, struct tls_connection *conn)\n{\n\tif (conn->tls_io_data.in_data) {\n\t\twpabuf_free(conn->tls_io_data.in_data);\n\t}\n\tconn->tls_io_data.in_data = NULL;\n\n\t/* outdata may have dangling pointer */\n\tconn->tls_io_data.out_data = NULL;\n\n\treturn mbedtls_ssl_session_reset(&conn->tls->ssl);\n}\n", "label": "crypto"}
{"project": "esp-idf", "file": "tls_mbedtls.c", "func": "int tls_connection_get_random(void *tls_ctx, struct tls_connection *conn,\n\t\t\t    struct tls_random *data)\n{\n\tmbedtls_ssl_context *ssl = &conn->tls->ssl;\n\n\tos_memset(data, 0, sizeof(*data));\n\tif (ssl->MBEDTLS_PRIVATE(state) == MBEDTLS_SSL_CLIENT_HELLO) {\n\t\treturn -1;\n\t}\n\n\tdata->client_random = conn->randbytes;\n\tdata->client_random_len = TLS_RANDOM_LEN;\n\n\tif (ssl->MBEDTLS_PRIVATE(state) != MBEDTLS_SSL_SERVER_HELLO) {\n\t\tdata->server_random = conn->randbytes + TLS_RANDOM_LEN;\n\t\tdata->server_random_len = TLS_RANDOM_LEN;\n\t}\n\n\treturn 0;\n}\n", "label": "crypto"}
{"project": "poco", "file": "DigestEngineTest.cpp", "func": "void DigestEngineTest::testSHA1()\n{\n\tDigestEngine engine(\"SHA1\");\n\n\t// test vectors from FIPS 180-1\n\n\tengine.update(\"abc\");\n\tassertTrue (DigestEngine::digestToHex(engine.digest()) == \"a9993e364706816aba3e25717850c26c9cd0d89d\");\n\n\tengine.update(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\");\n\tassertTrue (DigestEngine::digestToHex(engine.digest()) == \"84983e441c3bd26ebaae4aa1f95129e5e54670f1\");\n\n\tfor (int i = 0; i < 1000000; ++i)\n\t\tengine.update('a');\n\tassertTrue (DigestEngine::digestToHex(engine.digest()) == \"34aa973cd4c4daa4f61eeb2bdbad27316534016f\");\n}\n", "label": "crypto"}
{"project": "poco", "file": "DigestEngineTest.cpp", "func": "void DigestEngineTest::setUp()\n{\n}\n", "label": "crypto"}
{"project": "poco", "file": "DigestEngineTest.cpp", "func": "void DigestEngineTest::tearDown()\n{\n}\n", "label": "crypto"}
{"project": "poco", "file": "DigestEngineTest.cpp", "func": "CppUnit::Test* DigestEngineTest::suite()\n{\n\tCppUnit::TestSuite* pSuite = new CppUnit::TestSuite(\"DigestEngineTest\");\n\n\tCppUnit_addTest(pSuite, DigestEngineTest, testMD5);\n\tCppUnit_addTest(pSuite, DigestEngineTest, testSHA1);\n\n\treturn pSuite;\n}\n", "label": "crypto"}
{"project": "poco", "file": "Driver.cpp", "func": "int main(int ac, char **av)\n{\n\tCryptoInitializer ci;\n\t\n\tstd::vector<std::string> args;\n\tfor (int i = 0; i < ac; ++i)\n\t\targs.push_back(std::string(av[i]));\n\tCppUnit::TestRunner runner;\n\trunner.addTest(\"CryptoTestSuite\", CryptoTestSuite::suite());\n\treturn runner.run(args) ? 0 : 1;\n}\n", "label": "crypto"}
{"project": "poco", "file": "WinCEDriver.cpp", "func": "int _tmain(int argc, wchar_t* argv[])\n{\n\tCryptoInitializer ci;\n\n\tstd::vector<std::string> args;\n\tfor (int i = 0; i < argc; ++i)\n\t{\n\t\tchar buffer[1024];\n\t\tstd::wcstombs(buffer, argv[i], sizeof(buffer));\n\t\targs.push_back(std::string(buffer));\n\t}\n\tCppUnit::TestRunner runner;\t\n\trunner.addTest(\"CryptoTestSuite\", CryptoTestSuite::suite());\n\treturn runner.run(args) ? 0 : 1;\n}\n", "label": "crypto"}
{"project": "poco", "file": "WinDriver.cpp", "func": "\tvoid TestMain()\n\t{\n\t\tCryptoInitializer ci;\n\n\t\tCppUnit::WinTestRunner runner;\n\t\trunner.addTest(CryptoTestSuite::suite());\n\t\trunner.run();\n\t}\n", "label": "crypto"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::connect(const SocketAddress& address, const Poco::Timespan& timeout, bool performHandshake)\n{\n\t_state = ST_ERROR;\n\t_pSocket->connect(address, timeout);\n\tconnectSSL(performHandshake);\n\t_state = ST_DONE;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::connectNB(const SocketAddress& address)\n{\n\ttry\n\t{\n\t\t_state = ST_CONNECTING;\n\t\t_pSocket->connectNB(address);\n\t}\n\tcatch (...)\n\t{\n\t\t_state = ST_ERROR;\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::bind(const SocketAddress& address, bool reuseAddress)\n{\n\tpoco_check_ptr (_pSocket);\n\n\t_pSocket->bind(address, reuseAddress);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::bind(const SocketAddress& address, bool reuseAddress, bool reusePort)\n{\n\tpoco_check_ptr (_pSocket);\n\n\t_pSocket->bind(address, reuseAddress, reusePort);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::bind6(const SocketAddress& address, bool reuseAddress, bool ipV6Only)\n{\n\tpoco_check_ptr (_pSocket);\n\n\t_pSocket->bind6(address, reuseAddress, ipV6Only);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::bind6(const SocketAddress& address, bool reuseAddress, bool reusePort, bool ipV6Only)\n{\n\tpoco_check_ptr (_pSocket);\n\n\t_pSocket->bind6(address, reuseAddress, reusePort, ipV6Only);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::listen(int backlog)\n{\n\t_mode = MODE_SERVER;\n\n\tif (_hCreds.dwLower == 0 && _hCreds.dwUpper == 0)\n\t{\n\t\tinitServerContext();\n\t}\n\t_pSocket->listen(backlog);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::shutdown()\n{\n\tif (_mode == MODE_SERVER)\n\t\tserverDisconnect(&_hCreds, &_hContext);\n\telse\n\t\tclientDisconnect(&_hCreds, &_hContext);\n\n\t_pSocket->shutdown();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::close()\n{\n\tif (_mode == MODE_SERVER)\n\t\tserverDisconnect(&_hCreds, &_hContext);\n\telse\n\t\tclientDisconnect(&_hCreds, &_hContext);\n\n\t_pSocket->close();\n\tcleanup();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::abort()\n{\n\t_pSocket->shutdown();\n\tcleanup();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "int SecureSocketImpl::available() const\n{\n\treturn static_cast<int>(_overflowBuffer.size() + _recvBufferOffset);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::acceptSSL()\n{\n\t_state = ST_DONE;\n\tinitServerContext();\n\t_needHandshake = true;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::verifyPeerCertificate()\n{\n\tif (_peerHostName.empty())\n\t\t_peerHostName = _pSocket->peerAddress().host().toString();\n\n\tverifyPeerCertificate(_peerHostName);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::verifyPeerCertificate(const std::string& hostName)\n{\n\tContext::VerificationMode mode = _pContext->verificationMode();\n\tif (mode == Context::VERIFY_NONE || !_pContext->extendedCertificateVerificationEnabled() ||\n\t    (mode != Context::VERIFY_STRICT && isLocalHost(hostName)))\n\t{\n\t\treturn;\n\t}\n\n\n\tif (_mode == MODE_SERVER)\n\t\tserverVerifyCertificate();\n\telse\n\t\tclientVerifyCertificate(hostName);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "bool SecureSocketImpl::isLocalHost(const std::string& hostName)\n{\n\tSocketAddress addr(hostName, 0);\n\treturn addr.host().isLoopback();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "int SecureSocketImpl::sendRawBytes(const void* buffer, int length, int flags)\n{\n\treturn _pSocket->sendBytes(buffer, length, flags);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "int SecureSocketImpl::receiveRawBytes(void* buffer, int length, int flags)\n{\n\treturn _pSocket->receiveBytes(buffer, length, flags);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "int SecureSocketImpl::sendBytes(const void* buffer, int length, int flags)\n{\n\tif (_needHandshake)\n\t{\n\t\tcompleteHandshake();\n\t\t_needHandshake = false;\n\t}\n\n\tif (_state == ST_ERROR) return 0;\n\n\tif (_state != ST_DONE)\n\t{\n\t\tbool establish = _pSocket->getBlocking();\n\t\tif (establish)\n\t\t{\n\t\t\twhile (_state != ST_DONE)\n\t\t\t{\n\t\t\t\tstateMachine();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstateMachine();\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tint rc = 0;\n\tint dataToSend = length;\n\tint dataSent = 0;\n\tconst char* pBuffer = reinterpret_cast<const char*>(buffer);\n\n\tif (_sendBuffer.capacity() != _ioBufferSize)\n\t\t_sendBuffer.setCapacity(_ioBufferSize);\n\n\twhile (dataToSend > 0)\n\t{\n\t\tAutoSecBufferDesc<4> msg(&_securityFunctions, false);\n\t\tint dataSize = dataToSend;\n\t\tif (dataSize > _streamSizes.cbMaximumMessage)\n\t\t\tdataSize = _streamSizes.cbMaximumMessage;\n\t\tSecBuffer* pDataBuffer  = 0;\n\t\tSecBuffer* pExtraBuffer = 0;\n\n\t\tstd::memcpy(_sendBuffer.begin() + _streamSizes.cbHeader, pBuffer + dataSent, dataSize);\n\n\t\tmsg.setSecBufferStreamHeader(0, _sendBuffer.begin(), _streamSizes.cbHeader);\n\t\tmsg.setSecBufferData(1, _sendBuffer.begin() + _streamSizes.cbHeader, dataSize);\n\t\tmsg.setSecBufferStreamTrailer(2, _sendBuffer.begin() + _streamSizes.cbHeader + dataSize, _streamSizes.cbTrailer);\n\t\tmsg.setSecBufferEmpty(3);\n\n\t\tSECURITY_STATUS securityStatus = _securityFunctions.EncryptMessage(&_hContext, 0, &msg, 0);\n\n\t\tif (FAILED(securityStatus) && securityStatus != SEC_E_CONTEXT_EXPIRED)\n\t\t\tthrow SSLException(\"Failed to encrypt message\", Utility::formatError(securityStatus));\n\n\t\tint outBufferLen = msg[0].cbBuffer + msg[1].cbBuffer + msg[2].cbBuffer;\n\n\t\tint sent = sendRawBytes(_sendBuffer.begin(), outBufferLen, flags);\n\t\tif (_pSocket->getBlocking() && sent == -1)\n\t\t{\n\t\t\tif (dataSent == 0)\n\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn dataSent;\n\t\t}\n\t\tif (sent != outBufferLen)\n\t\t\tthrow SSLException(\"Failed to send encrypted message\");\n\n\t\tdataToSend -= dataSize;\n\t\tdataSent += dataSize;\n\t\trc += sent;\n\t}\n\treturn dataSent;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "int SecureSocketImpl::receiveBytes(void* buffer, int length, int flags)\n{\n\tif (_needHandshake)\n\t{\n\t\tcompleteHandshake();\n\t\t_needHandshake = false;\n\t}\n\n\tif (_state == ST_ERROR) return 0;\n\tif (_state != ST_DONE)\n\t{\n\t\tbool establish = _pSocket->getBlocking();\n\t\tif (establish)\n\t\t{\n\t\t\twhile (_state != ST_DONE)\n\t\t\t{\n\t\t\t\tstateMachine();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstateMachine();\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tint rc(0);\n\tstd::size_t overflowSize = _overflowBuffer.size();\n\tif (overflowSize > 0) // any remaining data from previous calls?\n\t{\n\t\tif (static_cast<DWORD>(length) < overflowSize)\n\t\t{\n\t\t\trc = length;\n\t\t\tstd::memcpy(buffer, _overflowBuffer.begin(), rc);\n\t\t\tstd::memmove(_overflowBuffer.begin(), _overflowBuffer.begin() + rc, overflowSize - rc);\n\t\t\t_overflowBuffer.resize(overflowSize - rc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trc = static_cast<int>(overflowSize);\n\t\t\tstd::memcpy(buffer, _overflowBuffer.begin(), rc);\n\t\t\t_overflowBuffer.resize(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// adjust buffer size to optimize memory usage\n\t\tif (_ioBufferSize != _recvBuffer.capacity() && _recvBufferOffset < _ioBufferSize)\n\t\t{\n\t\t\t_recvBuffer.setCapacity(_ioBufferSize);\n\t\t}\n\t\tbool needData = _recvBufferOffset == 0;\n\t\tbool cont = true;\n\t\tdo\n\t\t{\n\t\t\tif (needData)\n\t\t\t{\n\t\t\t\tint numBytes = receiveRawBytes(_recvBuffer.begin() + _recvBufferOffset, _ioBufferSize - _recvBufferOffset);\n\n\t\t\t\tif (numBytes == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\telse if (numBytes == 0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\t_recvBufferOffset += numBytes;\n\t\t\t}\n\t\t\telse needData = true;\n\n\t\t\tint bytesDecoded = 0;\n\t\t\t_extraSecBuffer.pvBuffer = 0;\n\t\t\t_extraSecBuffer.cbBuffer = 0;\n\t\t\tSECURITY_STATUS securityStatus = decodeBufferFull(_recvBuffer.begin(), _recvBufferOffset, reinterpret_cast<char*>(buffer), length, bytesDecoded);\n\t\t\tif (_extraSecBuffer.cbBuffer > 0)\n\t\t\t{\n\t\t\t\tstd::memmove(_recvBuffer.begin(), _extraSecBuffer.pvBuffer, _extraSecBuffer.cbBuffer);\n\t\t\t\t_recvBufferOffset = _extraSecBuffer.cbBuffer;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_recvBufferOffset = 0;\n\t\t\t\tcont = false;\n\t\t\t}\n\n\t\t\t_extraSecBuffer.pvBuffer = 0;\n\t\t\t_extraSecBuffer.cbBuffer = 0;\n\n\t\t\tif (bytesDecoded > 0)\n\t\t\t{\n\t\t\t\t// bytesDecoded contains everything including overflow data\n\t\t\t\trc = bytesDecoded;\n\t\t\t\tif (rc > length)\n\t\t\t\t\trc = length;\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tif (securityStatus == SEC_E_INCOMPLETE_MESSAGE)\n\t\t\t{\n\t\t\t\tif (!_pSocket->getBlocking())\n\t\t\t\t\treturn -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (securityStatus == SEC_I_CONTEXT_EXPIRED)\n\t\t\t{\n\t\t\t\tSetLastError(securityStatus);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (securityStatus != SEC_E_OK && securityStatus != SEC_I_RENEGOTIATE && securityStatus != SEC_I_CONTEXT_EXPIRED)\n\t\t\t{\n\t\t\t\tSetLastError(securityStatus);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (securityStatus == SEC_I_RENEGOTIATE)\n\t\t\t{\n\t\t\t\t_needData = false;\n\t\t\t\t_state = ST_CLIENTHANDSHAKECONDREAD;\n\t\t\t\tif (!_pSocket->getBlocking())\n\t\t\t\t\treturn -1;\n\n\t\t\t\tsecurityStatus = performClientHandshakeLoop();\n\n\t\t\t\tif (securityStatus != SEC_E_OK)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (_extraSecBuffer.pvBuffer)\n\t\t\t\t{\n\t\t\t\t\tstd::memmove(_recvBuffer.begin(), _extraSecBuffer.pvBuffer, _extraSecBuffer.cbBuffer);\n\t\t\t\t\t_recvBufferOffset = _extraSecBuffer.cbBuffer;\n\t\t\t\t}\n\n\t\t\t\t_extraSecBuffer.pvBuffer = 0;\n\t\t\t\t_extraSecBuffer.cbBuffer = 0;\n\t\t\t}\n\t\t}\n\t\twhile (cont);\n\t}\n\n\treturn rc;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "SECURITY_STATUS SecureSocketImpl::decodeMessage(BYTE* pBuffer, DWORD bufSize, AutoSecBufferDesc<4>& msg, SecBuffer*& pDataBuffer, SecBuffer*& pExtraBuffer)\n{\n\tmsg.setSecBufferData(0, pBuffer, bufSize);\n\tmsg.setSecBufferEmpty(1);\n\tmsg.setSecBufferEmpty(2);\n\tmsg.setSecBufferEmpty(3);\n\tpDataBuffer  = 0;\n\tpExtraBuffer = 0;\n\n\tSECURITY_STATUS securityStatus = _securityFunctions.DecryptMessage(&_hContext, &msg, 0, 0);\n\n\tif (securityStatus == SEC_E_OK || securityStatus == SEC_I_RENEGOTIATE)\n\t{\n\t\tfor (int i = 1; i < 4; ++i)\n\t\t{\n\t\t\tif (!pDataBuffer && msg[i].BufferType == SECBUFFER_DATA)\n\t\t\t\tpDataBuffer = &msg[i];\n\n\t\t\tif (!pExtraBuffer && msg[i].BufferType == SECBUFFER_EXTRA)\n\t\t\t\tpExtraBuffer = &msg[i];\n\t\t}\n\t}\n\n\treturn securityStatus;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "SECURITY_STATUS SecureSocketImpl::decodeBufferFull(BYTE* pBuffer, DWORD bufSize, char* pOutBuffer, int outLength, int& bytesDecoded)\n{\n\tpoco_check_ptr (pBuffer);\n\tpoco_assert (bufSize > 0);\n\tpoco_check_ptr (pOutBuffer);\n\tpoco_assert (outLength > 0);\n\n\t_extraSecBuffer.pvBuffer = 0;\n\t_extraSecBuffer.cbBuffer = 0;\n\n\tSecBuffer* pDataBuffer = 0;\n\tSecBuffer* pExtraBuffer = 0;\n\tint bytes = 0;\n\tbytesDecoded = 0;\n\n\tPoco::Buffer<BYTE> overflowBuffer(0);\n\tint overflowOffset = 0;\n\tSECURITY_STATUS securityStatus = SEC_E_OK;\n\tdo\n\t{\n\t\tAutoSecBufferDesc<4> msg(&_securityFunctions, false);\n\t\tsecurityStatus = decodeMessage(pBuffer, bufSize, msg, pDataBuffer, pExtraBuffer);\n\t\tif (pDataBuffer && pDataBuffer->cbBuffer > 0)\n\t\t{\n\t\t\tbytes = pDataBuffer->cbBuffer;\n\t\t\tbytesDecoded += bytes;\n\t\t\t// do we have room for more data in pOutBuffer?\n\t\t\tif (bytes <= outLength) // yes, everything fits in there\n\t\t\t{\n\t\t\t\toutLength -= bytes;\n\t\t\t\tstd::memcpy(pOutBuffer, pDataBuffer->pvBuffer, bytes);\n\t\t\t\tpOutBuffer += bytes;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// not enough room in pOutBuffer, write overflow data\n\t\t\t\t// simply reserve bufSize bytes (is large enough even in worst case scenario, no need to re-increase)\n\t\t\t\toverflowBuffer.resize(bufSize);\n\t\t\t\tif (outLength > 0)\n\t\t\t\t{\n\t\t\t\t\t// make pOutBuffer full\n\t\t\t\t\tstd::memcpy(pOutBuffer, pDataBuffer->pvBuffer, outLength);\n\t\t\t\t\t// no longer valid to write to pOutBuffer\n\t\t\t\t\tpOutBuffer = 0;\n\t\t\t\t\t// copy the rest to ptrOverflow\n\t\t\t\t\tstd::memcpy(overflowBuffer.begin(), reinterpret_cast<char*>(pDataBuffer->pvBuffer) + outLength, bytes - outLength);\n\t\t\t\t\toverflowOffset = bytes - outLength;\n\t\t\t\t\toutLength = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// append to overflowBuffer\n\t\t\t\t\tpoco_assert_dbg (overflowOffset + bytes <= overflowBuffer.capacity());\n\t\t\t\t\tstd::memcpy(overflowBuffer.begin() + overflowOffset, pDataBuffer->pvBuffer, bytes);\n\t\t\t\t\toverflowOffset += bytes;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (pExtraBuffer && pExtraBuffer->cbBuffer > 0)\n\t\t{\n\t\t\t// we have potentially more data to decode\n\t\t\t// decode as much as possible\n\t\t\tpBuffer = reinterpret_cast<BYTE*>(pExtraBuffer->pvBuffer);\n\t\t\tbufSize = pExtraBuffer->cbBuffer;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (securityStatus == SEC_E_OK)\n\t\t\t{\n\t\t\t\t// everything decoded\n\t\t\t\tpBuffer = 0;\n\t\t\t\tbufSize = 0;\n\t\t\t}\n\t\t\telse if (securityStatus != SEC_E_INCOMPLETE_MESSAGE && securityStatus != SEC_I_RENEGOTIATE && securityStatus != SEC_I_CONTEXT_EXPIRED)\n\t\t\t{\n\t\t\t\treturn securityStatus;\n\t\t\t}\n\t\t}\n\n\t\tif (securityStatus == SEC_I_RENEGOTIATE)\n\t\t{\n\t\t\t_needData = false;\n\t\t\tsecurityStatus = performClientHandshakeLoop();\n\t\t\tif (securityStatus != SEC_E_OK)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile (securityStatus == SEC_E_OK && pBuffer);\n\n\tif (overflowOffset > 0)\n\t{\n\t\t_overflowBuffer.resize(overflowOffset);\n\t\tstd::memcpy(_overflowBuffer.begin(), overflowBuffer.begin(), overflowOffset);\n\t}\n\tif (bufSize > 0)\n\t{\n\t\t_extraSecBuffer.cbBuffer = bufSize;\n\t\t_extraSecBuffer.pvBuffer = pBuffer;\n\t}\n\n\tif (pBuffer == 0) securityStatus = SEC_E_OK;\n\treturn securityStatus;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::setPeerHostName(const std::string& peerHostName)\n{\n\t_peerHostName = peerHostName;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "PCCERT_CONTEXT SecureSocketImpl::loadCertificate(bool mustFindCertificate)\n{\n\ttry\n\t{\n\t\tPoco::Net::X509Certificate cert = _pContext->certificate();\n\t\tPCCERT_CONTEXT pCert = cert.system();\n\t\tCertDuplicateCertificateContext(pCert);\n\t\treturn pCert;\n\t}\n\tcatch (...)\n\t{\n\t\tif (mustFindCertificate)\n\t\t\tthrow;\n\t\telse\n\t\t\treturn 0;\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::connectSSL(bool completeHandshake)\n{\n\tpoco_assert_dbg(_pPeerCertificate == 0);\n\n\tif (_peerHostName.empty())\n\t{\n\t\t_peerHostName = _pSocket->peerAddress().host().toString();\n\t}\n\n\tinitClientContext();\n\tif (completeHandshake)\n\t{\n\t\tperformClientHandshake();\n\t\t_needHandshake = false;\n\t}\n\telse\n\t{\n\t\t_needHandshake = true;\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::completeHandshake()\n{\n\tif (_mode == MODE_SERVER)\n\t\tperformServerHandshake();\n\telse\n\t\tperformClientHandshake();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::clientConnectVerify()\n{\n\tpoco_assert_dbg(!_pPeerCertificate);\n\tpoco_assert_dbg(!_peerHostName.empty());\n\n\ttry\n\t{\n\t\tSECURITY_STATUS securityStatus = _securityFunctions.QueryContextAttributesW(&_hContext, SECPKG_ATTR_REMOTE_CERT_CONTEXT, (PVOID) &_pPeerCertificate);\n\t\tif (securityStatus != SEC_E_OK)\n\t\t\tthrow SSLException(\"Failed to obtain peer certificate\", Utility::formatError(securityStatus));\n\n\t\tclientVerifyCertificate(_peerHostName);\n\n\t\tsecurityStatus = _securityFunctions.QueryContextAttributesW(&_hContext, SECPKG_ATTR_STREAM_SIZES, &_streamSizes);\n\t\tif (securityStatus != SEC_E_OK)\n\t\t\tthrow SSLException(\"Failed to query stream sizes\", Utility::formatError(securityStatus));\n\n\t\t_ioBufferSize = _streamSizes.cbHeader + _streamSizes.cbMaximumMessage + _streamSizes.cbTrailer;\n\t\t_state = ST_DONE;\n\t}\n\tcatch (...)\n\t{\n\t\tif (_pPeerCertificate)\n\t\t{\n\t\t\tCertFreeCertificateContext(_pPeerCertificate);\n\t\t\t_pPeerCertificate = 0;\n\t\t}\n\t\tthrow;\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::initClientContext()\n{\n\t_pOwnCertificate = loadCertificate(false);\n\t_hCreds = _pContext->credentials();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::performClientHandshake()\n{\n\tperformInitialClientHandshake();\n\tperformClientHandshakeLoop();\n\tclientConnectVerify();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::performInitialClientHandshake()\n{\n\t// get initial security token\n\t_outSecBuffer.reset(true);\n\t_outSecBuffer.setSecBufferToken(0, 0, 0);\n\n\tTimeStamp ts;\n\tDWORD contextAttributes(0);\n\tstd::wstring whostName;\n\tPoco::UnicodeConverter::convert(_peerHostName, whostName);\n\t_securityStatus = _securityFunctions.InitializeSecurityContextW(\n\t\t\t\t\t\t&_hCreds,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tconst_cast<SEC_WCHAR*>(whostName.c_str()),\n\t\t\t\t\t\t_contextFlags,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t&_hContext,\n\t\t\t\t\t\t&_outSecBuffer,\n\t\t\t\t\t\t&contextAttributes,\n\t\t\t\t\t\t&ts);\n\n\tif (_securityStatus != SEC_E_OK)\n\t{\n\t\tif (_securityStatus == SEC_I_INCOMPLETE_CREDENTIALS)\n\t\t{\n\t\t\t// the server is asking for client credentials, we didn't send one because we were not configured to do so, abort\n\t\t\tthrow SSLException(\"Handshake failed: No client credentials configured\");\n\t\t}\n\t\telse if (_securityStatus != SEC_I_CONTINUE_NEEDED)\n\t\t{\n\t\t\tthrow SSLException(\"Handshake failed\", Utility::formatError(_securityStatus));\n\t\t}\n\t}\n\n\t// incomplete credentials: more calls to InitializeSecurityContext needed\n\t// send the token\n\tsendInitialTokenOutBuffer();\n\n\tif (_securityStatus == SEC_E_OK)\n\t{\n\t\t// The security context was successfully initialized.\n\t\t// There is no need for another InitializeSecurityContext (Schannel) call.\n\t\t_state = ST_DONE;\n\t\treturn;\n\t}\n\n\t//SEC_I_CONTINUE_NEEDED was returned:\n\t// Wait for a return token. The returned token is then passed in\n\t// another call to InitializeSecurityContext (Schannel). The output token can be empty.\n\n\t_extraSecBuffer.pvBuffer = 0;\n\t_extraSecBuffer.cbBuffer = 0;\n\t_needData = true;\n\t_state = ST_CLIENTHANDSHAKECONDREAD;\n\t_securityStatus = SEC_E_INCOMPLETE_MESSAGE;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::sendInitialTokenOutBuffer()\n{\n\t// send the token\n\tif (_outSecBuffer[0].cbBuffer && _outSecBuffer[0].pvBuffer)\n\t{\n\t\tint numBytes = sendRawBytes(_outSecBuffer[0].pvBuffer, _outSecBuffer[0].cbBuffer);\n\t\tif (numBytes != _outSecBuffer[0].cbBuffer)\n\t\t\tthrow SSLException(\"Failed to send token to the server\");\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "SECURITY_STATUS SecureSocketImpl::performClientHandshakeLoop()\n{\n\t_recvBufferOffset = 0;\n\t_securityStatus = SEC_E_INCOMPLETE_MESSAGE;\n\n\twhile (_securityStatus == SEC_I_CONTINUE_NEEDED || _securityStatus == SEC_E_INCOMPLETE_MESSAGE || _securityStatus == SEC_I_INCOMPLETE_CREDENTIALS)\n\t{\n\t\tperformClientHandshakeLoopCondReceive();\n\n\t\tif (_securityStatus == SEC_E_OK)\n\t\t{\n\t\t\tperformClientHandshakeLoopOK();\n\t\t}\n\t\telse if (_securityStatus == SEC_I_CONTINUE_NEEDED)\n\t\t{\n\t\t\tperformClientHandshakeLoopContinueNeeded();\n\t\t}\n\t\telse if (_securityStatus == SEC_E_INCOMPLETE_MESSAGE)\n\t\t{\n\t\t\tperformClientHandshakeLoopIncompleteMessage();\n\t\t}\n\t\telse if (FAILED(_securityStatus))\n\t\t{\n\t\t\tif (_outFlags & ISC_RET_EXTENDED_ERROR)\n\t\t\t{\n\t\t\t\tperformClientHandshakeLoopExtError();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tperformClientHandshakeLoopError();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tperformClientHandshakeLoopIncompleteMessage();\n\t\t}\n\t}\n\n\tif (FAILED(_securityStatus))\n\t{\n\t\tperformClientHandshakeLoopError();\n\t}\n\n\treturn _securityStatus;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::performClientHandshakeLoopExtError()\n{\n\tpoco_assert_dbg (FAILED(_securityStatus));\n\n\tperformClientHandshakeSendOutBuffer();\n\tperformClientHandshakeLoopError();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::performClientHandshakeLoopError()\n{\n\tpoco_assert_dbg (FAILED(_securityStatus));\n\tcleanup();\n\t_state = ST_ERROR;\n\tthrow SSLException(\"Error during handshake\", Utility::formatError(_securityStatus));\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::performClientHandshakeSendOutBuffer()\n{\n\tif (_outSecBuffer[0].cbBuffer && _outSecBuffer[0].pvBuffer)\n\t{\n\t\tint numBytes = sendRawBytes(static_cast<const void*>(_outSecBuffer[0].pvBuffer), _outSecBuffer[0].cbBuffer);\n\t\tif (numBytes != _outSecBuffer[0].cbBuffer)\n\t\t\tthrow SSLException(\"Socket error during handshake\");\n\n\t\t_outSecBuffer.release(0);\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::performClientHandshakeExtraBuffer()\n{\n\tif (_inSecBuffer[1].BufferType == SECBUFFER_EXTRA)\n\t{\n\t\tstd::memmove(_recvBuffer.begin(), _recvBuffer.begin() + (_recvBufferOffset - _inSecBuffer[1].cbBuffer), _inSecBuffer[1].cbBuffer);\n\t\t_recvBufferOffset = _inSecBuffer[1].cbBuffer;\n\t}\n\telse _recvBufferOffset = 0;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::performClientHandshakeLoopOK()\n{\n\tpoco_assert_dbg(_securityStatus == SEC_E_OK);\n\n\tperformClientHandshakeSendOutBuffer();\n\tperformClientHandshakeExtraBuffer();\n\t_state = ST_VERIFY;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::performClientHandshakeLoopInit()\n{\n\t_inSecBuffer.reset(false);\n\t_outSecBuffer.reset(true);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::performClientHandshakeLoopReceive()\n{\n\tpoco_assert_dbg (_needData);\n\tpoco_assert (IO_BUFFER_SIZE > _recvBufferOffset);\n\n\tint n = receiveRawBytes(_recvBuffer.begin() + _recvBufferOffset, IO_BUFFER_SIZE - _recvBufferOffset);\n\tif (n <= 0) throw SSLException(\"Error during handshake: failed to read data\");\n\n\t_recvBufferOffset += n;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::performClientHandshakeLoopCondReceive()\n{\n\tpoco_assert_dbg (_securityStatus == SEC_E_INCOMPLETE_MESSAGE || SEC_I_CONTINUE_NEEDED);\n\n\tperformClientHandshakeLoopInit();\n\tif (_needData)\n\t{\n\t\tif (_recvBuffer.capacity() != IO_BUFFER_SIZE)\n\t\t\t_recvBuffer.setCapacity(IO_BUFFER_SIZE);\n\t\tperformClientHandshakeLoopReceive();\n\t}\n\telse _needData = true;\n\n\t_inSecBuffer.setSecBufferToken(0, _recvBuffer.begin(), _recvBufferOffset);\n\t// inbuffer 1 should be empty\n\t_inSecBuffer.setSecBufferEmpty(1);\n\n\t// outBuffer[0] should be empty\n\t_outSecBuffer.setSecBufferToken(0, 0, 0);\n\n\t_outFlags = 0;\n\tTimeStamp ts;\n\t_securityStatus = _securityFunctions.InitializeSecurityContextW(\n\t\t\t\t\t\t\t\t&_hCreds,\n\t\t\t\t\t\t\t\t&_hContext,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t_contextFlags,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t&_inSecBuffer,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t&_outSecBuffer,\n\t\t\t\t\t\t\t\t&_outFlags,\n\t\t\t\t\t\t\t\t&ts);\n\n\tif (_securityStatus == SEC_E_OK)\n\t{\n\t\t_state = ST_CLIENTHANDSHAKEOK;\n\t}\n\telse if (_securityStatus == SEC_I_CONTINUE_NEEDED)\n\t{\n\t\t_state = ST_CLIENTHANDSHAKECONTINUE;\n\t}\n\telse if (FAILED(_securityStatus))\n\t{\n\t\tif (_outFlags & ISC_RET_EXTENDED_ERROR)\n\t\t\t_state = ST_CLIENTHANDSHAKEEXTERROR;\n\t\telse\n\t\t\t_state = ST_ERROR;\n\t}\n\telse\n\t{\n\t\t_state = ST_CLIENTHANDSHAKEINCOMPLETE;\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::performClientHandshakeLoopContinueNeeded()\n{\n\tperformClientHandshakeSendOutBuffer();\n\tperformClientHandshakeExtraBuffer();\n\t_state = ST_CLIENTHANDSHAKECONDREAD;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::performClientHandshakeLoopIncompleteMessage()\n{\n\t_needData = true;\n\t_state = ST_CLIENTHANDSHAKECONDREAD;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::initServerContext()\n{\n\t_pOwnCertificate = loadCertificate(true);\n\t_hCreds = _pContext->credentials();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::performServerHandshake()\n{\n\tserverHandshakeLoop(&_hContext, &_hCreds, _clientAuthRequired, true, true);\n\n\tSECURITY_STATUS securityStatus;\n\tif (_clientAuthRequired)\n\t{\n\t\tpoco_assert_dbg (!_pPeerCertificate);\n\t\tsecurityStatus = _securityFunctions.QueryContextAttributesW(&_hContext, SECPKG_ATTR_REMOTE_CERT_CONTEXT, &_pPeerCertificate);\n\n\t\tif (securityStatus != SEC_E_OK)\n\t\t{\n\t\t\tif (_pPeerCertificate)\n\t\t\t{\n\t\t\t\tCertFreeCertificateContext(_pPeerCertificate);\n\t\t\t\t_pPeerCertificate = 0;\n\t\t\t}\n\t\t\tthrow SSLException(\"Cannot obtain client certificate\", Utility::formatError(securityStatus));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tserverVerifyCertificate();\n\t\t}\n\t}\n\n\tsecurityStatus = _securityFunctions.QueryContextAttributesW(&_hContext,SECPKG_ATTR_STREAM_SIZES, &_streamSizes);\n\tif (securityStatus != SEC_E_OK) throw SSLException(\"Cannot query stream sizes\", Utility::formatError(securityStatus));\n\n\t_ioBufferSize = _streamSizes.cbHeader + _streamSizes.cbMaximumMessage + _streamSizes.cbTrailer;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "bool SecureSocketImpl::serverHandshakeLoop(PCtxtHandle phContext, PCredHandle phCred, bool requireClientAuth, bool doInitialRead, bool newContext)\n{\n\tTimeStamp tsExpiry;\n\tint n = 0;\n\tbool doRead = doInitialRead;\n\tbool initContext = newContext;\n\tDWORD outFlags;\n\tSECURITY_STATUS securityStatus = SEC_E_INCOMPLETE_MESSAGE;\n\n\twhile (securityStatus == SEC_I_CONTINUE_NEEDED || securityStatus == SEC_E_INCOMPLETE_MESSAGE || securityStatus == SEC_I_INCOMPLETE_CREDENTIALS)\n\t{\n\t\tif (securityStatus == SEC_E_INCOMPLETE_MESSAGE)\n\t\t{\n\t\t\tif (doRead)\n\t\t\t{\n\t\t\t\tn = receiveRawBytes(_recvBuffer.begin() + _recvBufferOffset, IO_BUFFER_SIZE - _recvBufferOffset);\n\n\t\t\t\tif (n <= 0)\n\t\t\t\t\tthrow SSLException(\"Failed to receive data in handshake\");\n\t\t\t\telse\n\t\t\t\t\t_recvBufferOffset += n;\n\t\t\t}\n\t\t\telse doRead = true;\n\t\t}\n\n\t\tAutoSecBufferDesc<2> inBuffer(&_securityFunctions, false);\n\t\tAutoSecBufferDesc<1> outBuffer(&_securityFunctions, true);\n\t\tinBuffer.setSecBufferToken(0, _recvBuffer.begin(), _recvBufferOffset);\n\t\tinBuffer.setSecBufferEmpty(1);\n\t\toutBuffer.setSecBufferToken(0, 0, 0);\n\n\t\tsecurityStatus = _securityFunctions.AcceptSecurityContext(\n\t\t\t\t\t\tphCred,\n\t\t\t\t\t\tinitContext ? NULL : phContext,\n\t\t\t\t\t\t&inBuffer,\n\t\t\t\t\t\t_contextFlags,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tinitContext ? phContext : NULL,\n\t\t\t\t\t\t&outBuffer,\n\t\t\t\t\t\t&outFlags,\n\t\t\t\t\t\t&tsExpiry);\n\n\t\tinitContext = false;\n\n\t\tif (securityStatus == SEC_E_OK || securityStatus == SEC_I_CONTINUE_NEEDED || (FAILED(securityStatus) && (0 != (outFlags & ISC_RET_EXTENDED_ERROR))))\n\t\t{\n\t\t\tif (outBuffer[0].cbBuffer != 0 && outBuffer[0].pvBuffer != 0)\n\t\t\t{\n\t\t\t\tn = sendRawBytes(outBuffer[0].pvBuffer, outBuffer[0].cbBuffer);\n\t\t\t\toutBuffer.release(0);\n\t\t\t}\n\t\t}\n\n\t\tif (securityStatus == SEC_E_OK )\n\t\t{\n\t\t\tif (inBuffer[1].BufferType == SECBUFFER_EXTRA)\n\t\t\t{\n\t\t\t\tstd::memmove(_recvBuffer.begin(), _recvBuffer.begin() + (_recvBufferOffset - inBuffer[1].cbBuffer), inBuffer[1].cbBuffer);\n\t\t\t\t_recvBufferOffset = inBuffer[1].cbBuffer;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_recvBufferOffset = 0;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse if (FAILED(securityStatus) && securityStatus != SEC_E_INCOMPLETE_MESSAGE)\n\t\t{\n\t\t\tthrow SSLException(\"Handshake failure:\", Utility::formatError(securityStatus));\n\t\t}\n\n\t\tif (securityStatus != SEC_E_INCOMPLETE_MESSAGE && securityStatus != SEC_I_INCOMPLETE_CREDENTIALS)\n\t\t{\n\t\t\tif (inBuffer[1].BufferType == SECBUFFER_EXTRA)\n\t\t\t{\n\t\t\t\tstd::memmove(_recvBuffer.begin(), _recvBuffer.begin() + (_recvBufferOffset - inBuffer[1].cbBuffer), inBuffer[1].cbBuffer);\n\t\t\t\t_recvBufferOffset = inBuffer[1].cbBuffer;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_recvBufferOffset = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::clientVerifyCertificate(const std::string& hostName)\n{\n\tif (_pContext->verificationMode() == Context::VERIFY_NONE) return;\n\tif (!_pPeerCertificate) throw SSLException(\"No Server certificate\");\n\tif (hostName.empty()) throw SSLException(\"Server name not set\");\n\n\tX509Certificate cert(_pPeerCertificate, true);\n\n\tif (!cert.verify(hostName))\n\t{\n\t\tVerificationErrorArgs args(cert, 0, SEC_E_CERT_EXPIRED, \"The certificate host names do not match the server host name\");\n\t\tSSLManager::instance().ClientVerificationError(this, args);\n\t\tif (!args.getIgnoreError())\n\t\t\tthrow InvalidCertificateException(\"Host name verification failed\");\n\t}\n\n\tverifyCertificateChainClient(_pPeerCertificate);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::verifyCertificateChainClient(PCCERT_CONTEXT pServerCert)\n{\n\tX509Certificate cert(pServerCert, true);\n\n\tCERT_CHAIN_PARA chainPara;\n\tPCCERT_CHAIN_CONTEXT pChainContext = NULL;\n\tstd::memset(&chainPara, 0, sizeof(chainPara));\n\tchainPara.cbSize = sizeof(chainPara);\n\n\tif (!CertGetCertificateChain(\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t_pPeerCertificate,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&chainPara,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&pChainContext))\n\t{\n\t\tthrow SSLException(\"Cannot get certificate chain\", GetLastError());\n\t}\n\n\tHTTPSPolicyCallbackData polHttps;\n\tstd::memset(&polHttps, 0, sizeof(HTTPSPolicyCallbackData));\n\tpolHttps.cbStruct = sizeof(HTTPSPolicyCallbackData);\n\tpolHttps.dwAuthType = AUTHTYPE_SERVER;\n\tpolHttps.fdwChecks = SECURITY_FLAG_IGNORE_UNKNOWN_CA; // we do our own check later on\n\tpolHttps.pwszServerName = 0;\n\n\tCERT_CHAIN_POLICY_PARA polPara;\n\tstd::memset(&polPara, 0, sizeof(polPara));\n\tpolPara.cbSize = sizeof(polPara);\n\tpolPara.pvExtraPolicyPara = &polHttps;\n\n\tCERT_CHAIN_POLICY_STATUS polStatus;\n\tstd::memset(&polStatus, 0, sizeof(polStatus));\n\tpolStatus.cbSize = sizeof(polStatus);\n\n\tif (!CertVerifyCertificateChainPolicy(\n\t\t\t\t\t\tCERT_CHAIN_POLICY_SSL,\n\t\t\t\t\t\tpChainContext,\n\t\t\t\t\t\t&polPara,\n\t\t\t\t\t\t&polStatus))\n\t{\n\t\tVerificationErrorArgs args(cert, 0, GetLastError(), \"Failed to verify certificate chain\");\n\t\tSSLManager::instance().ClientVerificationError(this, args);\n\t\tif (!args.getIgnoreError())\n\t\t{\n\t\t\tCertFreeCertificateChain(pChainContext);\n\t\t\tthrow SSLException(\"Cannot verify certificate chain\");\n\t\t}\n\t\telse return;\n\t}\n\telse if (polStatus.dwError)\n\t{\n\t\tVerificationErrorArgs args(cert, polStatus.lElementIndex, polStatus.dwError, Utility::formatError(polStatus.dwError));\n\t\tSSLManager::instance().ClientVerificationError(this, args);\n\t\tCertFreeCertificateChain(pChainContext);\n\t\tif (!args.getIgnoreError())\n\t\t{\n\t\t\tthrow SSLException(\"Failed to verify certificate chain\");\n\t\t}\n\t\telse return;\n\t}\n\n\t// now verify CA's\n\tHCERTSTORE trustedCerts = _pContext->certificateStore();\n\tfor (DWORD i = 0; i < pChainContext->cChain; i++)\n\t{\n\t\tstd::vector<PCCERT_CONTEXT> certs;\n\t\tfor (DWORD k = 0; k < pChainContext->rgpChain[i]->cElement; k++)\n\t\t{\n\t\t\tcerts.push_back(pChainContext->rgpChain[i]->rgpElement[k]->pCertContext);\n\t\t}\n\t\t// verify that the root of the chain can be found in the trusted store\n\t\tPCCERT_CONTEXT pResult = CertFindCertificateInStore(trustedCerts, certs.back()->dwCertEncodingType, 0, CERT_FIND_ISSUER_OF, certs.back(), 0);\n\t\tif (!pResult)\n\t\t{\n\t\t\tpoco_assert_dbg (GetLastError() == CRYPT_E_NOT_FOUND);\n\t\t\tVerificationErrorArgs args(cert, i, 0, \"Certificate Authority not trusted\");\n\t\t\tSSLManager::instance().ClientVerificationError(this, args);\n\t\t\tCertFreeCertificateChain(pChainContext);\n\t\t\tif (!args.getIgnoreError())\n\t\t\t\tthrow CertificateValidationException(\"Failed to verify certificate chain: CA not trusted\");\n\t\t\telse\n\t\t\t\treturn;\n\t\t}\n\t\tCertFreeCertificateContext(pResult);\n\n#if !defined(_WIN32_WCE)\n\t\t// check if cert is revoked\n\t\tif (_pContext->options() & Context::OPT_PERFORM_REVOCATION_CHECK)\n\t\t{\n\t\t\tCERT_REVOCATION_STATUS revStat;\n\t\t\trevStat.cbSize = sizeof(CERT_REVOCATION_STATUS);\n\n\t\t\tBOOL ok = CertVerifyRevocation(\n\t\t\t\t\tX509_ASN_ENCODING | PKCS_7_ASN_ENCODING,\n\t\t\t\t\tCERT_CONTEXT_REVOCATION_TYPE,\n\t\t\t\t\tstatic_cast<DWORD>(certs.size()),\n\t\t\t\t\t(void**) &certs[0],\n\t\t\t\t\tCERT_VERIFY_REV_CHAIN_FLAG,\n\t\t\t\t\tNULL,\n\t\t\t\t\t&revStat);\n\n\t\t\t// Revocation check of the root certificate may fail due to missing CRL points, etc.\n\t\t\t// We ignore all errors checking the root certificate except CRYPT_E_REVOKED.\n\t\t\tif (!ok && revStat.dwIndex < certs.size() - 1 && revStat.dwError == CRYPT_E_REVOKED)\n\t\t\t{\n\t\t\t\tVerificationErrorArgs args(cert, revStat.dwIndex, revStat.dwReason, Utility::formatError(revStat.dwError));\n\t\t\t\tSSLManager::instance().ClientVerificationError(this, args);\n\t\t\t\tif (!args.getIgnoreError())\n\t\t\t\t{\n\t\t\t\t\tCertFreeCertificateChain(pChainContext);\n\t\t\t\t\tthrow SSLException(\"Failed to verify revoked certificate chain\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse break;\n\t\t}\n#endif\n\t}\n\tCertFreeCertificateChain(pChainContext);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::serverVerifyCertificate()\n{\n\tif (_pContext->verificationMode() < Context::VERIFY_STRICT) return;\n\n\t// we are now in Strict mode\n\tif (!_pPeerCertificate) throw SSLException(\"No client certificate\");\n\n\tDWORD status = SEC_E_OK;\n\tX509Certificate cert(_pPeerCertificate, true);\n\n\tPCCERT_CHAIN_CONTEXT pChainContext = NULL;\n\tCERT_CHAIN_PARA chainPara;\n\tstd::memset(&chainPara, 0, sizeof(chainPara));\n\tchainPara.cbSize = sizeof(chainPara);\n\n\tif (!CertGetCertificateChain(\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t_pPeerCertificate,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&chainPara,\n\t\t\t\t\t\t\tCERT_CHAIN_REVOCATION_CHECK_CHAIN,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&pChainContext))\n\t{\n\t\tthrow SSLException(\"Cannot get certificate chain\", GetLastError());\n\t}\n\n\tHTTPSPolicyCallbackData polHttps;\n\tstd::memset(&polHttps, 0, sizeof(HTTPSPolicyCallbackData));\n\tpolHttps.cbStruct       = sizeof(HTTPSPolicyCallbackData);\n\tpolHttps.dwAuthType     = AUTHTYPE_CLIENT;\n\tpolHttps.fdwChecks      = 0;\n\tpolHttps.pwszServerName = 0;\n\n\tCERT_CHAIN_POLICY_PARA policyPara;\n\tstd::memset(&policyPara, 0, sizeof(policyPara));\n\tpolicyPara.cbSize = sizeof(policyPara);\n\tpolicyPara.pvExtraPolicyPara = &polHttps;\n\n\tCERT_CHAIN_POLICY_STATUS policyStatus;\n\tstd::memset(&policyStatus, 0, sizeof(policyStatus));\n\tpolicyStatus.cbSize = sizeof(policyStatus);\n\n\tif (!CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_SSL, pChainContext, &policyPara, &policyStatus))\n\t{\n\t\tVerificationErrorArgs args(cert, 0, GetLastError(), \"Failed to verify certificate chain\");\n\t\tSSLManager::instance().ServerVerificationError(this, args);\n\t\tCertFreeCertificateChain(pChainContext);\n\t\tif (!args.getIgnoreError())\n\t\t\tthrow SSLException(\"Cannot verify certificate chain\");\n\t\telse\n\t\t\treturn;\n\t}\n\telse if (policyStatus.dwError)\n\t{\n\t\tVerificationErrorArgs args(cert, policyStatus.lElementIndex, status, Utility::formatError(policyStatus.dwError));\n\t\tSSLManager::instance().ServerVerificationError(this, args);\n\t\tCertFreeCertificateChain(pChainContext);\n\t\tif (!args.getIgnoreError())\n\t\t\tthrow SSLException(\"Failed to verify certificate chain\");\n\t\telse\n\t\t\treturn;\n\t}\n\n#if !defined(_WIN32_WCE)\n\t// perform revocation checking\n\tfor (DWORD i = 0; i < pChainContext->cChain; i++)\n\t{\n\t\tstd::vector<PCCERT_CONTEXT> certs;\n\t\tfor (DWORD k = 0; k < pChainContext->rgpChain[i]->cElement; k++)\n\t\t{\n\t\t\tcerts.push_back(pChainContext->rgpChain[i]->rgpElement[k]->pCertContext);\n\t\t}\n\n\t\tCERT_REVOCATION_STATUS revStat;\n\t\trevStat.cbSize = sizeof(CERT_REVOCATION_STATUS);\n\n\t\tBOOL ok = CertVerifyRevocation(\n\t\t\t\t\t\tX509_ASN_ENCODING | PKCS_7_ASN_ENCODING,\n\t\t\t\t\t\tCERT_CONTEXT_REVOCATION_TYPE,\n\t\t\t\t\t\tstatic_cast<DWORD>(certs.size()),\n\t\t\t\t\t\t(void**) &certs[0],\n\t\t\t\t\t\tCERT_VERIFY_REV_CHAIN_FLAG,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&revStat);\n\n\t\t// Revocation check of the root certificate may fail due to missing CRL points, etc.\n\t\t// We ignore all errors checking the root certificate except CRYPT_E_REVOKED.\n\t\tif (!ok && revStat.dwIndex < certs.size() - 1 && revStat.dwError == CRYPT_E_REVOKED)\n\t\t{\n\t\t\tVerificationErrorArgs args(cert, revStat.dwIndex, revStat.dwReason, Utility::formatError(revStat.dwReason));\n\t\t\tSSLManager::instance().ServerVerificationError(this, args);\n\t\t\tif (!args.getIgnoreError())\n\t\t\t{\n\t\t\t\tCertFreeCertificateChain(pChainContext);\n\t\t\t\tthrow SSLException(\"Failed to verify certificate chain\");\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tif (pChainContext)\n\t{\n\t\tCertFreeCertificateChain(pChainContext);\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "LONG SecureSocketImpl::clientDisconnect(PCredHandle phCreds, CtxtHandle* phContext)\n{\n\tif (phContext->dwLower == 0 && phContext->dwUpper == 0)\n\t{\n\t\treturn SEC_E_OK;\n\t}\n\n\tAutoSecBufferDesc<1> tokBuffer(&_securityFunctions, false);\n\n\tDWORD tokenType = SCHANNEL_SHUTDOWN;\n\ttokBuffer.setSecBufferToken(0, &tokenType, sizeof(tokenType));\n\tDWORD status = _securityFunctions.ApplyControlToken(phContext, &tokBuffer);\n\n\tif (FAILED(status)) return status;\n\n\tDWORD sspiFlags = ISC_REQ_SEQUENCE_DETECT\n                    | ISC_REQ_REPLAY_DETECT\n\t                | ISC_REQ_CONFIDENTIALITY\n\t                | ISC_RET_EXTENDED_ERROR\n\t                | ISC_REQ_ALLOCATE_MEMORY\n\t                | ISC_REQ_STREAM;\n\n\tAutoSecBufferDesc<1> outBuffer(&_securityFunctions, true);\n\toutBuffer.setSecBufferToken(0, 0, 0);\n\n\tDWORD sspiOutFlags;\n\tTimeStamp expiry;\n\tstatus = _securityFunctions.InitializeSecurityContextW(\n\t\t\t\tphCreds,\n\t\t\t\tphContext,\n\t\t\t\tNULL,\n\t\t\t\tsspiFlags,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tNULL,\n\t\t\t\t0,\n\t\t\t\tphContext,\n\t\t\t\t&outBuffer,\n\t\t\t\t&sspiOutFlags,\n\t\t\t\t&expiry);\n\n\treturn status;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "LONG SecureSocketImpl::serverDisconnect(PCredHandle phCreds, CtxtHandle* phContext)\n{\n\tif (phContext->dwLower == 0 && phContext->dwUpper == 0)\n\t{\n\t\t// handshake has never been done\n\t\tpoco_assert_dbg (_needHandshake);\n\t\treturn SEC_E_OK;\n\t}\n\n\tAutoSecBufferDesc<1> tokBuffer(&_securityFunctions, false);\n\n\tDWORD tokenType = SCHANNEL_SHUTDOWN;\n\ttokBuffer.setSecBufferToken(0, &tokenType, sizeof(tokenType));\n\tDWORD status = _securityFunctions.ApplyControlToken(phContext, &tokBuffer);\n\n\tif (FAILED(status)) return status;\n\n\tDWORD sspiFlags = ASC_REQ_SEQUENCE_DETECT\n\t                | ASC_REQ_REPLAY_DETECT\n\t                | ASC_REQ_CONFIDENTIALITY\n\t                | ASC_REQ_EXTENDED_ERROR\n\t                | ASC_REQ_ALLOCATE_MEMORY\n\t                | ASC_REQ_STREAM;\n\n\tAutoSecBufferDesc<1> outBuffer(&_securityFunctions, true);\n\toutBuffer.setSecBufferToken(0,0,0);\n\n\tDWORD sspiOutFlags;\n\tTimeStamp expiry;\n\tstatus = _securityFunctions.AcceptSecurityContext(\n\t\t\t\t\tphCreds,\n\t\t\t\t\tphContext,\n\t\t\t\t\tNULL,\n\t\t\t\t\tsspiFlags,\n\t\t\t\t\t0,\n\t\t\t\t\tNULL,\n\t\t\t\t\t&outBuffer,\n\t\t\t\t\t&sspiOutFlags,\n\t\t\t\t\t&expiry);\n\n\tif (FAILED(status)) return status;\n\n\tif (outBuffer[0].pvBuffer && outBuffer[0].cbBuffer)\n\t{\n\t\tint sent = sendRawBytes(outBuffer[0].pvBuffer, outBuffer[0].cbBuffer);\n\t\tif (sent <= 0)\n\t\t{\n\t\t\tstatus = WSAGetLastError();\n\t\t}\n\t}\n\n\treturn status;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::stateIllegal()\n{\n\tthrow Poco::IllegalStateException(\"SSL state machine\");\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::stateConnected()\n{\n\t_peerHostName = _pSocket->peerAddress().host().toString();\n\tinitClientContext();\n\tperformInitialClientHandshake();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void SecureSocketImpl::stateMachine()\n{\n\tStateMachine::instance().execute(this);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "StateMachine& StateMachine::instance()\n{\n\treturn *stateMachineSingleton.get();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "bool StateMachine::readable(SOCKET sockfd)\n{\n\tfd_set fdRead;\n\tFD_ZERO(&fdRead);\n\tFD_SET(sockfd, &fdRead);\n\tselect(&fdRead, 0, sockfd);\n\treturn (FD_ISSET(sockfd, &fdRead) != 0);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "bool StateMachine::writable(SOCKET sockfd)\n{\n\tfd_set fdWrite;\n\tFD_ZERO(&fdWrite);\n\tFD_SET(sockfd, &fdWrite);\n\tselect(0, &fdWrite, sockfd);\n\treturn (FD_ISSET(sockfd, &fdWrite) != 0);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "bool StateMachine::readOrWritable(SOCKET sockfd)\n{\n\tfd_set fdRead, fdWrite;\n\tFD_ZERO(&fdRead);\n\tFD_SET(sockfd, &fdRead);\n\tfdWrite = fdRead;\n\tselect(&fdRead, &fdWrite, sockfd);\n\treturn (FD_ISSET(sockfd, &fdRead) != 0 || FD_ISSET(sockfd, &fdWrite) != 0);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "bool StateMachine::none(SOCKET sockfd)\n{\n\treturn true;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void StateMachine::select(fd_set* fdRead, fd_set* fdWrite, SOCKET sockfd)\n{\n\tPoco::Timespan remainingTime(((Poco::Timestamp::TimeDiff)SecureSocketImpl::TIMEOUT_MILLISECS)*1000);\n\tint rc(0);\n\tdo\n\t{\n\t\tstruct timeval tv;\n\t\ttv.tv_sec  = (long) remainingTime.totalSeconds();\n\t\ttv.tv_usec = (long) remainingTime.useconds();\n\t\tPoco::Timestamp start;\n\t\trc = ::select(int(sockfd) + 1, fdRead, fdWrite, 0, &tv);\n\t\tif (rc < 0 && SecureSocketImpl::lastError() == POCO_EINTR)\n\t\t{\n\t\t\tPoco::Timestamp end;\n\t\t\tPoco::Timespan waited = end - start;\n\t\t\tif (waited < remainingTime)\n\t\t\t\tremainingTime -= waited;\n\t\t\telse\n\t\t\t\tremainingTime = 0;\n\t\t}\n\t}\n\twhile (rc < 0 && SecureSocketImpl::lastError() == POCO_EINTR);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureSocketImpl.cpp", "func": "void StateMachine::execute(SecureSocketImpl* pSock)\n{\n\ttry\n\t{\n\t\tpoco_assert_dbg (pSock);\n\t\tConditionState& state = _states[pSock->getState()];\n\t\tConditionMethod& meth = state.first;\n\t\tif ((this->*state.first)(pSock->sockfd()))\n\t\t{\n\t\t\t(pSock->*(state.second))();\n\t\t\t(pSock->getState() == SecureSocketImpl::ST_DONE);\n\t\t}\n\t}\n\tcatch (...)\n\t{\n\t\tpSock->setState(SecureSocketImpl::ST_ERROR);\n\t\tthrow;\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "SecureStreamSocket& SecureStreamSocket::operator = (const Socket& socket)\n{\n\tif (dynamic_cast<SecureStreamSocketImpl*>(socket.impl()))\n\t\tStreamSocket::operator = (socket);\n\telse\n\t\tthrow InvalidArgumentException(\"Cannot assign incompatible socket\");\n\treturn *this;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "bool SecureStreamSocket::havePeerCertificate() const\n{\n\treturn static_cast<SecureStreamSocketImpl*>(impl())->havePeerCertificate();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "X509Certificate SecureStreamSocket::peerCertificate() const\n{\n\treturn static_cast<SecureStreamSocketImpl*>(impl())->peerCertificate();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "void SecureStreamSocket::setPeerHostName(const std::string& hostName)\n{\n\tstatic_cast<SecureStreamSocketImpl*>(impl())->setPeerHostName(hostName);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "const std::string& SecureStreamSocket::getPeerHostName() const\n{\n\treturn static_cast<SecureStreamSocketImpl*>(impl())->getPeerHostName();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "SecureStreamSocket SecureStreamSocket::attach(const StreamSocket& streamSocket)\n{\n\tSecureStreamSocketImpl* pImpl = new SecureStreamSocketImpl(static_cast<StreamSocketImpl*>(streamSocket.impl()), SSLManager::instance().defaultClientContext());\n\tSecureStreamSocket result(pImpl);\n\tpImpl->connectSSL();\n\treturn result;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "SecureStreamSocket SecureStreamSocket::attach(const StreamSocket& streamSocket, Context::Ptr pContext)\n{\n\tSecureStreamSocketImpl* pImpl = new SecureStreamSocketImpl(static_cast<StreamSocketImpl*>(streamSocket.impl()), pContext);\n\tSecureStreamSocket result(pImpl);\n\tpImpl->connectSSL();\n\treturn result;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "SecureStreamSocket SecureStreamSocket::attach(const StreamSocket& streamSocket, Context::Ptr pContext, Session::Ptr pSession)\n{\n\tSecureStreamSocketImpl* pImpl = new SecureStreamSocketImpl(static_cast<StreamSocketImpl*>(streamSocket.impl()), pContext);\n\tSecureStreamSocket result(pImpl);\n\tresult.useSession(pSession);\n\tpImpl->connectSSL();\n\treturn result;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "SecureStreamSocket SecureStreamSocket::attach(const StreamSocket& streamSocket, const std::string& peerHostName)\n{\n\tSecureStreamSocketImpl* pImpl = new SecureStreamSocketImpl(static_cast<StreamSocketImpl*>(streamSocket.impl()), SSLManager::instance().defaultClientContext());\n\tSecureStreamSocket result(pImpl);\n\tresult.setPeerHostName(peerHostName);\n\tpImpl->connectSSL();\n\treturn result;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "SecureStreamSocket SecureStreamSocket::attach(const StreamSocket& streamSocket, const std::string& peerHostName, Context::Ptr pContext)\n{\n\tSecureStreamSocketImpl* pImpl = new SecureStreamSocketImpl(static_cast<StreamSocketImpl*>(streamSocket.impl()), pContext);\n\tSecureStreamSocket result(pImpl);\n\tresult.setPeerHostName(peerHostName);\n\tpImpl->connectSSL();\n\treturn result;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "SecureStreamSocket SecureStreamSocket::attach(const StreamSocket& streamSocket, const std::string& peerHostName, Context::Ptr pContext, Session::Ptr pSession)\n{\n\tSecureStreamSocketImpl* pImpl = new SecureStreamSocketImpl(static_cast<StreamSocketImpl*>(streamSocket.impl()), pContext);\n\tSecureStreamSocket result(pImpl);\n\tresult.setPeerHostName(peerHostName);\n\tresult.useSession(pSession);\n\tpImpl->connectSSL();\n\treturn result;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "Context::Ptr SecureStreamSocket::context() const\n{\n\treturn static_cast<SecureStreamSocketImpl*>(impl())->context();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "void SecureStreamSocket::setLazyHandshake(bool flag)\n{\n\tstatic_cast<SecureStreamSocketImpl*>(impl())->setLazyHandshake(flag);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "bool SecureStreamSocket::getLazyHandshake() const\n{\n\treturn static_cast<SecureStreamSocketImpl*>(impl())->getLazyHandshake();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "void SecureStreamSocket::verifyPeerCertificate()\n{\n\tstatic_cast<SecureStreamSocketImpl*>(impl())->verifyPeerCertificate();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "void SecureStreamSocket::verifyPeerCertificate(const std::string& hostName)\n{\n\tstatic_cast<SecureStreamSocketImpl*>(impl())->verifyPeerCertificate(hostName);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "int SecureStreamSocket::completeHandshake()\n{\n\treturn static_cast<SecureStreamSocketImpl*>(impl())->completeHandshake();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "Session::Ptr SecureStreamSocket::currentSession()\n{\n\treturn static_cast<SecureStreamSocketImpl*>(impl())->currentSession();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "void SecureStreamSocket::useSession(Session::Ptr pSession)\n{\n\tstatic_cast<SecureStreamSocketImpl*>(impl())->useSession(pSession);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "bool SecureStreamSocket::sessionWasReused()\n{\n\treturn static_cast<SecureStreamSocketImpl*>(impl())->sessionWasReused();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocket.cpp", "func": "void SecureStreamSocket::abort()\n{\n\tstatic_cast<SecureStreamSocketImpl*>(impl())->abort();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "SocketImpl* SecureStreamSocketImpl::acceptConnection(SocketAddress& clientAddr)\n{\n\tthrow Poco::InvalidAccessException(\"Cannot acceptConnection() on a SecureStreamSocketImpl\");\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::acceptSSL()\n{\n\t_impl.acceptSSL();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::connect(const SocketAddress& address)\n{\n\t_impl.connect(address, !_lazyHandshake);\n\treset(_impl.sockfd());\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::connect(const SocketAddress& address, const Poco::Timespan& timeout)\n{\n\t_impl.connect(address, timeout, !_lazyHandshake);\n\treset(_impl.sockfd());\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::connectNB(const SocketAddress& address)\n{\n\t_impl.connectNB(address);\n\treset(_impl.sockfd());\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::connectSSL()\n{\n\t_impl.connectSSL(!_lazyHandshake);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::bind(const SocketAddress& address, bool reuseAddress)\n{\n\tthrow Poco::InvalidAccessException(\"Cannot bind() a SecureStreamSocketImpl\");\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::listen(int backlog)\n{\n\tthrow Poco::InvalidAccessException(\"Cannot listen() on a SecureStreamSocketImpl\");\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::close()\n{\n\treset();\n\t_impl.close();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::abort()\n{\n\treset();\n\t_impl.abort();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "int SecureStreamSocketImpl::sendBytes(const void* buffer, int length, int flags)\n{\n\treturn _impl.sendBytes(buffer, length, flags);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "int SecureStreamSocketImpl::receiveBytes(void* buffer, int length, int flags)\n{\n\treturn _impl.receiveBytes(buffer, length, flags);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "int SecureStreamSocketImpl::sendTo(const void* buffer, int length, const SocketAddress& address, int flags)\n{\n\tthrow Poco::InvalidAccessException(\"Cannot sendTo() on a SecureStreamSocketImpl\");\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "int SecureStreamSocketImpl::receiveFrom(void* buffer, int length, SocketAddress& address, int flags)\n{\n\tthrow Poco::InvalidAccessException(\"Cannot receiveFrom() on a SecureStreamSocketImpl\");\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::sendUrgent(unsigned char data)\n{\n\tthrow Poco::InvalidAccessException(\"Cannot sendUrgent() on a SecureStreamSocketImpl\");\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "int SecureStreamSocketImpl::available()\n{\n\treturn _impl.available();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::shutdownReceive()\n{\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::shutdownSend()\n{\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::shutdown()\n{\n\t_impl.shutdown();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "bool SecureStreamSocketImpl::secure() const\n{\n\treturn true;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "bool SecureStreamSocketImpl::havePeerCertificate() const\n{\n\treturn _impl.peerCertificate() != 0;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "X509Certificate SecureStreamSocketImpl::peerCertificate() const\n{\n\tif (havePeerCertificate())\n\t{\n\t\treturn X509Certificate(_impl.peerCertificate(), true);\n\t}\n\telse throw SSLException(\"No certificate available\");\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::setLazyHandshake(bool flag)\n{\n\t_lazyHandshake = flag;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "bool SecureStreamSocketImpl::getLazyHandshake() const\n{\n\treturn _lazyHandshake;\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::verifyPeerCertificate()\n{\n\t_impl.verifyPeerCertificate();\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "void SecureStreamSocketImpl::verifyPeerCertificate(const std::string& hostName)\n{\n\t_impl.verifyPeerCertificate(hostName);\n}\n", "label": "network"}
{"project": "poco", "file": "SecureStreamSocketImpl.cpp", "func": "int SecureStreamSocketImpl::completeHandshake()\n{\n\t_impl.completeHandshake();\n\treturn 0;\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "SSLManager& SSLManager::instance()\n{\n\treturn *singleton.get();\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "void SSLManager::initializeServer(PrivateKeyPassphraseHandlerPtr pPassphraseHandler, InvalidCertificateHandlerPtr pCertHandler, Context::Ptr pContext)\n{\n\t_ptrServerPassphraseHandler  = pPassphraseHandler;\n\t_ptrServerCertificateHandler = pCertHandler;\n\t_ptrDefaultServerContext     = pContext;\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "void SSLManager::initializeClient(PrivateKeyPassphraseHandlerPtr pPassphraseHandler, InvalidCertificateHandlerPtr pCertHandler, Context::Ptr pContext)\n{\n\t_ptrClientPassphraseHandler  = pPassphraseHandler;\n\t_ptrClientCertificateHandler = pCertHandler;\n\t_ptrDefaultClientContext     = pContext;\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "Context::Ptr SSLManager::defaultServerContext()\n{\n\tPoco::FastMutex::ScopedLock lock(_mutex);\n\n\tif (!_ptrDefaultServerContext)\n\t\tinitDefaultContext(true);\n\n\treturn _ptrDefaultServerContext;\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "Context::Ptr SSLManager::defaultClientContext()\n{\n\tPoco::FastMutex::ScopedLock lock(_mutex);\n\n\tif (!_ptrDefaultClientContext)\n\t{\n\t\ttry\n\t\t{\n\t\t\tinitDefaultContext(false);\n\t\t} \n\t\tcatch (Poco::IllegalStateException&)\n\t\t{\n\t\t\t_ptrClientCertificateHandler = new RejectCertificateHandler(false);\n\t\t\t_ptrDefaultClientContext = new Context(Context::CLIENT_USE, \"\");\n\t\t}\n\t}\n\n\treturn _ptrDefaultClientContext;\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "SSLManager::PrivateKeyPassphraseHandlerPtr SSLManager::serverPassphraseHandler()\n{\n\tPoco::FastMutex::ScopedLock lock(_mutex);\n\n\tif (!_ptrServerPassphraseHandler)\n\t\tinitPassphraseHandler(true);\n\n\treturn _ptrServerPassphraseHandler;\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "SSLManager::PrivateKeyPassphraseHandlerPtr SSLManager::clientPassphraseHandler()\n{\n\tPoco::FastMutex::ScopedLock lock(_mutex);\n\n\tif (!_ptrClientPassphraseHandler)\n\t\tinitPassphraseHandler(false);\n\n\treturn _ptrClientPassphraseHandler;\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "SSLManager::InvalidCertificateHandlerPtr SSLManager::serverCertificateHandler()\n{\n\tPoco::FastMutex::ScopedLock lock(_mutex);\n\n\tif (!_ptrServerCertificateHandler)\n\t\tinitCertificateHandler(true);\n\n\treturn _ptrServerCertificateHandler;\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "SSLManager::InvalidCertificateHandlerPtr SSLManager::clientCertificateHandler()\n{\n\tPoco::FastMutex::ScopedLock lock(_mutex);\n\n\tif (!_ptrClientCertificateHandler)\n\t\tinitCertificateHandler(false);\n\n\treturn _ptrClientCertificateHandler;\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "void SSLManager::initDefaultContext(bool server)\n{\n\tif (server && _ptrDefaultServerContext) return;\n\tif (!server && _ptrDefaultClientContext) return;\n\n\tinitEvents(server);\n\n\tconst std::string prefix = server ? CFG_SERVER_PREFIX : CFG_CLIENT_PREFIX;\n\tPoco::Util::AbstractConfiguration& config = appConfig();\n\tstd::string certName = config.getString(prefix + CFG_CERT_NAME, VAL_CERT_NAME);\n\tstd::string certPath = config.getString(prefix + CFG_CERT_PATH, VAL_CERT_PATH);\n\tstd::string certStore = config.getString(prefix + CFG_CERT_STORE, VAL_CERT_STORE);\n\n\tbool requireTLSv1 = config.getBool(prefix + CFG_REQUIRE_TLSV1, false);\n\tbool requireTLSv1_1 = config.getBool(prefix + CFG_REQUIRE_TLSV1_1, false);\n\tbool requireTLSv1_2 = config.getBool(prefix + CFG_REQUIRE_TLSV1_2, false);\n\tbool requireTLSv1_3 = config.getBool(prefix + CFG_REQUIRE_TLSV1_3, false);\n\n\t// optional options for which we have defaults defined\n\tContext::VerificationMode verMode = VAL_VER_MODE;\n\tif (config.hasProperty(prefix + CFG_VER_MODE))\n\t{\n\t\t// either: none, relaxed, strict, once\n\t\tstd::string mode = config.getString(prefix + CFG_VER_MODE);\n\t\tverMode = Utility::convertVerificationMode(mode);\n\t}\n\tbool revocChecking = config.getBool(prefix + CFG_REVOCATION_CHECK, VAL_REVOCATION_CHECK);\n\tbool trustRoots = config.getBool(prefix + CFG_TRUST_ROOTS, VAL_TRUST_ROOTS);\n\tbool useMachineStore = config.getBool(prefix + CFG_USE_MACHINE_STORE, VAL_USE_MACHINE_STORE);\n\tbool useStrongCrypto = config.getBool(prefix + CFG_USE_STRONG_CRYPTO, VAL_USE_STRONG_CRYPTO);\n\n\tint options = 0;\n\tif (revocChecking) options |= Context::OPT_PERFORM_REVOCATION_CHECK;\n\tif (trustRoots) options |= Context::OPT_TRUST_ROOTS_WIN_CERT_STORE;\n\tif (useMachineStore) options |= Context::OPT_USE_MACHINE_STORE;\n\tif (useStrongCrypto) options |= Context::OPT_USE_STRONG_CRYPTO;\n\tif (!certPath.empty()) \n\t{\n\t\toptions |= Context::OPT_LOAD_CERT_FROM_FILE;\n\t\tcertName = certPath;\n\t}\n\n\tContext::Usage usage;\n\tif (server)\n\t{\n\t\tif (requireTLSv1_3)\n\t\t\tusage = Context::TLSV1_3_SERVER_USE;\n\t\telse if (requireTLSv1_2)\n\t\t\tusage = Context::TLSV1_2_SERVER_USE;\n\t\telse if (requireTLSv1_1)\n\t\t\tusage = Context::TLSV1_1_SERVER_USE;\n\t\telse if (requireTLSv1)\n\t\t\tusage = Context::TLSV1_SERVER_USE;\n\t\telse\n\t\t\tusage = Context::SERVER_USE;\n\t\t_ptrDefaultServerContext = new Context(usage, certName, verMode, options, certStore);\n\t}\n\telse\n\t{\n\t\tif (requireTLSv1_3)\n\t\t\tusage = Context::TLSV1_3_CLIENT_USE;\n\t\telse if (requireTLSv1_2)\n\t\t\tusage = Context::TLSV1_2_CLIENT_USE;\n\t\telse if (requireTLSv1_1)\n\t\t\tusage = Context::TLSV1_1_CLIENT_USE;\n\t\telse if (requireTLSv1)\n\t\t\tusage = Context::TLSV1_CLIENT_USE;\n\t\telse\n\t\t\tusage = Context::CLIENT_USE;\n\t\t_ptrDefaultClientContext = new Context(usage, certName, verMode, options, certStore);\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "void SSLManager::initEvents(bool server)\n{\n\tinitPassphraseHandler(server);\n\tinitCertificateHandler(server);\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "void SSLManager::initPassphraseHandler(bool server)\n{\n\tif (server && _ptrServerPassphraseHandler) return;\n\tif (!server && _ptrClientPassphraseHandler) return;\n\t\n\tstd::string prefix = server ? CFG_SERVER_PREFIX : CFG_CLIENT_PREFIX;\n\tPoco::Util::AbstractConfiguration& config = appConfig();\n\n\tstd::string className(config.getString(prefix + CFG_DELEGATE_HANDLER, VAL_DELEGATE_HANDLER));\n\n\tconst PrivateKeyFactory* pFactory = 0;\n\tif (privateKeyFactoryMgr().hasFactory(className))\n\t{\n\t\tpFactory = privateKeyFactoryMgr().getFactory(className);\n\t}\n\n\tif (pFactory)\n\t{\n\t\tif (server)\n\t\t\t_ptrServerPassphraseHandler = pFactory->create(server);\n\t\telse\n\t\t\t_ptrClientPassphraseHandler = pFactory->create(server);\n\t}\n\telse throw Poco::Util::UnknownOptionException(std::string(\"No passphrase handler known with the name \") + className);\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "void SSLManager::initCertificateHandler(bool server)\n{\n\tif (server && _ptrServerCertificateHandler) return;\n\tif (!server && _ptrClientCertificateHandler) return;\n\n\tstd::string prefix = server ? CFG_SERVER_PREFIX : CFG_CLIENT_PREFIX;\n\tPoco::Util::AbstractConfiguration& config = appConfig();\n\n\tstd::string className(config.getString(prefix + CFG_CERTIFICATE_HANDLER, VAL_CERTIFICATE_HANDLER));\n\n\tconst CertificateHandlerFactory* pFactory = 0;\n\tif (certificateHandlerFactoryMgr().hasFactory(className))\n\t{\n\t\tpFactory = certificateHandlerFactoryMgr().getFactory(className);\n\t}\n\n\tif (pFactory)\n\t{\n\t\tif (server)\n\t\t\t_ptrServerCertificateHandler = pFactory->create(true);\n\t\telse\n\t\t\t_ptrClientCertificateHandler = pFactory->create(false);\n\t}\n\telse throw Poco::Util::UnknownOptionException(\"No InvalidCertificate handler known with the name\", className);\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "void SSLManager::shutdown()\n{\n\tClientVerificationError.clear();\n\tServerVerificationError.clear();\n\t_ptrServerPassphraseHandler  = 0;\n\t_ptrServerCertificateHandler = 0;\n\t_ptrDefaultServerContext     = 0;\n\t_ptrClientPassphraseHandler  = 0;\n\t_ptrClientCertificateHandler = 0;\n\t_ptrDefaultClientContext     = 0;\n\n\tunloadSecurityLibrary();\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "void SSLManager::loadSecurityLibrary()\n{\n\tif (_hSecurityModule) return;\n\n\tOSVERSIONINFO VerInfo;\n\tstd::wstring dllPath;\n\n\t// Find out which security DLL to use, depending on\n\t// whether we are on Win2k, NT or Win9x\n\n\tVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n\tif (!GetVersionEx(&VerInfo))\n\t\tthrow Poco::SystemException(\"Cannot determine OS version\");\n\n#if defined(_WIN32_WCE)\n\tdllPath = L\"Secur32.dll\";\n#else\n\tif (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT \n\t\t&& VerInfo.dwMajorVersion == 4)\n\t{\n\t\tdllPath = L\"Security.dll\";\n\t}\n\telse if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ||\n\t\tVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT )\n\t{\n\t\tdllPath = L\"Secur32.dll\";\n\t}\n\telse\n\t{\n\t\tthrow Poco::SystemException(\"Cannot determine which security DLL to use\");\n\t}\n#endif\n\n\t//\n\t//  Load Security DLL\n\t//\n\n\t_hSecurityModule = LoadLibraryW(dllPath.c_str());\n\tif(_hSecurityModule == 0)\n\t{\n\t\tthrow Poco::SystemException(\"Failed to load security DLL\");\n\t}\n\n#if defined(_WIN32_WCE)\n\tINIT_SECURITY_INTERFACE pInitSecurityInterface = (INIT_SECURITY_INTERFACE)GetProcAddressW( _hSecurityModule, L\"InitSecurityInterfaceW\");\n#else\n\tINIT_SECURITY_INTERFACE pInitSecurityInterface = (INIT_SECURITY_INTERFACE)GetProcAddress( _hSecurityModule, \"InitSecurityInterfaceW\");\n#endif\n\n\tif (!pInitSecurityInterface)\n\t{\n\t\tFreeLibrary(_hSecurityModule);\n\t\t_hSecurityModule = 0;\n\t\tthrow Poco::SystemException(\"Failed to initialize security DLL (no init function)\");\n\t}\n\n\tPSecurityFunctionTable pSecurityFunc = pInitSecurityInterface();\n\tif (!pSecurityFunc)\n\t{\n\t\tFreeLibrary(_hSecurityModule);\n\t\t_hSecurityModule = 0;\n\t\tthrow Poco::SystemException(\"Failed to initialize security DLL (no function table)\");\n\t}\n\n\tCopyMemory(&_securityFunctions, pSecurityFunc, sizeof(_securityFunctions));\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "void SSLManager::unloadSecurityLibrary()\n{\n\tif (_hSecurityModule)\n\t{\n\t\tFreeLibrary(_hSecurityModule);\n\t\t_hSecurityModule = 0;\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "Poco::Util::AbstractConfiguration& SSLManager::appConfig()\n{\n\ttry\n\t{\n\t\treturn Poco::Util::Application::instance().config();\n\t}\n\tcatch (Poco::NullPointerException&)\n\t{\n\t\tthrow Poco::IllegalStateException(\n\t\t\t\"An application configuration is required to initialize the Poco::Net::SSLManager, \"\n\t\t\t\"but no Poco::Util::Application instance is available.\"\n\t\t);\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "void initializeSSL()\n{\n}\n", "label": "network"}
{"project": "poco", "file": "SSLManager.cpp", "func": "void uninitializeSSL()\n{\n\tSSLManager::instance().shutdown();\n}\n", "label": "network"}
{"project": "poco", "file": "Utility.cpp", "func": "Context::VerificationMode Utility::convertVerificationMode(const std::string& vMode)\n{\n\tstd::string mode = Poco::toLower(vMode);\n\tContext::VerificationMode verMode = Context::VERIFY_STRICT;\n\n\tif (mode == \"none\")\n\t\tverMode = Context::VERIFY_NONE;\n\telse if (mode == \"relaxed\")\n\t\tverMode = Context::VERIFY_RELAXED;\n\telse if (mode == \"strict\")\n\t\tverMode = Context::VERIFY_STRICT;\n\telse\n\t\tthrow Poco::Util::OptionException(std::string(\"Wrong value >\") + vMode + std::string(\"< for a verificationMode. Can only be none, relaxed, strict or once.\"));\n\n\treturn verMode;\n}\n", "label": "network"}
{"project": "poco", "file": "Utility.cpp", "func": "inline void add(std::map<long, const std::string>& messageMap, long key, const std::string& val)\n{\n\tmessageMap.insert(std::make_pair(key, val));\n}\n", "label": "network"}
{"project": "poco", "file": "Utility.cpp", "func": "std::map<long, const std::string> Utility::initSSPIErr()\n{\n\tstd::map<long, const std::string> messageMap;\n\tadd(messageMap, NTE_BAD_UID, \"Bad UID\");\n\tadd(messageMap, NTE_BAD_HASH, \"Bad Hash\");\n\tadd(messageMap, NTE_BAD_KEY, \"Bad Key\");\n\tadd(messageMap, NTE_BAD_LEN, \"Bad Length\");\n\tadd(messageMap, NTE_BAD_DATA, \"Bad Data\");\n\tadd(messageMap, NTE_BAD_SIGNATURE, \"Invalid signature\");\n\tadd(messageMap, NTE_BAD_VER, \"Bad Version of provider\");\n\tadd(messageMap, NTE_BAD_ALGID, \"Invalid algorithm specified\");\n\tadd(messageMap, NTE_BAD_FLAGS, \"Invalid flags specified\");\n\tadd(messageMap, NTE_BAD_TYPE, \"Invalid type specified\");\n\tadd(messageMap, NTE_BAD_KEY_STATE, \"Key not valid for use in specified state\");\n\tadd(messageMap, NTE_BAD_HASH_STATE, \"Hash not valid for use in specified state\");\n\tadd(messageMap, NTE_NO_KEY, \"Key does not exist\");\n\tadd(messageMap, NTE_NO_MEMORY, \"Insufficient memory available for the operation\");\n\tadd(messageMap, NTE_EXISTS, \"Object already exists\");\n\tadd(messageMap, NTE_PERM, \"Permission denied\");\n\tadd(messageMap, NTE_NOT_FOUND, \"Object was not found\");\n\tadd(messageMap, NTE_DOUBLE_ENCRYPT, \"Data already encrypted\");\n\tadd(messageMap, NTE_BAD_PROVIDER, \"Invalid provider specified\");\n\tadd(messageMap, NTE_BAD_PROV_TYPE, \"Invalid provider type specified\");\n\tadd(messageMap, NTE_BAD_PUBLIC_KEY, \"Provider's public key is invalid\");\n\tadd(messageMap, NTE_BAD_KEYSET, \"Keyset does not exist\");\n\tadd(messageMap, NTE_PROV_TYPE_NOT_DEF, \"Provider type not defined\");\n\tadd(messageMap, NTE_PROV_TYPE_ENTRY_BAD, \"Provider type as registered is invalid\");\n\tadd(messageMap, NTE_KEYSET_NOT_DEF, \"The keyset is not defined\");\n\tadd(messageMap, NTE_KEYSET_ENTRY_BAD, \"Keyset as registered is invalid\");\n\tadd(messageMap, NTE_PROV_TYPE_NO_MATCH, \"Provider type does not match registered value\");\n\tadd(messageMap, NTE_SIGNATURE_FILE_BAD, \"The digital signature file is corrupt\");\n\tadd(messageMap, NTE_PROVIDER_DLL_FAIL, \"Provider DLL failed to initialize correctly\");\n\tadd(messageMap, NTE_PROV_DLL_NOT_FOUND, \"Provider DLL could not be found\");\n\tadd(messageMap, NTE_BAD_KEYSET_PARAM, \"The Keyset parameter is invalid\");\n\tadd(messageMap, NTE_FAIL, \"NTE_FAIL: An internal error occurred\");\n\tadd(messageMap, NTE_SYS_ERR, \"NTE_SYS_ERR: A base error occurred\");\n\tadd(messageMap, NTE_SILENT_CONTEXT, \"Provider could not perform the action since the context was acquired as silent\");\n\tadd(messageMap, NTE_TOKEN_KEYSET_STORAGE_FULL, \"The security token does not have storage space available for an additional container\");\n\tadd(messageMap, NTE_TEMPORARY_PROFILE, \"The profile for the user is a temporary profile\");\n\tadd(messageMap, NTE_FIXEDPARAMETER, \"The key parameters could not be set because the CSP uses fixed parameters\");\n\tadd(messageMap, SEC_E_INSUFFICIENT_MEMORY, \"Not enough memory is available to complete this request\");\n\tadd(messageMap, SEC_E_INVALID_HANDLE, \"The handle specified is invalid\");\n\tadd(messageMap, SEC_E_UNSUPPORTED_FUNCTION, \"The function requested is not supported\");\n\tadd(messageMap, SEC_E_TARGET_UNKNOWN, \"The specified target is unknown or unreachable\");\n\tadd(messageMap, SEC_E_INTERNAL_ERROR, \"The Local Security Authority cannot be contacted\");\n\tadd(messageMap, SEC_E_SECPKG_NOT_FOUND, \"The requested security package does not exist\");\n\tadd(messageMap, SEC_E_NOT_OWNER, \"The caller is not the owner of the desired credentials\");\n\tadd(messageMap, SEC_E_CANNOT_INSTALL, \"The security package failed to initialize, and cannot be installed\");\n\tadd(messageMap, SEC_E_INVALID_TOKEN, \"The token supplied to the function is invalid\");\n\tadd(messageMap, SEC_E_CANNOT_PACK, \"The security package is not able to marshall the logon buffer, so the logon attempt has failed\");\n\tadd(messageMap, SEC_E_QOP_NOT_SUPPORTED, \"The per-message Quality of Protection is not supported by the security package\");\n\tadd(messageMap, SEC_E_NO_IMPERSONATION, \"The security context does not allow impersonation of the client\");\n\tadd(messageMap, SEC_E_LOGON_DENIED, \"The logon attempt failed\");\n\tadd(messageMap, SEC_E_UNKNOWN_CREDENTIALS, \"The credentials supplied to the package were not recognized\");\n\tadd(messageMap, SEC_E_NO_CREDENTIALS, \"No credentials are available in the security package\");\n\tadd(messageMap, SEC_E_MESSAGE_ALTERED, \"The message or signature supplied for verification has been altered\");\n\tadd(messageMap, SEC_E_OUT_OF_SEQUENCE, \"The message supplied for verification is out of sequence\");\n\tadd(messageMap, SEC_E_NO_AUTHENTICATING_AUTHORITY, \"No authority could be contacted for authentication\");\n\tadd(messageMap, SEC_I_CONTINUE_NEEDED, \"The function completed successfully, but must be called again to complete the context\");\n\tadd(messageMap, SEC_I_COMPLETE_NEEDED, \"The function completed successfully, but CompleteToken must be called\");\n\tadd(messageMap, SEC_I_COMPLETE_AND_CONTINUE, \"The function completed successfully, but both CompleteToken and this function must be called to complete the context\");\n\tadd(messageMap, SEC_I_LOCAL_LOGON, \"The logon was completed, but no network authority was available. The logon was made using locally known information\");\n\tadd(messageMap, SEC_E_BAD_PKGID, \"The requested security package does not exist\");\n\tadd(messageMap, SEC_E_CONTEXT_EXPIRED, \"The context has expired and can no longer be used\");\n\tadd(messageMap, SEC_E_INCOMPLETE_MESSAGE, \"The supplied message is incomplete. The signature was not verified\");\n\tadd(messageMap, SEC_E_INCOMPLETE_CREDENTIALS, \"The credentials supplied were not complete, and could not be verified. The context could not be initialized\");\n\tadd(messageMap, SEC_E_BUFFER_TOO_SMALL, \"The buffers supplied to a function was too small\");\n\tadd(messageMap, SEC_I_RENEGOTIATE, \"The context data must be renegotiated with the peer\");\n\tadd(messageMap, SEC_E_WRONG_PRINCIPAL, \"The target principal name is incorrect\");\n\tadd(messageMap, SEC_I_NO_LSA_CONTEXT, \"There is no LSA mode context associated with this context\");\n\tadd(messageMap, SEC_E_TIME_SKEW, \"The clocks on the client and server machines are skewed\");\n\tadd(messageMap, SEC_E_UNTRUSTED_ROOT, \"The certificate chain was issued by an authority that is not trusted\");\n\tadd(messageMap, SEC_E_ILLEGAL_MESSAGE, \"The message received was unexpected or badly formatted\");\n\tadd(messageMap, SEC_E_CERT_UNKNOWN, \"An unknown error occurred while processing the certificate\");\n\tadd(messageMap, SEC_E_CERT_EXPIRED, \"The received certificate has expired\");\n\tadd(messageMap, SEC_E_ENCRYPT_FAILURE, \"The specified data could not be encrypted\");\n\tadd(messageMap, SEC_E_DECRYPT_FAILURE, \"The specified data could not be decrypted\");\n\tadd(messageMap, SEC_E_ALGORITHM_MISMATCH, \"The client and server cannot communicate, because they do not possess a common algorithm\");\n\tadd(messageMap, SEC_E_SECURITY_QOS_FAILED, \"The security context could not be established due to a failure in the requested quality of service (e.g. mutual authentication or delegation)\");\n\tadd(messageMap, SEC_E_UNFINISHED_CONTEXT_DELETED, \"A security context was deleted before the context was completed.  This is considered a logon failure\");\n\tadd(messageMap, SEC_E_NO_TGT_REPLY, \"The client is trying to negotiate a context and the server requires user-to-user but didn't send a TGT reply\");\n\tadd(messageMap, SEC_E_NO_IP_ADDRESSES, \"Unable to accomplish the requested task because the local machine does not have any IP addresses\");\n\tadd(messageMap, SEC_E_WRONG_CREDENTIAL_HANDLE, \"The supplied credential handle does not match the credential associated with the security context\");\n\tadd(messageMap, SEC_E_CRYPTO_SYSTEM_INVALID, \"The crypto system or checksum function is invalid because a required function is unavailable\");\n\tadd(messageMap, SEC_E_MAX_REFERRALS_EXCEEDED, \"The number of maximum ticket referrals has been exceeded\");\n\tadd(messageMap, SEC_E_MUST_BE_KDC, \"The local machine must be a Kerberos KDC (domain controller) and it is not\");\n\tadd(messageMap, SEC_E_STRONG_CRYPTO_NOT_SUPPORTED, \"The other end of the security negotiation is requires strong crypto but it is not supported on the local machine\");\n\tadd(messageMap, SEC_E_TOO_MANY_PRINCIPALS, \"The KDC reply contained more than one principal name\");\n\tadd(messageMap, SEC_E_NO_PA_DATA, \"Expected to find PA data for a hint of what type to use, but it was not found\");\n\t//80092001\n\tadd(messageMap, CRYPT_E_SELF_SIGNED, \"The specified certificate is self signed\");\n\tadd(messageMap, CRYPT_E_DELETED_PREV, \"The previous certificate or CRL context was deleted\");\n\tadd(messageMap, CRYPT_E_NO_MATCH, \"Cannot find the requested object\");\n\tadd(messageMap, CRYPT_E_UNEXPECTED_MSG_TYPE, \"The certificate does not have a property that references a private key\");\n\tadd(messageMap, CRYPT_E_NO_KEY_PROPERTY, \"Cannot find the certificate and private key for decryption\");\n\tadd(messageMap, CRYPT_E_NO_DECRYPT_CERT, \"Cannot find the certificate and private key to use for decryption\");\n\tadd(messageMap, CRYPT_E_BAD_MSG, \"Not a cryptographic message or the cryptographic message is not formatted correctly\");\n\tadd(messageMap, CRYPT_E_NO_SIGNER, \"The signed cryptographic message does not have a signer for the specified signer index\");\n\tadd(messageMap, CRYPT_E_PENDING_CLOSE, \"Final closure is pending until additional frees or closes\");\n\tadd(messageMap, CRYPT_E_REVOKED, \"The certificate is revoked\");\n\tadd(messageMap, CRYPT_E_NO_REVOCATION_DLL, \"No Dll or exported function was found to verify revocation\");\n\tadd(messageMap, CRYPT_E_NO_REVOCATION_CHECK, \"The revocation function was unable to check revocation for the certificate\");\n\tadd(messageMap, CRYPT_E_REVOCATION_OFFLINE, \"The revocation function was unable to check revocation because the revocation server was offline\");\n\tadd(messageMap, CRYPT_E_NOT_IN_REVOCATION_DATABASE, \"The certificate is not in the revocation server's database\");\n\tadd(messageMap, CRYPT_E_INVALID_NUMERIC_STRING, \"The string contains a non-numeric character\");\n\tadd(messageMap, CRYPT_E_INVALID_PRINTABLE_STRING, \"The string contains a non-printable character\");\n\tadd(messageMap, CRYPT_E_INVALID_IA5_STRING, \"The string contains a character not in the 7 bit ASCII character set\");\n\tadd(messageMap, CRYPT_E_INVALID_X500_STRING, \"The string contains an invalid X500 name attribute key, oid, value or delimiter\");\n\tadd(messageMap, CRYPT_E_NOT_CHAR_STRING, \"The dwValueType for the CERT_NAME_VALUE is not one of the character strings.  Most likely it is either a CERT_RDN_ENCODED_BLOB or CERT_TDN_OCTED_STRING\");\n\tadd(messageMap, CRYPT_E_FILERESIZED, \"The Put operation can not continue.  The file needs to be resized.  However, there is already a signature present.  A complete signing operation must be done\");\n\tadd(messageMap, CRYPT_E_SECURITY_SETTINGS, \"The cryptographic operation failed due to a local security option setting\");\n\tadd(messageMap, CRYPT_E_NO_VERIFY_USAGE_DLL, \"No DLL or exported function was found to verify subject usage\");\n\tadd(messageMap, CRYPT_E_NO_VERIFY_USAGE_CHECK, \"The called function was unable to do a usage check on the subject\");\n\tadd(messageMap, CRYPT_E_VERIFY_USAGE_OFFLINE, \"Since the server was offline, the called function was unable to complete the usage check\");\n\tadd(messageMap, CRYPT_E_NOT_IN_CTL, \"The subject was not found in a Certificate Trust List (CTL)\");\n\tadd(messageMap, CRYPT_E_NO_TRUSTED_SIGNER, \"None of the signers of the cryptographic message or certificate trust list is trusted\");\n\tadd(messageMap, CRYPT_E_MISSING_PUBKEY_PARA, \"The public key's algorithm parameters are missing\");\n\tadd(messageMap, TRUST_E_CERT_SIGNATURE, \"The signature of the certificate cannot be verified.\");\n\tadd(messageMap, TRUST_E_BASIC_CONSTRAINTS, \"The basic constraints of the certificate are not valid or missing\");\n\tadd(messageMap, CERT_E_UNTRUSTEDROOT, \"A certification chain processed correctly but terminated in a root certificate not trusted by the trust provider\");\n\tadd(messageMap, CERT_E_UNTRUSTEDTESTROOT, \"The root certificate is a testing certificate and policy settings disallow test certificates\");\n\tadd(messageMap, CERT_E_CHAINING, \"A chain of certificates was not correctly created\");\n\tadd(messageMap, CERT_E_WRONG_USAGE, \"The certificate is not valid for the requested usage\");\n\tadd(messageMap, CERT_E_EXPIRED, \"A required certificate is not within its validity period\");\n\tadd(messageMap, CERT_E_VALIDITYPERIODNESTING, \"The validity periods of the certification chain do not nest correctly\");\n\tadd(messageMap, CERT_E_PURPOSE, \"A certificate is being used for a purpose that is not supported\");\n\tadd(messageMap, CERT_E_ROLE, \"A certificate that can only be used as an end entity is being used as a CA or visa versa\");\n\tadd(messageMap, CERT_E_CN_NO_MATCH, \"The CN name of the certificate does not match the passed value\");\n\tadd(messageMap, CERT_E_REVOKED, \"A certificate in the chain has been explicitly revoked by its issuer\");\n\tadd(messageMap, CERT_E_REVOCATION_FAILURE, \"The revocation process could not continue. The certificates could not be checked\");\n\treturn messageMap;\n}\n", "label": "network"}
{"project": "poco", "file": "Utility.cpp", "func": "const std::string& Utility::formatError(long errCode)\n{\n\tPoco::FastMutex::ScopedLock lock(_mutex);\n\n\tstatic const std::string def(\"Internal SSPI error\");\n\tstatic const std::map<long, const std::string> errs(initSSPIErr());\n\n\tconst std::map<long, const std::string>::const_iterator it = errs.find(errCode);\n\tif (it != errs.end())\n\t\treturn it->second;\n\telse\n\t\treturn def;\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "X509Certificate& X509Certificate::operator = (const X509Certificate& cert)\n{\n\tX509Certificate tmp(cert);\n\tswap(tmp);\n\treturn *this;\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "X509Certificate& X509Certificate::operator = (X509Certificate&& cert) noexcept\n{\n\t_issuerName = std::move(cert._issuerName);\n\t_subjectName = std::move(cert._subjectName);\n\t_pCert = cert._pCert; cert._pCert = nullptr;\n\n\treturn *this;\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "void X509Certificate::swap(X509Certificate& cert)\n{\n\tusing std::swap;\n\tswap(cert._issuerName, _issuerName);\n\tswap(cert._subjectName, _subjectName);\n\tswap(cert._pCert, _pCert);\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "void X509Certificate::init()\n{\n\tstd::string name = issuerName(NID_COUNTRY);\n\tif (!name.empty())\n\t{\n\t\t_issuerName += \"/C=\";\n\t\t_issuerName += name;\n\t}\n\tname = issuerName(NID_STATE_OR_PROVINCE);\n\tif (!name.empty())\n\t{\n\t\t_issuerName += \"/ST=\";\n\t\t_issuerName += name;\n\t}\n\tname = issuerName(NID_LOCALITY_NAME);\n\tif (!name.empty())\n\t{\n\t\t_issuerName += \"/L=\";\n\t\t_issuerName += name;\n\t}\n\tname = issuerName(NID_ORGANIZATION_NAME);\n\tif (!name.empty())\n\t{\n\t\t_issuerName += \"/O=\";\n\t\t_issuerName += name;\n\t}\n\tname = issuerName(NID_ORGANIZATION_UNIT_NAME);\n\tif (!name.empty())\n\t{\n\t\t_issuerName += \"/OU=\";\n\t\t_issuerName += name;\n\t}\n\tname = issuerName(NID_COMMON_NAME);\n\tif (!name.empty())\n\t{\n\t\t_issuerName += \"/CN=\";\n\t\t_issuerName += name;\n\t}\n\n\tname = subjectName(NID_COUNTRY);\n\tif (!name.empty())\n\t{\n\t\t_subjectName += \"/C=\";\n\t\t_subjectName += name;\n\t}\n\tname = subjectName(NID_STATE_OR_PROVINCE);\n\tif (!name.empty())\n\t{\n\t\t_subjectName += \"/ST=\";\n\t\t_subjectName += name;\n\t}\n\tname = subjectName(NID_LOCALITY_NAME);\n\tif (!name.empty())\n\t{\n\t\t_subjectName += \"/L=\";\n\t\t_subjectName += name;\n\t}\n\tname = subjectName(NID_ORGANIZATION_NAME);\n\tif (!name.empty())\n\t{\n\t\t_subjectName += \"/O=\";\n\t\t_subjectName += name;\n\t}\n\tname = subjectName(NID_ORGANIZATION_UNIT_NAME);\n\tif (!name.empty())\n\t{\n\t\t_subjectName += \"/OU=\";\n\t\t_subjectName += name;\n\t}\n\tname = subjectName(NID_COMMON_NAME);\n\tif (!name.empty())\n\t{\n\t\t_subjectName += \"/CN=\";\n\t\t_subjectName += name;\n\t}}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "std::string X509Certificate::commonName() const\n{\n\treturn subjectName(NID_COMMON_NAME);\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "std::string X509Certificate::issuerName(NID nid) const\n{\n\tstd::string result;\n\tDWORD size = CertGetNameStringW(_pCert, CERT_NAME_ATTR_TYPE, CERT_NAME_ISSUER_FLAG, nid2oid(nid), 0, 0);\n\tPoco::Buffer<wchar_t> data(size);\n\tCertGetNameStringW(_pCert, CERT_NAME_ATTR_TYPE, CERT_NAME_ISSUER_FLAG, nid2oid(nid), data.begin(), size);\n\tPoco::UnicodeConverter::convert(data.begin(), result);\n\treturn result;\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "std::string X509Certificate::subjectName(NID nid) const\n{\n\tstd::string result;\n\tDWORD size = CertGetNameStringW(_pCert, CERT_NAME_ATTR_TYPE, 0, nid2oid(nid), 0, 0);\n\tPoco::Buffer<wchar_t> data(size);\n\tCertGetNameStringW(_pCert, CERT_NAME_ATTR_TYPE, 0, nid2oid(nid), data.begin(), size);\n\tPoco::UnicodeConverter::convert(data.begin(), result);\n\treturn result;\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "void X509Certificate::extractNames(std::string& cmnName, std::set<std::string>& domainNames) const\n{\n\tdomainNames.clear();\n\tcmnName = commonName();\n\tPCERT_EXTENSION pExt = _pCert->pCertInfo->rgExtension;\n\tfor (int i = 0; i < _pCert->pCertInfo->cExtension; i++, pExt++)\n\t{\n\t\tif (std::strcmp(pExt->pszObjId, szOID_SUBJECT_ALT_NAME2) == 0)\n\t\t{\n\t\t\tDWORD flags(0);\n#if defined(CRYPT_DECODE_ENABLE_PUNYCODE_FLAG)\n\t\t\tflags |= CRYPT_DECODE_ENABLE_PUNYCODE_FLAG;\n#endif\n\t\t\tPoco::Buffer<char> buffer(256);\n\t\t\tDWORD bufferSize = static_cast<DWORD>(buffer.sizeBytes());\n\t\t\tBOOL rc = CryptDecodeObjectEx(\n\t\t\t\t\tX509_ASN_ENCODING | PKCS_7_ASN_ENCODING,\n\t\t\t\t\tpExt->pszObjId,\n\t\t\t\t\tpExt->Value.pbData,\n\t\t\t\t\tpExt->Value.cbData,\n\t\t\t\t\tflags,\n\t\t\t\t\t0,\n\t\t\t\t\tbuffer.begin(),\n\t\t\t\t\t&bufferSize);\n\t\t\tif (!rc && GetLastError() == ERROR_MORE_DATA)\n\t\t\t{\n\t\t\t\tbuffer.resize(bufferSize);\n\t\t\t\trc = CryptDecodeObjectEx(\n\t\t\t\t\tX509_ASN_ENCODING | PKCS_7_ASN_ENCODING,\n\t\t\t\t\tpExt->pszObjId,\n\t\t\t\t\tpExt->Value.pbData,\n\t\t\t\t\tpExt->Value.cbData,\n\t\t\t\t\tflags,\n\t\t\t\t\t0,\n\t\t\t\t\tbuffer.begin(),\n\t\t\t\t\t&bufferSize);\n\t\t\t}\n\t\t\tif (rc)\n\t\t\t{\n\t\t\t\tPCERT_ALT_NAME_INFO pNameInfo = reinterpret_cast<PCERT_ALT_NAME_INFO>(buffer.begin());\n\t\t\t\tfor (int i = 0; i < pNameInfo->cAltEntry; i++)\n\t\t\t\t{\n\t\t\t\t\t// Some certificates have Subject Alternative Name entries that are not DNS Name. Skip them.\n\t\t\t\t\tif (pNameInfo->rgAltEntry[i].dwAltNameChoice == CERT_ALT_NAME_DNS_NAME)\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::wstring waltName(pNameInfo->rgAltEntry[i].pwszDNSName);\n\t\t\t\t\t\tstd::string altName;\n\t\t\t\t\t\tPoco::UnicodeConverter::toUTF8(waltName, altName);\n\t\t\t\t\t\tdomainNames.insert(altName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!cmnName.empty() && domainNames.empty())\n\t{\n\t\tdomainNames.insert(cmnName);\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "Poco::DateTime X509Certificate::validFrom() const\n{\n\tPoco::Timestamp ts = Poco::Timestamp::fromFileTimeNP(_pCert->pCertInfo->NotBefore.dwLowDateTime, _pCert->pCertInfo->NotBefore.dwHighDateTime);\n\treturn Poco::DateTime(ts);\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "Poco::DateTime X509Certificate::expiresOn() const\n{\n\tPoco::Timestamp ts = Poco::Timestamp::fromFileTimeNP(_pCert->pCertInfo->NotAfter.dwLowDateTime, _pCert->pCertInfo->NotAfter.dwHighDateTime);\n\treturn Poco::DateTime(ts);\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "bool X509Certificate::issuedBy(const X509Certificate& issuerCertificate) const\n{\n\tCERT_CHAIN_PARA chainPara;\n\tPCCERT_CHAIN_CONTEXT pChainContext = 0;\n\tstd::memset(&chainPara, 0, sizeof(chainPara));\n\tchainPara.cbSize = sizeof(chainPara);\n\n\tif (!CertGetCertificateChain(\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t_pCert,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&chainPara,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&pChainContext))\n\t{\n\t\tthrow SSLException(\"Cannot get certificate chain\", subjectName(), GetLastError());\n\t}\n\n\tbool result = false;\n\tfor (DWORD i = 0; i < pChainContext->cChain && !result; i++)\n\t{\n\t\tfor (DWORD k = 0; k < pChainContext->rgpChain[i]->cElement && !result; k++)\n\t\t{\n\t\t\tPCCERT_CONTEXT pChainCert = pChainContext->rgpChain[i]->rgpElement[k]->pCertContext;\n\t\t\tif (CertCompareCertificate(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, issuerCertificate.system()->pCertInfo, pChainCert->pCertInfo))\n\t\t\t{\n\t\t\t\tif (CertComparePublicKeyInfo(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, &issuerCertificate.system()->pCertInfo->SubjectPublicKeyInfo, &pChainCert->pCertInfo->SubjectPublicKeyInfo))\n\t\t\t\t{\n\t\t\t\t\tresult = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tCertFreeCertificateChain(pChainContext);\n\treturn result;\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "void* X509Certificate::nid2oid(NID nid)\n{\n\tconst char* result = 0;\n\tswitch (nid)\n\t{\n\tcase NID_COMMON_NAME:\n\t\tresult = szOID_COMMON_NAME;\n\t\tbreak;\n\tcase NID_COUNTRY:\n\t\tresult = szOID_COUNTRY_NAME;\n\t\tbreak;\n\tcase NID_LOCALITY_NAME:\n\t\tresult = szOID_LOCALITY_NAME;\n\t\tbreak;\n\tcase NID_STATE_OR_PROVINCE:\n\t\tresult = szOID_STATE_OR_PROVINCE_NAME;\n\t\tbreak;\n\tcase NID_ORGANIZATION_NAME:\n\t\tresult = szOID_ORGANIZATION_NAME;\n\t\tbreak;\n\tcase NID_ORGANIZATION_UNIT_NAME:\n\t\tresult = szOID_ORGANIZATIONAL_UNIT_NAME;\n\t\tbreak;\n\tdefault:\n\t\tpoco_bugcheck();\n\t\tresult = \"\";\n\t\tbreak;\n\t}\n\treturn const_cast<char*>(result);\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "void X509Certificate::loadCertificate(const std::string& certName, const std::string& certStoreName, bool useMachineStore)\n{\n\tstd::wstring wcertStoreName;\n\tPoco::UnicodeConverter::convert(certStoreName, wcertStoreName);\n\tHCERTSTORE hCertStore;\n\tif (useMachineStore)\n\t\thCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_SYSTEM_STORE_LOCAL_MACHINE, wcertStoreName.c_str());\n\telse\n\t\thCertStore = CertOpenSystemStoreW(0, wcertStoreName.c_str());\n\n\tif (!hCertStore) throw CertificateException(\"Failed to open certificate store\", certStoreName, GetLastError());\n\n\tCERT_RDN_ATTR cert_rdn_attr;\n\tcert_rdn_attr.pszObjId = szOID_COMMON_NAME;\n\tcert_rdn_attr.dwValueType = CERT_RDN_ANY_TYPE;\n\tcert_rdn_attr.Value.cbData = static_cast<DWORD>(certName.size());\n\tcert_rdn_attr.Value.pbData = reinterpret_cast<BYTE*>(const_cast<char*>(certName.c_str()));\n\n\tCERT_RDN cert_rdn;\n\tcert_rdn.cRDNAttr = 1;\n\tcert_rdn.rgRDNAttr = &cert_rdn_attr;\n\n\t_pCert = CertFindCertificateInStore(hCertStore, X509_ASN_ENCODING, 0, CERT_FIND_SUBJECT_ATTR, &cert_rdn, NULL);\n\tif (!_pCert)\n\t{\n\t\tCertCloseStore(hCertStore, 0);\n\t\tthrow NoCertificateException(Poco::format(\"Failed to find certificate %s in store %s\", certName, certStoreName));\n\t}\n\tCertCloseStore(hCertStore, 0);\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "void X509Certificate::importCertificate(const std::string& certPath)\n{\n\tPoco::File certFile(certPath);\n\tif (!certFile.exists()) throw Poco::FileNotFoundException(certPath);\n\tPoco::File::FileSize size = certFile.getSize();\n\tif (size < 32) throw Poco::DataFormatException(\"certificate file too small\", certPath);\n\tPoco::Buffer<char> buffer(static_cast<std::size_t>(size));\n\tPoco::FileInputStream istr(certPath);\n\tistr.read(buffer.begin(), buffer.size());\n\tif (istr.gcount() != size) throw Poco::IOException(\"error reading certificate file\");\n\timportCertificate(buffer.begin(), buffer.size());\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "void X509Certificate::importCertificate(std::istream& istr)\n{\n\tstd::string data;\n\tPoco::StreamCopier::copyToString(istr, data);\n\tif (!data.empty())\n\t{\n\t\timportCertificate(data.data(), data.size());\n\t}\n\telse throw Poco::IOException(\"failed to read certificate from stream\");\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "void X509Certificate::importCertificate(const char* pBuffer, std::size_t size)\n{\n\tif (std::memcmp(pBuffer, \"-----BEGIN CERTIFICATE-----\", 27) == 0)\n\t\timportPEMCertificate(pBuffer + 27, size - 27);\n\telse\n\t\timportDERCertificate(pBuffer, size);\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "void X509Certificate::importPEMCertificate(const char* pBuffer, std::size_t size)\n{\n\tPoco::Buffer<char> derBuffer(size);\n\tstd::size_t derSize = 0;\n\n\tconst char* pemBegin = pBuffer;\n\tconst char* pemEnd = pemBegin + (size - 25);\n\twhile (pemEnd > pemBegin && std::memcmp(pemEnd, \"-----END CERTIFICATE-----\", 25) != 0) --pemEnd;\n\tif (pemEnd == pemBegin) throw Poco::DataFormatException(\"Not a valid PEM file - end marker missing\");\n\n\tPoco::MemoryInputStream istr(pemBegin, pemEnd - pemBegin);\n\tPoco::Base64Decoder dec(istr);\n\n\tchar* derBegin = derBuffer.begin();\n\tchar* derEnd = derBegin;\n\n\tint ch = dec.get();\n\twhile (ch != -1)\n\t{\n\t\t*derEnd++ = static_cast<char>(ch);\n\t\tch = dec.get();\n\t}\n\n\timportDERCertificate(derBegin, derEnd - derBegin);\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "void X509Certificate::importDERCertificate(const char* pBuffer, std::size_t size)\n{\n\t_pCert = CertCreateCertificateContext(X509_ASN_ENCODING, reinterpret_cast<const BYTE*>(pBuffer), static_cast<DWORD>(size));\n\tif (!_pCert)\n\t{\n\t\tthrow Poco::DataFormatException(\"Failed to load certificate from file\", GetLastError());\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "bool X509Certificate::verify(const std::string& hostName) const\n{\n\treturn verify(*this, hostName);\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "bool X509Certificate::verify(const Poco::Net::X509Certificate& certificate, const std::string& hostName)\n{\n\tstd::string commonName;\n\tstd::set<std::string> dnsNames;\n\tcertificate.extractNames(commonName, dnsNames);\n\tif (!commonName.empty()) dnsNames.insert(commonName);\n\tbool ok = (dnsNames.find(hostName) != dnsNames.end());\n\tif (!ok)\n\t{\n\t\tfor (std::set<std::string>::const_iterator it = dnsNames.begin(); !ok && it != dnsNames.end(); ++it)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// two cases: strData contains wildcards or not\n\t\t\t\tif (containsWildcards(*it))\n\t\t\t\t{\n\t\t\t\t\t// a compare by IPAddress is not possible with wildcards\n\t\t\t\t\t// only allow compare by name\n\t\t\t\t\tok = matchWildcard(*it, hostName);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// it depends on hostName if we compare by IP or by alias\n\t\t\t\t\tIPAddress ip;\n\t\t\t\t\tif (IPAddress::tryParse(hostName, ip))\n\t\t\t\t\t{\n\t\t\t\t\t\t// compare by IP\n\t\t\t\t\t\tconst HostEntry& heData = DNS::resolve(*it);\n\t\t\t\t\t\tconst HostEntry::AddressList& addr = heData.addresses();\n\t\t\t\t\t\tHostEntry::AddressList::const_iterator it = addr.begin();\n\t\t\t\t\t\tHostEntry::AddressList::const_iterator itEnd = addr.end();\n\t\t\t\t\t\tfor (; it != itEnd && !ok; ++it)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok = (*it == ip);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tok = Poco::icompare(*it, hostName) == 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoAddressFoundException&)\n\t\t\t{\n\t\t\t}\n\t\t\tcatch (HostNotFoundException&)\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}\n\treturn ok;\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "bool X509Certificate::containsWildcards(const std::string& commonName)\n{\n\treturn (commonName.find('*') != std::string::npos || commonName.find('?') != std::string::npos);\n}\n", "label": "network"}
{"project": "poco", "file": "X509Certificate.cpp", "func": "bool X509Certificate::matchWildcard(const std::string& wildcard, const std::string& hostName)\n{\n\t// fix wildcards\n\tstd::string wildcardExpr(\"^\");\n\twildcardExpr += Poco::replace(wildcard, \".\", \"\\\\.\");\n\tPoco::replaceInPlace(wildcardExpr, \"*\", \".*\");\n\tPoco::replaceInPlace(wildcardExpr, \"..*\", \".*\");\n\tPoco::replaceInPlace(wildcardExpr, \"?\", \".?\");\n\tPoco::replaceInPlace(wildcardExpr, \"..?\", \".?\");\n\twildcardExpr += \"$\";\n\n\tPoco::RegularExpression expr(wildcardExpr, Poco::RegularExpression::RE_CASELESS);\n\treturn expr.match(hostName);\n}\n", "label": "network"}
{"project": "poco", "file": "Driver.cpp", "func": "\tint main(const std::vector<std::string>& args)\n\t{\n\t\tCppUnit::TestRunner runner;\n\t\trunner.addTest(\"NetSSLTestSuite\", NetSSLTestSuite::suite());\n\t\treturn runner.run(_targs) ? 0 : 1;\n\t}\n", "label": "network"}
{"project": "poco", "file": "Driver.cpp", "func": "\tvoid setup(int argc, char** argv)\n\t{\n\t\tinit(1, argv);\n\t\tfor (int i = 0; i < argc; ++i)\n\t\t\t_targs.push_back(std::string(argv[i]));\n\t}\n", "label": "network"}
{"project": "poco", "file": "Driver.cpp", "func": "\tvoid initialize(Poco::Util::Application& self)\n\t{\n\t\tloadConfiguration(); // load default configuration files, if present\n\t\tPoco::Util::Application::initialize(self);\n\t}\n", "label": "network"}
{"project": "poco", "file": "Driver.cpp", "func": "int main(int ac, char **av)\n{\n\tNetSSLApp app;\n\ttry\n\t{\n\t\tapp.setup(ac, av);\n\t\treturn app.run();\n\t}\n\tcatch (Poco::Exception& exc)\n\t{\n\t\tstd::cout << exc.displayText() << std::endl;\n\t\treturn 1;\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "\tvoid handleRequest(HTTPServerRequest& request, HTTPServerResponse& response)\n\t{\n\t\tresponse.setChunkedTransferEncoding(true);\n\t\tresponse.setContentType(request.getContentType());\n\t\tstd::ostream& ostr = response.send();\n\t\tPoco::StreamCopier::copyStream(request.stream(), ostr);\n\t}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "\tHTTPRequestHandler* createRequestHandler(const HTTPServerRequest& request)\n\t{\n\t\treturn new TestRequestHandler();\n\t}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::testGetSmall()\n{\n\tHTTPSTestServer srv;\n\tHTTPSClientSession s(\"127.0.0.1\", srv.port());\n\tHTTPRequest request(HTTPRequest::HTTP_GET, \"/small\");\n\ts.sendRequest(request);\n\tHTTPResponse response;\n\tstd::istream& rs = s.receiveResponse(response);\n\tassertTrue (response.getContentLength() == HTTPSTestServer::SMALL_BODY.length());\n\tassertTrue (response.getContentType() == \"text/plain\");\n\tstd::ostringstream ostr;\n\tStreamCopier::copyStream(rs, ostr);\n\tassertTrue (ostr.str() == HTTPSTestServer::SMALL_BODY);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::testGetLarge()\n{\n\tHTTPSTestServer srv;\n\tHTTPSClientSession s(\"127.0.0.1\", srv.port());\n\tHTTPRequest request(HTTPRequest::HTTP_GET, \"/large\");\n\ts.sendRequest(request);\n\tHTTPResponse response;\n\tstd::istream& rs = s.receiveResponse(response);\n\tassertTrue (response.getContentLength() == HTTPSTestServer::LARGE_BODY.length());\n\tassertTrue (response.getContentType() == \"text/plain\");\n\tstd::ostringstream ostr;\n\tStreamCopier::copyStream(rs, ostr);\n\tassertTrue (ostr.str() == HTTPSTestServer::LARGE_BODY);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::testHead()\n{\n\tHTTPSTestServer srv;\n\tHTTPSClientSession s(\"127.0.0.1\", srv.port());\n\tHTTPRequest request(HTTPRequest::HTTP_HEAD, \"/large\");\n\ts.sendRequest(request);\n\tHTTPResponse response;\n\tstd::istream& rs = s.receiveResponse(response);\n\tassertTrue (response.getContentLength() == HTTPSTestServer::LARGE_BODY.length());\n\tassertTrue (response.getContentType() == \"text/plain\");\n\tstd::ostringstream ostr;\n\tassertTrue (StreamCopier::copyStream(rs, ostr) == 0);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::testPostSmallIdentity()\n{\n\tHTTPSTestServer srv;\n\tHTTPSClientSession s(\"127.0.0.1\", srv.port());\n\tHTTPRequest request(HTTPRequest::HTTP_POST, \"/echo\");\n\tstd::string body(\"this is a random request body\\r\\n0\\r\\n\");\n\trequest.setContentLength((int) body.length());\n\ts.sendRequest(request) << body;\n\tHTTPResponse response;\n\tstd::istream& rs = s.receiveResponse(response);\n\tassertTrue (response.getContentLength() == body.length());\n\tstd::ostringstream ostr;\n\tStreamCopier::copyStream(rs, ostr);\n\tassertTrue (ostr.str() == body);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::testPostLargeIdentity()\n{\n\tHTTPSTestServer srv;\n\tHTTPSClientSession s(\"127.0.0.1\", srv.port());\n\tHTTPRequest request(HTTPRequest::HTTP_POST, \"/echo\");\n\tstd::string body(8000, 'x');\n\tbody.append(\"\\r\\n0\\r\\n\");\n\trequest.setContentLength((int) body.length());\n\ts.sendRequest(request) << body;\n\tHTTPResponse response;\n\tstd::istream& rs = s.receiveResponse(response);\n\tassertTrue (response.getContentLength() == body.length());\n\tstd::ostringstream ostr;\n\tStreamCopier::copyStream(rs, ostr);\n\tassertTrue (ostr.str() == body);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::testPostSmallChunked()\n{\n\tHTTPSTestServer srv;\n\tHTTPSClientSession s(\"127.0.0.1\", srv.port());\n\tHTTPRequest request(HTTPRequest::HTTP_POST, \"/echo\");\n\tstd::string body(\"this is a random request body\");\n\trequest.setChunkedTransferEncoding(true);\n\ts.sendRequest(request) << body;\n\tHTTPResponse response;\n\tstd::istream& rs = s.receiveResponse(response);\n\tassertTrue (response.getChunkedTransferEncoding());\n\tassertTrue (response.getContentLength() == HTTPMessage::UNKNOWN_CONTENT_LENGTH);\n\tstd::ostringstream ostr;\n\tStreamCopier::copyStream(rs, ostr);\n\tassertTrue (ostr.str() == body);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::testPostLargeChunked()\n{\n\tHTTPSTestServer srv;\n\tHTTPSClientSession s(\"127.0.0.1\", srv.port());\n\tHTTPRequest request(HTTPRequest::HTTP_POST, \"/echo\");\n\tstd::string body(16000, 'x');\n\trequest.setChunkedTransferEncoding(true);\n\ts.sendRequest(request) << body;\n\tHTTPResponse response;\n\tstd::istream& rs = s.receiveResponse(response);\n\tassertTrue (response.getChunkedTransferEncoding());\n\tassertTrue (response.getContentLength() == HTTPMessage::UNKNOWN_CONTENT_LENGTH);\n\tstd::ostringstream ostr;\n\tStreamCopier::copyStream(rs, ostr);\n\tassertTrue (ostr.str() == body);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::testPostLargeChunkedKeepAlive()\n{\n\tSecureServerSocket svs(32322);\n\tHTTPServer srv(new TestRequestHandlerFactory(), svs, new HTTPServerParams());\n\tsrv.start();\n\ttry\n\t{\n\t\tHTTPSClientSession s(\"127.0.0.1\", srv.port());\n\t\ts.setKeepAlive(true);\n\t\tfor (int i = 0; i < 10; ++i)\n\t\t{\n\t\t\tHTTPRequest request(HTTPRequest::HTTP_POST, \"/keepAlive\", HTTPMessage::HTTP_1_1);\n\t\t\tstd::string body(16000, 'x');\n\t\t\trequest.setChunkedTransferEncoding(true);\n\t\t\ts.sendRequest(request) << body;\n\t\t\tHTTPResponse response;\n\t\t\tstd::istream& rs = s.receiveResponse(response);\n\t\t\tassertTrue (response.getChunkedTransferEncoding());\n\t\t\tassertTrue (response.getContentLength() == HTTPMessage::UNKNOWN_CONTENT_LENGTH);\n\t\t\tstd::ostringstream ostr;\n\t\t\tStreamCopier::copyStream(rs, ostr);\n\t\t\tassertTrue (ostr.str() == body);\n\t\t}\n\t\tsrv.stop();\n\t}\n\tcatch (...)\n\t{\n\t\tsrv.stop();\n\t\tthrow;\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::testKeepAlive()\n{\n\tHTTPSTestServer srv;\n\tHTTPSClientSession s(\"127.0.0.1\", srv.port());\n\ts.setKeepAlive(true);\n\tHTTPRequest request(HTTPRequest::HTTP_HEAD, \"/keepAlive\", HTTPMessage::HTTP_1_1);\n\ts.sendRequest(request);\n\tHTTPResponse response;\n\tstd::istream& rs1 = s.receiveResponse(response);\n\tassertTrue (response.getContentLength() == HTTPSTestServer::SMALL_BODY.length());\n\tassertTrue (response.getContentType() == \"text/plain\");\n\tassertTrue (response.getKeepAlive());\n\tstd::ostringstream ostr1;\n\tassertTrue (StreamCopier::copyStream(rs1, ostr1) == 0);\n\t\n\trequest.setMethod(HTTPRequest::HTTP_GET);\n\trequest.setURI(\"/small\");\n\ts.sendRequest(request);\n\tstd::istream& rs2 = s.receiveResponse(response);\n\tassertTrue (response.getContentLength() == HTTPSTestServer::SMALL_BODY.length());\n\tassertTrue (response.getKeepAlive());\n\tstd::ostringstream ostr2;\n\tStreamCopier::copyStream(rs2, ostr2);\n\tassertTrue (ostr2.str() == HTTPSTestServer::SMALL_BODY);\n\t\n\trequest.setMethod(HTTPRequest::HTTP_GET);\n\trequest.setURI(\"/large\");\n\ts.sendRequest(request);\n\tstd::istream& rs3 = s.receiveResponse(response);\n\tassertTrue (response.getContentLength() == HTTPMessage::UNKNOWN_CONTENT_LENGTH);\n\tassertTrue (response.getChunkedTransferEncoding());\n\tassertTrue (response.getKeepAlive());\n\tstd::ostringstream ostr3;\n\tStreamCopier::copyStream(rs3, ostr3);\n\tassertTrue (ostr3.str() == HTTPSTestServer::LARGE_BODY);\n\n\trequest.setMethod(HTTPRequest::HTTP_HEAD);\n\trequest.setURI(\"/large\");\n\ts.sendRequest(request);\n\tstd::istream& rs4 = s.receiveResponse(response);\n\tassertTrue (response.getContentLength() == HTTPSTestServer::LARGE_BODY.length());\n\tassertTrue (response.getContentType() == \"text/plain\");\n\tassertTrue (!response.getKeepAlive());\n\tstd::ostringstream ostr4;\n\tassertTrue (StreamCopier::copyStream(rs4, ostr4) == 0);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::testInterop()\n{\n\tHTTPSClientSession s(\"secure.appinf.com\");\n\tHTTPRequest request(HTTPRequest::HTTP_GET, \"/public/poco/NetSSL.txt\");\n\ts.sendRequest(request);\n\tPoco::Net::X509Certificate cert = s.serverCertificate();\n\n\tHTTPResponse response;\n\tstd::istream& rs = s.receiveResponse(response);\n\tstd::ostringstream ostr;\n\tStreamCopier::copyStream(rs, ostr);\n\tstd::string str(ostr.str());\n\tassertTrue (str == \"This is a test file for NetSSL.\\n\");\n\n\tstd::string commonName;\n\tstd::set<std::string> domainNames;\n\tcert.extractNames(commonName, domainNames);\n\n\tassertTrue (commonName == \"secure.appinf.com\" || commonName == \"*.appinf.com\");\n\tassertTrue (domainNames.find(\"appinf.com\") != domainNames.end() \n\t\t || domainNames.find(\"*.appinf.com\") != domainNames.end());\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::testProxy()\n{\n\tHTTPSTestServer srv;\n\tHTTPSClientSession s(\"secure.appinf.com\");\n\ts.setProxy(\n\t\tApplication::instance().config().getString(\"testsuite.proxy.host\"), \n\t\tApplication::instance().config().getInt(\"testsuite.proxy.port\")\n\t);\n\tHTTPRequest request(HTTPRequest::HTTP_GET, \"/public/poco/NetSSL.txt\");\n\ts.sendRequest(request);\n\tPoco::Net::X509Certificate cert = s.serverCertificate();\n\tHTTPResponse response;\n\tstd::istream& rs = s.receiveResponse(response);\n\tstd::ostringstream ostr;\n\tStreamCopier::copyStream(rs, ostr);\n\tstd::string str(ostr.str());\n\tassertTrue (str == \"This is a test file for NetSSL.\\n\");\n\tassertTrue (cert.commonName() == \"secure.appinf.com\" || cert.commonName() == \"*.appinf.com\");\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::testCachedSession()\n{\n\t// ensure OpenSSL machinery is fully setup\n\tContext::Ptr pDefaultServerContext = SSLManager::instance().defaultServerContext();\n\tContext::Ptr pDefaultClientContext = SSLManager::instance().defaultClientContext();\n\t\n\tContext::Ptr pServerContext = new Context(\n\t\tContext::SERVER_USE,\n\t\t\"\");\t\n\t//pServerContext->enableSessionCache(true, \"TestSuite\");\n\t//pServerContext->setSessionTimeout(10);\n\t//pServerContext->setSessionCacheSize(1000);\n\t//pServerContext->disableStatelessSessionResumption();\n\n\tHTTPSTestServer srv(pServerContext);\n\n\tContext::Ptr pClientContext = new Context(\n\t\tContext::CLIENT_USE, \n\t\t\"\");\n\t//pClientContext->enableSessionCache(true);\n\n\tHTTPSClientSession s1(\"127.0.0.1\", srv.port(), pClientContext);\n\tHTTPRequest request1(HTTPRequest::HTTP_GET, \"/small\");\n\ts1.sendRequest(request1);\n\tSession::Ptr pSession1 = s1.sslSession();\n\tHTTPResponse response1;\n\tstd::istream& rs1 = s1.receiveResponse(response1);\n\tassertTrue (response1.getContentLength() == HTTPSTestServer::SMALL_BODY.length());\n\tassertTrue (response1.getContentType() == \"text/plain\");\n\tstd::ostringstream ostr1;\n\tStreamCopier::copyStream(rs1, ostr1);\n\tassertTrue (ostr1.str() == HTTPSTestServer::SMALL_BODY);\n\n\tHTTPSClientSession s2(\"127.0.0.1\", srv.port(), pClientContext, pSession1);\n\tHTTPRequest request2(HTTPRequest::HTTP_GET, \"/small\");\n\ts2.sendRequest(request2);\n\tSession::Ptr pSession2 = s2.sslSession();\n\tHTTPResponse response2;\n\tstd::istream& rs2 = s2.receiveResponse(response2);\n\tassertTrue (response2.getContentLength() == HTTPSTestServer::SMALL_BODY.length());\n\tassertTrue (response2.getContentType() == \"text/plain\");\n\tstd::ostringstream ostr2;\n\tStreamCopier::copyStream(rs2, ostr2);\n\tassertTrue (ostr2.str() == HTTPSTestServer::SMALL_BODY);\n\t\n\tassertTrue (pSession1 == pSession2);\n\n\tHTTPRequest request3(HTTPRequest::HTTP_GET, \"/small\");\n\ts2.sendRequest(request3);\n\tSession::Ptr pSession3 = s2.sslSession();\n\tHTTPResponse response3;\n\tstd::istream& rs3 = s2.receiveResponse(response3);\n\tassertTrue (response3.getContentLength() == HTTPSTestServer::SMALL_BODY.length());\n\tassertTrue (response3.getContentType() == \"text/plain\");\n\tstd::ostringstream ostr3;\n\tStreamCopier::copyStream(rs3, ostr3);\n\tassertTrue (ostr3.str() == HTTPSTestServer::SMALL_BODY);\n\n\tassertTrue (pSession1 == pSession3);\n\n\tThread::sleep(15000); // wait for session to expire\n\t//pServerContext->flushSessionCache();\n\t\n\tHTTPRequest request4(HTTPRequest::HTTP_GET, \"/small\");\n\ts2.sendRequest(request4);\n\tSession::Ptr pSession4 = s2.sslSession();\n\tHTTPResponse response4;\n\tstd::istream& rs4 = s2.receiveResponse(response4);\n\tassertTrue (response4.getContentLength() == HTTPSTestServer::SMALL_BODY.length());\n\tassertTrue (response4.getContentType() == \"text/plain\");\n\tstd::ostringstream ostr4;\n\tStreamCopier::copyStream(rs4, ostr4);\n\tassertTrue (ostr4.str() == HTTPSTestServer::SMALL_BODY);\n\n\tassertTrue (pSession1 != pSession4);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::setUp()\n{\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "void HTTPSClientSessionTest::tearDown()\n{\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientSessionTest.cpp", "func": "CppUnit::Test* HTTPSClientSessionTest::suite()\n{\n\tCppUnit::TestSuite* pSuite = new CppUnit::TestSuite(\"HTTPSClientSessionTest\");\n\n\tCppUnit_addTest(pSuite, HTTPSClientSessionTest, testGetSmall);\n\tCppUnit_addTest(pSuite, HTTPSClientSessionTest, testGetLarge);\n\tCppUnit_addTest(pSuite, HTTPSClientSessionTest, testHead);\n\tCppUnit_addTest(pSuite, HTTPSClientSessionTest, testPostSmallIdentity);\n\tCppUnit_addTest(pSuite, HTTPSClientSessionTest, testPostLargeIdentity);\n\tCppUnit_addTest(pSuite, HTTPSClientSessionTest, testPostSmallChunked);\n\tCppUnit_addTest(pSuite, HTTPSClientSessionTest, testPostLargeChunked);\n\tCppUnit_addTest(pSuite, HTTPSClientSessionTest, testPostLargeChunkedKeepAlive);\n\tCppUnit_addTest(pSuite, HTTPSClientSessionTest, testKeepAlive);\n\tCppUnit_addTest(pSuite, HTTPSClientSessionTest, testInterop);\n\tCppUnit_addTest(pSuite, HTTPSClientSessionTest, testProxy);\n\t//CppUnit_addTest(pSuite, HTTPSClientSessionTest, testCachedSession);\n\n\treturn pSuite;\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSClientTestSuite.cpp", "func": "CppUnit::Test* HTTPSClientTestSuite::suite()\n{\n\tCppUnit::TestSuite* pSuite = new CppUnit::TestSuite(\"HTTPSClientTestSuite\");\n\n\tpSuite->addTest(HTTPSClientSessionTest::suite());\n\tpSuite->addTest(HTTPSStreamFactoryTest::suite());\n\n\treturn pSuite;\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "\t\tvoid handleRequest(HTTPServerRequest& request, HTTPServerResponse& response)\n\t\t{\n\t\t\tif (request.getChunkedTransferEncoding())\n\t\t\t\tresponse.setChunkedTransferEncoding(true);\n\t\t\telse if (request.getContentLength() != HTTPMessage::UNKNOWN_CONTENT_LENGTH)\n\t\t\t\tresponse.setContentLength(request.getContentLength());\n\t\t\t\n\t\t\tresponse.setContentType(request.getContentType());\n\t\t\t\n\t\t\tstd::istream& istr = request.stream();\n\t\t\tstd::ostream& ostr = response.send();\n\t\t\tStreamCopier::copyStream(istr, ostr);\n\t\t}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "\t\tvoid handleRequest(HTTPServerRequest& request, HTTPServerResponse& response)\n\t\t{\n\t\t\tstd::ostringstream osstr;\n\t\t\trequest.write(osstr);\n\t\t\tint n = (int) osstr.str().length();\n\t\t\tresponse.setContentLength(n);\n\t\t\tstd::ostream& ostr = response.send();\n\t\t\tif (request.getMethod() != HTTPRequest::HTTP_HEAD)\n\t\t\t\trequest.write(ostr);\n\t\t}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "\t\tvoid handleRequest(HTTPServerRequest& request, HTTPServerResponse& response)\n\t\t{\n\t\t\tresponse.redirect(\"http://www.appinf.com/\");\n\t\t}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "\t\tvoid handleRequest(HTTPServerRequest& request, HTTPServerResponse& response)\n\t\t{\n\t\t\tresponse.requireAuthentication(\"/auth\");\n\t\t\tresponse.send();\n\t\t}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "\t\tHTTPRequestHandler* createRequestHandler(const HTTPServerRequest& request)\n\t\t{\n\t\t\tif (request.getURI() == \"/echoBody\")\n\t\t\t\treturn new EchoBodyRequestHandler;\n\t\t\telse if (request.getURI() == \"/echoHeader\")\n\t\t\t\treturn new EchoHeaderRequestHandler;\n\t\t\telse if (request.getURI() == \"/redirect\")\n\t\t\t\treturn new RedirectRequestHandler();\n\t\t\telse if (request.getURI() == \"/auth\")\n\t\t\t\treturn new AuthRequestHandler();\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "void HTTPSServerTest::testIdentityRequest()\n{\n\tSecureServerSocket svs(0);\n\tHTTPServerParams* pParams = new HTTPServerParams;\n\tpParams->setKeepAlive(false);\n\tHTTPServer srv(new RequestHandlerFactory, svs, pParams);\n\tsrv.start();\n\t\n\tHTTPSClientSession cs(\"127.0.0.1\", svs.address().port());\n\tstd::string body(5000, 'x');\n\tHTTPRequest request(\"POST\", \"/echoBody\");\n\trequest.setContentLength((int) body.length());\n\trequest.setContentType(\"text/plain\");\n\tcs.sendRequest(request) << body;\n\tHTTPResponse response;\n\tstd::string rbody;\n\tcs.receiveResponse(response) >> rbody;\n\tassertTrue (response.getContentLength() == body.size());\n\tassertTrue (response.getContentType() == \"text/plain\");\n\tassertTrue (rbody == body);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "void HTTPSServerTest::testChunkedRequest()\n{\n\tSecureServerSocket svs(0);\n\tHTTPServerParams* pParams = new HTTPServerParams;\n\tpParams->setKeepAlive(false);\n\tHTTPServer srv(new RequestHandlerFactory, svs, pParams);\n\tsrv.start();\n\t\n\tHTTPSClientSession cs(\"127.0.0.1\", svs.address().port());\n\tstd::string body(5000, 'x');\n\tHTTPRequest request(\"POST\", \"/echoBody\");\n\trequest.setContentType(\"text/plain\");\n\trequest.setChunkedTransferEncoding(true);\n\tcs.sendRequest(request) << body;\n\tHTTPResponse response;\n\tstd::string rbody;\n\tcs.receiveResponse(response) >> rbody;\n\tassertTrue (response.getContentLength() == HTTPMessage::UNKNOWN_CONTENT_LENGTH);\n\tassertTrue (response.getContentType() == \"text/plain\");\n\tassertTrue (response.getChunkedTransferEncoding());\n\tassertTrue (rbody == body);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "void HTTPSServerTest::testIdentityRequestKeepAlive()\n{\n\tSecureServerSocket svs(0);\n\tHTTPServerParams* pParams = new HTTPServerParams;\n\tpParams->setKeepAlive(true);\n\tHTTPServer srv(new RequestHandlerFactory, svs, pParams);\n\tsrv.start();\n\t\n\tHTTPSClientSession cs(\"127.0.0.1\", svs.address().port());\n\tcs.setKeepAlive(true);\n\tstd::string body(5000, 'x');\n\tHTTPRequest request(\"POST\", \"/echoBody\", HTTPMessage::HTTP_1_1);\n\trequest.setContentLength((int) body.length());\n\trequest.setContentType(\"text/plain\");\n\tcs.sendRequest(request) << body;\n\tHTTPResponse response;\n\tstd::string rbody;\n\tcs.receiveResponse(response) >> rbody;\n\tassertTrue (response.getContentLength() == body.size());\n\tassertTrue (response.getContentType() == \"text/plain\");\n\tassertTrue (response.getKeepAlive());\n\tassertTrue (rbody == body);\n\t\n\tbody.assign(1000, 'y');\n\trequest.setContentLength((int) body.length());\n\trequest.setKeepAlive(false);\n\tcs.sendRequest(request) << body;\n\tcs.receiveResponse(response) >> rbody;\n\tassertTrue (response.getContentLength() == body.size());\n\tassertTrue (response.getContentType() == \"text/plain\");\n\tassertTrue (!response.getKeepAlive());\n\tassertTrue (rbody == body);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "void HTTPSServerTest::testChunkedRequestKeepAlive()\n{\n\tSecureServerSocket svs(0);\n\tHTTPServerParams* pParams = new HTTPServerParams;\n\tpParams->setKeepAlive(true);\n\tHTTPServer srv(new RequestHandlerFactory, svs, pParams);\n\tsrv.start();\n\t\n\tHTTPSClientSession cs(\"127.0.0.1\", svs.address().port());\n\tcs.setKeepAlive(true);\n\tstd::string body(5000, 'x');\n\tHTTPRequest request(\"POST\", \"/echoBody\", HTTPMessage::HTTP_1_1);\n\trequest.setContentType(\"text/plain\");\n\trequest.setChunkedTransferEncoding(true);\n\tcs.sendRequest(request) << body;\n\tHTTPResponse response;\n\tstd::string rbody;\n\tcs.receiveResponse(response) >> rbody;\n\tassertTrue (response.getContentLength() == HTTPMessage::UNKNOWN_CONTENT_LENGTH);\n\tassertTrue (response.getContentType() == \"text/plain\");\n\tassertTrue (response.getChunkedTransferEncoding());\n\tassertTrue (rbody == body);\n\n\tbody.assign(1000, 'y');\n\trequest.setKeepAlive(false);\n\tcs.sendRequest(request) << body;\n\tcs.receiveResponse(response) >> rbody;\n\tassertTrue (response.getContentLength() == HTTPMessage::UNKNOWN_CONTENT_LENGTH);\n\tassertTrue (response.getContentType() == \"text/plain\");\n\tassertTrue (response.getChunkedTransferEncoding());\n\tassertTrue (!response.getKeepAlive());\n\tassertTrue (rbody == body);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "void HTTPSServerTest::test100Continue()\n{\n\tSecureServerSocket svs(0);\n\tHTTPServerParams* pParams = new HTTPServerParams;\n\tpParams->setKeepAlive(false);\n\tHTTPServer srv(new RequestHandlerFactory, svs, pParams);\n\tsrv.start();\n\t\n\tHTTPSClientSession cs(\"127.0.0.1\", svs.address().port());\n\tstd::string body(5000, 'x');\n\tHTTPRequest request(\"POST\", \"/echoBody\");\n\trequest.setContentLength((int) body.length());\n\trequest.setContentType(\"text/plain\");\n\trequest.set(\"Expect\", \"100-Continue\");\n\tcs.sendRequest(request) << body;\n\tHTTPResponse response;\n\tstd::string rbody;\n\tcs.receiveResponse(response) >> rbody;\n\tassertTrue (response.getContentLength() == body.size());\n\tassertTrue (response.getContentType() == \"text/plain\");\n\tassertTrue (rbody == body);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "void HTTPSServerTest::testRedirect()\n{\n\tSecureServerSocket svs(0);\n\tHTTPServerParams* pParams = new HTTPServerParams;\n\tpParams->setKeepAlive(false);\n\tHTTPServer srv(new RequestHandlerFactory, svs, pParams);\n\tsrv.start();\n\t\n\tHTTPSClientSession cs(\"127.0.0.1\", svs.address().port());\n\tHTTPRequest request(\"GET\", \"/redirect\");\n\tcs.sendRequest(request);\n\tHTTPResponse response;\n\tstd::string rbody;\n\tcs.receiveResponse(response) >> rbody;\n\tassertTrue (response.getStatus() == HTTPResponse::HTTP_FOUND);\n\tassertTrue (response.get(\"Location\") == \"http://www.appinf.com/\");\n\tassertTrue (rbody.empty());\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "void HTTPSServerTest::testAuth()\n{\n\tSecureServerSocket svs(0);\n\tHTTPServerParams* pParams = new HTTPServerParams;\n\tpParams->setKeepAlive(false);\n\tHTTPServer srv(new RequestHandlerFactory, svs, pParams);\n\tsrv.start();\n\t\n\tHTTPSClientSession cs(\"127.0.0.1\", svs.address().port());\n\tHTTPRequest request(\"GET\", \"/auth\");\n\tcs.sendRequest(request);\n\tHTTPResponse response;\n\tstd::string rbody;\n\tcs.receiveResponse(response) >> rbody;\n\tassertTrue (response.getStatus() == HTTPResponse::HTTP_UNAUTHORIZED);\n\tassertTrue (response.get(\"WWW-Authenticate\") == \"Basic realm=\\\"/auth\\\"\");\n\tassertTrue (rbody.empty());\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "void HTTPSServerTest::testNotImpl()\n{\n\tSecureServerSocket svs(0);\n\tHTTPServerParams* pParams = new HTTPServerParams;\n\tpParams->setKeepAlive(false);\n\tHTTPServer srv(new RequestHandlerFactory, svs, pParams);\n\tsrv.start();\n\t\n\tHTTPSClientSession cs(\"127.0.0.1\", svs.address().port());\n\tHTTPRequest request(\"GET\", \"/notImpl\");\n\tcs.sendRequest(request);\n\tHTTPResponse response;\n\tstd::string rbody;\n\tcs.receiveResponse(response) >> rbody;\n\tassertTrue (response.getStatus() == HTTPResponse::HTTP_NOT_IMPLEMENTED);\n\tassertTrue (rbody.empty());\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "void HTTPSServerTest::setUp()\n{\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "void HTTPSServerTest::tearDown()\n{\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTest.cpp", "func": "CppUnit::Test* HTTPSServerTest::suite()\n{\n\tCppUnit::TestSuite* pSuite = new CppUnit::TestSuite(\"HTTPSServerTest\");\n\n\tCppUnit_addTest(pSuite, HTTPSServerTest, testIdentityRequest);\n\tCppUnit_addTest(pSuite, HTTPSServerTest, testChunkedRequest);\n\tCppUnit_addTest(pSuite, HTTPSServerTest, testIdentityRequestKeepAlive);\n\tCppUnit_addTest(pSuite, HTTPSServerTest, testChunkedRequestKeepAlive);\n\tCppUnit_addTest(pSuite, HTTPSServerTest, test100Continue);\n\tCppUnit_addTest(pSuite, HTTPSServerTest, testRedirect);\n\tCppUnit_addTest(pSuite, HTTPSServerTest, testAuth);\n\tCppUnit_addTest(pSuite, HTTPSServerTest, testNotImpl);\n\n\treturn pSuite;\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSServerTestSuite.cpp", "func": "CppUnit::Test* HTTPSServerTestSuite::suite()\n{\n\tCppUnit::TestSuite* pSuite = new CppUnit::TestSuite(\"HTTPSServerTestSuite\");\n\n\tpSuite->addTest(HTTPSServerTest::suite());\n\n\treturn pSuite;\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSStreamFactoryTest.cpp", "func": "void HTTPSStreamFactoryTest::testNoRedirect()\n{\n\tHTTPSTestServer server;\n\tHTTPSStreamFactory factory;\n\tURI uri(\"https://127.0.0.1/large\");\n\turi.setPort(server.port());\n\tstd::unique_ptr<std::istream> pStr(factory.open(uri));\n\tstd::ostringstream ostr;\n\tStreamCopier::copyStream(*pStr.get(), ostr);\n\tassertTrue (ostr.str() == HTTPSTestServer::LARGE_BODY);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSStreamFactoryTest.cpp", "func": "void HTTPSStreamFactoryTest::testEmptyPath()\n{\n\tHTTPSTestServer server;\n\tHTTPSStreamFactory factory;\n\tURI uri(\"https://127.0.0.1\");\n\turi.setPort(server.port());\n\tstd::unique_ptr<std::istream> pStr(factory.open(uri));\n\tstd::ostringstream ostr;\n\tStreamCopier::copyStream(*pStr.get(), ostr);\n\tassertTrue (ostr.str() == HTTPSTestServer::SMALL_BODY);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSStreamFactoryTest.cpp", "func": "void HTTPSStreamFactoryTest::testRedirect()\n{\n\tHTTPSTestServer server;\n\tHTTPSStreamFactory factory;\n\tURI uri(\"https://127.0.0.1/redirect\");\n\turi.setPort(server.port());\n\tstd::unique_ptr<std::istream> pStr(factory.open(uri));\n\tstd::ostringstream ostr;\n\tStreamCopier::copyStream(*pStr.get(), ostr);\n\tassertTrue (ostr.str() == HTTPSTestServer::LARGE_BODY);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSStreamFactoryTest.cpp", "func": "void HTTPSStreamFactoryTest::testProxy()\n{\n\tHTTPSTestServer server;\n\tHTTPSStreamFactory factory(\n\t\tApplication::instance().config().getString(\"testsuite.proxy.host\"),\n\t\tApplication::instance().config().getInt(\"testsuite.proxy.port\")\n\t);\n\tURI uri(\"https://secure.appinf.com/public/poco/NetSSL.txt\");\n\tstd::unique_ptr<std::istream> pStr(factory.open(uri));\n\tstd::ostringstream ostr;\n\tStreamCopier::copyStream(*pStr.get(), ostr);\n\tassertTrue (ostr.str().length() > 0);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSStreamFactoryTest.cpp", "func": "void HTTPSStreamFactoryTest::testError()\n{\n\tHTTPSTestServer server;\n\tHTTPSStreamFactory factory;\n\tURI uri(\"https://127.0.0.1/notfound\");\n\turi.setPort(server.port());\n\ttry\n\t{\n\t\tstd::istream* pStr = factory.open(uri);\n\t\tfail(\"not found - must throw\");\n\t}\n\tcatch (HTTPException& exc)\n\t{\n\t\tstd::string m = exc.displayText();\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSStreamFactoryTest.cpp", "func": "void HTTPSStreamFactoryTest::setUp()\n{\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSStreamFactoryTest.cpp", "func": "void HTTPSStreamFactoryTest::tearDown()\n{\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSStreamFactoryTest.cpp", "func": "CppUnit::Test* HTTPSStreamFactoryTest::suite()\n{\n\tCppUnit::TestSuite* pSuite = new CppUnit::TestSuite(\"HTTPSStreamFactoryTest\");\n\n\tCppUnit_addTest(pSuite, HTTPSStreamFactoryTest, testNoRedirect);\n\tCppUnit_addTest(pSuite, HTTPSStreamFactoryTest, testEmptyPath);\n\tCppUnit_addTest(pSuite, HTTPSStreamFactoryTest, testRedirect);\n\tCppUnit_addTest(pSuite, HTTPSStreamFactoryTest, testProxy);\n\tCppUnit_addTest(pSuite, HTTPSStreamFactoryTest, testError);\n\n\treturn pSuite;\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSTestServer.cpp", "func": "Poco::UInt16 HTTPSTestServer::port() const\n{\n\treturn _socket.address().port();\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSTestServer.cpp", "func": "const std::string& HTTPSTestServer::lastRequest() const\n{\n\treturn _lastRequest;\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSTestServer.cpp", "func": "void HTTPSTestServer::run()\n{\n\t_ready.set();\n\tPoco::Timespan span(250000);\n\twhile (!_stop)\n\t{\n\t\tif (_socket.poll(span, Socket::SELECT_READ))\n\t\t{\n\t\t\tStreamSocket ss = _socket.acceptConnection();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_lastRequest.clear();\n\t\t\t\tchar buffer[256];\n\t\t\t\tint n = ss.receiveBytes(buffer, sizeof(buffer));\n\t\t\t\twhile (n > 0 && !_stop)\n\t\t\t\t{\n\t\t\t\t\t_lastRequest.append(buffer, n);\n\t\t\t\t\tif (!requestComplete())\n\t\t\t\t\t\tn = ss.receiveBytes(buffer, sizeof(buffer));\n\t\t\t\t\telse\n\t\t\t\t\t\tn = 0;\n\t\t\t\t}\n\t\t\t\tstd::string response = handleRequest();\n\t\t\t\tss.sendBytes(response.data(), (int) response.size());\n\t\t\t\tPoco::Thread::sleep(1000);\n\t\t\t}\n\t\t\tcatch (Poco::Exception& exc)\n\t\t\t{\n\t\t\t\tstd::cerr << \"HTTPSTestServer: \" << exc.displayText() << std::endl;\n\t\t\t}\n\t\t}\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSTestServer.cpp", "func": "bool HTTPSTestServer::requestComplete() const\n{\n\treturn ((_lastRequest.substr(0, 3) == \"GET\" || _lastRequest.substr(0, 4) == \"HEAD\") && \n\t       (_lastRequest.find(\"\\r\\n\\r\\n\") != std::string::npos)) ||\n\t       (_lastRequest.find(\"\\r\\n0\\r\\n\") != std::string::npos);\n}\n", "label": "network"}
{"project": "poco", "file": "HTTPSTestServer.cpp", "func": "std::string HTTPSTestServer::handleRequest() const\n{\n\tstd::string response;\n\tresponse.reserve(16000);\n\tif (_lastRequest.substr(0, 10) == \"GET /small\" ||\n\t    _lastRequest.substr(0, 11) == \"HEAD /small\")\n\t{\n\t\tstd::string body(SMALL_BODY);\n\t\tresponse.append(\"HTTP/1.0 200 OK\\r\\n\");\n\t\tresponse.append(\"Content-Type: text/plain\\r\\n\");\n\t\tresponse.append(\"Content-Length: \"); \n\t\tresponse.append(NumberFormatter::format((int) body.size()));\n\t\tresponse.append(\"\\r\\n\");\n\t\tresponse.append(\"Connection: Close\\r\\n\");\n\t\tresponse.append(\"\\r\\n\");\n\t\tif (_lastRequest.substr(0, 3) == \"GET\")\n\t\t\tresponse.append(body);\n\t}\n\telse if (_lastRequest.substr(0, 10) == \"GET /large\" ||\n\t         _lastRequest.substr(0, 11) == \"HEAD /large\" ||\n\t         _lastRequest.substr(0, 36) == \"GET http://www.somehost.com:80/large\")\n\t{\n\t\tstd::string body(LARGE_BODY);\n\t\tresponse.append(\"HTTP/1.0 200 OK\\r\\n\");\n\t\tresponse.append(\"Content-Type: text/plain\\r\\n\");\n\t\tresponse.append(\"Content-Length: \"); \n\t\tresponse.append(NumberFormatter::format((int) body.size()));\n\t\tresponse.append(\"\\r\\n\");\n\t\tresponse.append(\"Connection: Close\\r\\n\");\n\t\tresponse.append(\"\\r\\n\");\n\t\tif (_lastRequest.substr(0, 3) == \"GET\")\n\t\t\tresponse.append(body);\n\t}\n\telse if (_lastRequest.substr(0, 4) == \"POST\")\n\t{\n\t\tstd::string::size_type pos = _lastRequest.find(\"\\r\\n\\r\\n\");\n\t\tpos += 4;\n\t\tstd::string body = _lastRequest.substr(pos);\n\t\tresponse.append(\"HTTP/1.0 200 OK\\r\\n\");\n\t\tresponse.append(\"Content-Type: text/plain\\r\\n\");\n\t\tif (_lastRequest.find(\"Content-Length\") != std::string::npos)\n\t\t{\n\t\t\tresponse.append(\"Content-Length: \"); \n\t\t\tresponse.append(NumberFormatter::format((int) body.size()));\n\t\t\tresponse.append(\"\\r\\n\");\n\t\t}\n\t\telse if (_lastRequest.find(\"chunked\") != std::string::npos)\n\t\t{\n\t\t\tresponse.append(\"Transfer-Encoding: chunked\\r\\n\");\n\t\t}\n\t\tif (_lastRequest.substr(0,15) == \"POST /keepAlive\")\n\t\t\tresponse.append(\"Connection: keep-alive\\r\\n\");\n\t\telse\n\t\t\tresponse.append(\"Connection: Close\\r\\n\");\n\t\tresponse.append(\"\\r\\n\");\n\t\tresponse.append(body);\n\t}\n\telse if (_lastRequest.substr(0, 15) == \"HEAD /keepAlive\")\n\t{\n\t\tstd::string body(SMALL_BODY);\n\t\tresponse.append(\"HTTP/1.1 200 OK\\r\\n\");\n\t\tresponse.append(\"Connection: keep-alive\\r\\n\");\n\t\tresponse.append(\"Content-Type: text/plain\\r\\n\");\n\t\tresponse.append(\"Content-Length: \"); \n\t\tresponse.append(NumberFormatter::format((int) body.size()));\n\t\tresponse.append(\"\\r\\n\\r\\n\");\n\t\tresponse.append(\"HTTP/1.1 200 OK\\r\\n\");\n\t\tresponse.append(\"Connection: Keep-Alive\\r\\n\");\n\t\tresponse.append(\"Content-Type: text/plain\\r\\n\");\n\t\tresponse.append(\"Content-Length: \"); \n\t\tresponse.append(NumberFormatter::format((int) body.size()));\n\t\tresponse.append(\"\\r\\n\\r\\n\");\n\t\tresponse.append(body);\n\t\tbody = LARGE_BODY;\n\t\tresponse.append(\"HTTP/1.1 200 OK\\r\\n\");\n\t\tresponse.append(\"Connection: keep-alive\\r\\n\");\n\t\tresponse.append(\"Content-Type: text/plain\\r\\n\");\n\t\tresponse.append(\"Transfer-Encoding: chunked\\r\\n\\r\\n\");\n\t\tresponse.append(NumberFormatter::formatHex((unsigned) body.length()));\n\t\tresponse.append(\"\\r\\n\");\n\t\tresponse.append(body);\n\t\tresponse.append(\"\\r\\n0\\r\\n\\r\\n\");\n\t\tresponse.append(\"HTTP/1.1 200 OK\\r\\n\");\n\t\tresponse.append(\"Connection: close\\r\\n\");\n\t\tresponse.append(\"Content-Type: text/plain\\r\\n\");\n\t\tresponse.append(\"Content-Length: \"); \n\t\tresponse.append(NumberFormatter::format((int) body.size()));\n\t\tresponse.append(\"\\r\\n\\r\\n\");\n\t}\n\telse if (_lastRequest.substr(0, 13) == \"GET /redirect\")\n\t{\n\t\tresponse.append(\"HTTP/1.0 302 Found\\r\\n\");\n\t\tresponse.append(\"Location: /large\\r\\n\");\n\t\tresponse.append(\"\\r\\n\");\n\t}\n\telse if (_lastRequest.substr(0, 13) == \"GET /notfound\")\n\t{\n\t\tresponse.append(\"HTTP/1.0 404 Not Found\\r\\n\");\n\t\tresponse.append(\"\\r\\n\");\n\t}\n\telse if (_lastRequest.substr(0, 5) == \"GET /\" ||\n\t    _lastRequest.substr(0, 6) == \"HEAD /\")\n\t{\n\t\tstd::string body(SMALL_BODY);\n\t\tresponse.append(\"HTTP/1.0 200 OK\\r\\n\");\n\t\tresponse.append(\"Content-Type: text/plain\\r\\n\");\n\t\tresponse.append(\"Content-Length: \"); \n\t\tresponse.append(NumberFormatter::format((int) body.size()));\n\t\tresponse.append(\"\\r\\n\");\n\t\tresponse.append(\"Connection: Close\\r\\n\");\n\t\tresponse.append(\"\\r\\n\");\n\t\tif (_lastRequest.substr(0, 3) == \"GET\")\n\t\t\tresponse.append(body);\n\t}\n\treturn response;\n}\n", "label": "network"}
{"project": "poco", "file": "NetSSLTestSuite.cpp", "func": "CppUnit::Test* NetSSLTestSuite::suite()\n{\n\tCppUnit::TestSuite* pSuite = new CppUnit::TestSuite(\"NetSSLTestSuite\");\n\n\tpSuite->addTest(HTTPSClientTestSuite::suite());\n\tpSuite->addTest(TCPServerTestSuite::suite());\n\tpSuite->addTest(HTTPSServerTestSuite::suite());\n\n\treturn pSuite;\n}\n", "label": "network"}
{"project": "poco", "file": "TCPServerTest.cpp", "func": "\t\tvoid run()\n\t\t{\n\t\t\tStreamSocket& ss = socket();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tchar buffer[256];\n\t\t\t\tint n = ss.receiveBytes(buffer, sizeof(buffer));\n\t\t\t\twhile (n > 0)\n\t\t\t\t{\n\t\t\t\t\tss.sendBytes(buffer, n);\n\t\t\t\t\tn = ss.receiveBytes(buffer, sizeof(buffer));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Poco::Exception& exc)\n\t\t\t{\n\t\t\t\tstd::cerr << \"EchoConnection: \" << exc.displayText() << std::endl;\n\t\t\t}\n\t\t}\n", "label": "network"}
{"project": "poco", "file": "TCPServerTest.cpp", "func": "void TCPServerTest::testOneConnection()\n{\n\tSecureServerSocket svs(0);\n\tTCPServer srv(new TCPServerConnectionFactoryImpl<EchoConnection>(), svs);\n\tsrv.start();\n\tassertTrue (srv.currentConnections() == 0);\n\tassertTrue (srv.currentThreads() == 0);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 0);\n\t\n\tSocketAddress sa(\"127.0.0.1\", svs.address().port());\n\tSecureStreamSocket ss1(sa);\n\tstd::string data(\"hello, world\");\n\tss1.sendBytes(data.data(), (int) data.size());\n\tchar buffer[256];\n\tint n = ss1.receiveBytes(buffer, sizeof(buffer));\n\tassertTrue (n > 0);\n\tassertTrue (std::string(buffer, n) == data);\n\tassertTrue (srv.currentConnections() == 1);\n\tassertTrue (srv.currentThreads() == 1);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 1);\n\tss1.close();\n\tThread::sleep(300);\n\tassertTrue (srv.currentConnections() == 0);\n}\n", "label": "network"}
{"project": "poco", "file": "TCPServerTest.cpp", "func": "void TCPServerTest::testTwoConnections()\n{\n\tSecureServerSocket svs(0);\n\tTCPServer srv(new TCPServerConnectionFactoryImpl<EchoConnection>(), svs);\n\tsrv.start();\n\tassertTrue (srv.currentConnections() == 0);\n\tassertTrue (srv.currentThreads() == 0);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 0);\n\t\n\tSocketAddress sa(\"127.0.0.1\", svs.address().port());\n\tSecureStreamSocket ss1(sa);\n\tSecureStreamSocket ss2(sa);\n\tstd::string data(\"hello, world\");\n\tss1.sendBytes(data.data(), (int) data.size());\n\tss2.sendBytes(data.data(), (int) data.size());\n\n\tchar buffer[256];\n\tint n = ss1.receiveBytes(buffer, sizeof(buffer));\n\tassertTrue (n > 0);\n\tassertTrue (std::string(buffer, n) == data);\n\n\tn = ss2.receiveBytes(buffer, sizeof(buffer));\n\tassertTrue (n > 0);\n\tassertTrue (std::string(buffer, n) == data);\n\t\n\tassertTrue (srv.currentConnections() == 2);\n\tassertTrue (srv.currentThreads() == 2);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 2);\n\tss1.close();\n\tThread::sleep(300);\n\tassertTrue (srv.currentConnections() == 1);\n\tassertTrue (srv.currentThreads() == 1);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 2);\n\tss2.close();\n\n\tThread::sleep(300);\n\tassertTrue (srv.currentConnections() == 0);\n}\n", "label": "network"}
{"project": "poco", "file": "TCPServerTest.cpp", "func": "void TCPServerTest::testMultiConnections()\n{\n\tSecureServerSocket svs(0);\n\tTCPServerParams* pParams = new TCPServerParams;\n\tpParams->setMaxThreads(4);\n\tpParams->setMaxQueued(4);\n\tpParams->setThreadIdleTime(100);\n\tTCPServer srv(new TCPServerConnectionFactoryImpl<EchoConnection>(), svs, pParams);\n\tsrv.start();\n\tassertTrue (srv.currentConnections() == 0);\n\tassertTrue (srv.currentThreads() == 0);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 0);\n\t\n\tSocketAddress sa(\"127.0.0.1\", svs.address().port());\n\tSecureStreamSocket ss1(sa);\n\tSecureStreamSocket ss2(sa);\n\tSecureStreamSocket ss3(sa);\n\tSecureStreamSocket ss4(sa);\n\tstd::string data(\"hello, world\");\n\tss1.sendBytes(data.data(), (int) data.size());\n\tss2.sendBytes(data.data(), (int) data.size());\n\tss3.sendBytes(data.data(), (int) data.size());\n\tss4.sendBytes(data.data(), (int) data.size());\n\n\tchar buffer[256];\n\tint n = ss1.receiveBytes(buffer, sizeof(buffer));\n\tassertTrue (n > 0);\n\tassertTrue (std::string(buffer, n) == data);\n\n\tn = ss2.receiveBytes(buffer, sizeof(buffer));\n\tassertTrue (n > 0);\n\tassertTrue (std::string(buffer, n) == data);\n\n\tn = ss3.receiveBytes(buffer, sizeof(buffer));\n\tassertTrue (n > 0);\n\tassertTrue (std::string(buffer, n) == data);\n\n\tn = ss4.receiveBytes(buffer, sizeof(buffer));\n\tassertTrue (n > 0);\n\tassertTrue (std::string(buffer, n) == data);\n\t\n\tassertTrue (srv.currentConnections() == 4);\n\tassertTrue (srv.currentThreads() == 4);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 4);\n\t\n\tSecureStreamSocket ss5;\n\tss5.setLazyHandshake();\n\tss5.connect(sa);\n\tThread::sleep(200);\n\tassertTrue (srv.queuedConnections() == 1);\n\tSecureStreamSocket ss6;\n\tss6.setLazyHandshake();\n\tss6.connect(sa);\n\tThread::sleep(200);\n\tassertTrue (srv.queuedConnections() == 2);\n\t\n\tss1.close();\n\tThread::sleep(300);\n\tassertTrue (srv.currentConnections() == 4);\n\tassertTrue (srv.currentThreads() == 4);\n\tassertTrue (srv.queuedConnections() == 1);\n\tassertTrue (srv.totalConnections() == 5);\n\n\tss2.close();\n\tThread::sleep(300);\n\tassertTrue (srv.currentConnections() == 4);\n\tassertTrue (srv.currentThreads() == 4);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 6);\n\t\n\tss3.close();\n\tThread::sleep(300);\n\tassertTrue (srv.currentConnections() == 3);\n\tassertTrue (srv.currentThreads() == 3);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 6);\n\n\tss4.close();\n\tThread::sleep(300);\n\tassertTrue (srv.currentConnections() == 2);\n\tassertTrue (srv.currentThreads() == 2);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 6);\n\n\tss5.close();\n\tss6.close();\n\tThread::sleep(300);\n\tassertTrue (srv.currentConnections() == 0);\n}\n", "label": "network"}
{"project": "poco", "file": "TCPServerTest.cpp", "func": "void TCPServerTest::testReuseSocket()\n{\n\tSecureServerSocket svs(0);\n\tTCPServer srv(new TCPServerConnectionFactoryImpl<EchoConnection>(), svs);\n\tsrv.start();\n\tassertTrue (srv.currentConnections() == 0);\n\tassertTrue (srv.currentThreads() == 0);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 0);\n\t\n\tSocketAddress sa(\"127.0.0.1\", svs.address().port());\n\tSecureStreamSocket ss1(sa);\n\tstd::string data(\"hello, world\");\n\tss1.sendBytes(data.data(), (int) data.size());\n\tchar buffer[256];\n\tint n = ss1.receiveBytes(buffer, sizeof(buffer));\n\tassertTrue (n > 0);\n\tassertTrue (std::string(buffer, n) == data);\n\tassertTrue (srv.currentConnections() == 1);\n\tassertTrue (srv.currentThreads() == 1);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 1);\n\tss1.close();\n\tThread::sleep(300);\n\tassertTrue (srv.currentConnections() == 0);\n\n\tss1.connect(sa);\n\tss1.sendBytes(data.data(), (int) data.size());\n\tn = ss1.receiveBytes(buffer, sizeof(buffer));\n\tassertTrue (n > 0);\n\tassertTrue (std::string(buffer, n) == data);\n\tassertTrue (srv.currentConnections() == 1);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 2);\n\tss1.close();\n\tThread::sleep(300);\n\tassertTrue (srv.currentConnections() == 0);\n}\n", "label": "network"}
{"project": "poco", "file": "TCPServerTest.cpp", "func": "void TCPServerTest::testReuseSession()\n{\n\t// ensure SSL machinery is fully setup\n\tContext::Ptr pDefaultServerContext = SSLManager::instance().defaultServerContext();\n\tContext::Ptr pDefaultClientContext = SSLManager::instance().defaultClientContext();\n\t\n\tContext::Ptr pServerContext = new Context(\n\t\tContext::SERVER_USE, \n\t\t\"test.appinf.com\");\t\n\t//pServerContext->enableSessionCache(true, \"TestSuite\");\n\t//pServerContext->setSessionTimeout(10);\n\t//pServerContext->setSessionCacheSize(1000);\n\t//pServerContext->disableStatelessSessionResumption();\n\t\n\tSecureServerSocket svs(0, 64, pServerContext);\n\tTCPServer srv(new TCPServerConnectionFactoryImpl<EchoConnection>(), svs);\n\tsrv.start();\n\tassertTrue (srv.currentConnections() == 0);\n\tassertTrue (srv.currentThreads() == 0);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 0);\n\t\n\tContext::Ptr pClientContext = new Context(\n\t\tContext::CLIENT_USE, \n\t\t\"\");\n\t//pClientContext->enableSessionCache(true);\n\t\n\tSocketAddress sa(\"127.0.0.1\", svs.address().port());\n\tSecureStreamSocket ss1(sa, pClientContext);\n\tassertTrue (!ss1.sessionWasReused());\n\tstd::string data(\"hello, world\");\n\tss1.sendBytes(data.data(), (int) data.size());\n\tchar buffer[256];\n\tint n = ss1.receiveBytes(buffer, sizeof(buffer));\n\tassertTrue (n > 0);\n\tassertTrue (std::string(buffer, n) == data);\n\tassertTrue (srv.currentConnections() == 1);\n\tassertTrue (srv.currentThreads() == 1);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 1);\n\t\n\tSession::Ptr pSession = ss1.currentSession();\n\t\n\tss1.close();\n\tThread::sleep(300);\n\tassertTrue (srv.currentConnections() == 0);\n\n\tss1.useSession(pSession);\n\tss1.connect(sa);\n\tassertTrue (ss1.sessionWasReused());\n\tassertTrue (ss1.currentSession() == pSession);\n\tss1.sendBytes(data.data(), (int) data.size());\n\tn = ss1.receiveBytes(buffer, sizeof(buffer));\n\tassertTrue (n > 0);\n\tassertTrue (std::string(buffer, n) == data);\n\tassertTrue (srv.currentConnections() == 1);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 2);\n\tss1.close();\n\tThread::sleep(300);\n\tassertTrue (srv.currentConnections() == 0);\n\n\tThread::sleep(15000); // wait for session to expire\n\t//pServerContext->flushSessionCache();\n\t\n\tss1.useSession(pSession);\n\tss1.connect(sa);\n\tassertTrue (!ss1.sessionWasReused());\n\tassertTrue (ss1.currentSession() != pSession);\n\tss1.sendBytes(data.data(), (int) data.size());\n\tn = ss1.receiveBytes(buffer, sizeof(buffer));\n\tassertTrue (n > 0);\n\tassertTrue (std::string(buffer, n) == data);\n\tassertTrue (srv.currentConnections() == 1);\n\tassertTrue (srv.queuedConnections() == 0);\n\tassertTrue (srv.totalConnections() == 3);\n\tss1.close();\n\tThread::sleep(300);\n\tassertTrue (srv.currentConnections() == 0);\n}\n", "label": "network"}
{"project": "poco", "file": "TCPServerTest.cpp", "func": "void TCPServerTest::setUp()\n{\n}\n", "label": "network"}
{"project": "poco", "file": "TCPServerTest.cpp", "func": "void TCPServerTest::tearDown()\n{\n}\n", "label": "network"}
{"project": "poco", "file": "TCPServerTest.cpp", "func": "CppUnit::Test* TCPServerTest::suite()\n{\n\tCppUnit::TestSuite* pSuite = new CppUnit::TestSuite(\"TCPServerTest\");\n\n\tCppUnit_addTest(pSuite, TCPServerTest, testOneConnection);\n\tCppUnit_addTest(pSuite, TCPServerTest, testTwoConnections);\n\tCppUnit_addTest(pSuite, TCPServerTest, testMultiConnections);\n\tCppUnit_addTest(pSuite, TCPServerTest, testReuseSocket);\n\t//CppUnit_addTest(pSuite, TCPServerTest, testReuseSession);\n\n\treturn pSuite;\n}\n", "label": "network"}
{"project": "poco", "file": "TCPServerTestSuite.cpp", "func": "CppUnit::Test* TCPServerTestSuite::suite()\n{\n\tCppUnit::TestSuite* pSuite = new CppUnit::TestSuite(\"TCPServerTestSuite\");\n\n\tpSuite->addTest(TCPServerTest::suite());\n\n\treturn pSuite;\n}\n", "label": "network"}
{"project": "poco", "file": "WebSocketTest.cpp", "func": "\t\tvoid handleRequest(HTTPServerRequest& request, HTTPServerResponse& response)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tWebSocket ws(request, response);\n\t\t\t\tstd::unique_ptr<char[]> pBuffer(new char[_bufSize]);\n\t\t\t\tint flags;\n\t\t\t\tint n;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tn = ws.receiveFrame(pBuffer.get(), static_cast<int>(_bufSize), flags);\n\t\t\t\t\tif (n == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tws.sendFrame(pBuffer.get(), n, flags);\n\t\t\t\t}\n\t\t\t\twhile ((flags & WebSocket::FRAME_OP_BITMASK) != WebSocket::FRAME_OP_CLOSE);\n\t\t\t}\n\t\t\tcatch (WebSocketException& exc)\n\t\t\t{\n\t\t\t\tswitch (exc.code())\n\t\t\t\t{\n\t\t\t\tcase WebSocket::WS_ERR_HANDSHAKE_UNSUPPORTED_VERSION:\n\t\t\t\t\tresponse.set(\"Sec-WebSocket-Version\", WebSocket::WEBSOCKET_VERSION);\n\t\t\t\t\t// fallthrough\n\t\t\t\tcase WebSocket::WS_ERR_NO_HANDSHAKE:\n\t\t\t\tcase WebSocket::WS_ERR_HANDSHAKE_NO_VERSION:\n\t\t\t\tcase WebSocket::WS_ERR_HANDSHAKE_NO_KEY:\n\t\t\t\t\tresponse.setStatusAndReason(HTTPResponse::HTTP_BAD_REQUEST);\n\t\t\t\t\tresponse.setContentLength(0);\n\t\t\t\t\tresponse.send();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n", "label": "network"}
{"project": "poco", "file": "WebSocketTest.cpp", "func": "\t\tPoco::Net::HTTPRequestHandler* createRequestHandler(const HTTPServerRequest& request)\n\t\t{\n\t\t\treturn new WebSocketRequestHandler(_bufSize);\n\t\t}\n", "label": "network"}
{"project": "poco", "file": "WebSocketTest.cpp", "func": "void WebSocketTest::testWebSocket()\n{\n\tPoco::Net::SecureServerSocket ss(0);\n\tPoco::Net::HTTPServer server(new WebSocketRequestHandlerFactory, ss, new Poco::Net::HTTPServerParams);\n\tserver.start();\n\n\tPoco::Thread::sleep(200);\n\n\tHTTPSClientSession cs(\"127.0.0.1\", ss.address().port());\n\tHTTPRequest request(HTTPRequest::HTTP_GET, \"/ws\");\n\tHTTPResponse response;\n\tWebSocket ws(cs, request, response);\n\n\tstd::string payload(\"x\");\n\tws.sendFrame(payload.data(), (int) payload.size());\n\tchar buffer[1024] = {};\n\tint flags;\n\tint n = ws.receiveFrame(buffer, sizeof(buffer), flags);\n\tassertTrue (n == payload.size());\n\tassertTrue (payload.compare(0, payload.size(), buffer, 0, n) == 0);\n\tassertTrue (flags == WebSocket::FRAME_TEXT);\n\n\tfor (int i = 2; i < 20; i++)\n\t{\n\t\tpayload.assign(i, 'x');\n\t\tws.sendFrame(payload.data(), (int) payload.size());\n\t\tn = ws.receiveFrame(buffer, sizeof(buffer), flags);\n\t\tassertTrue (n == payload.size());\n\t\tassertTrue (payload.compare(0, payload.size(), buffer, 0, n) == 0);\n\t\tassertTrue (flags == WebSocket::FRAME_TEXT);\n\t}\n\n\tfor (int i = 125; i < 129; i++)\n\t{\n\t\tpayload.assign(i, 'x');\n\t\tws.sendFrame(payload.data(), (int) payload.size());\n\t\tn = ws.receiveFrame(buffer, sizeof(buffer), flags);\n\t\tassertTrue (n == payload.size());\n\t\tassertTrue (payload.compare(0, payload.size(), buffer, 0, n) == 0);\n\t\tassertTrue (flags == WebSocket::FRAME_TEXT);\n\t}\n\n\tpayload = \"Hello, world!\";\n\tws.sendFrame(payload.data(), (int) payload.size());\n\tn = ws.receiveFrame(buffer, sizeof(buffer), flags);\n\tassertTrue (n == payload.size());\n\tassertTrue (payload.compare(0, payload.size(), buffer, 0, n) == 0);\n\tassertTrue (flags == WebSocket::FRAME_TEXT);\n\n\tpayload = \"Hello, universe!\";\n\tws.sendFrame(payload.data(), (int) payload.size(), WebSocket::FRAME_BINARY);\n\tn = ws.receiveFrame(buffer, sizeof(buffer), flags);\n\tassertTrue (n == payload.size());\n\tassertTrue (payload.compare(0, payload.size(), buffer, 0, n) == 0);\n\tassertTrue (flags == WebSocket::FRAME_BINARY);\n\n\tws.shutdown();\n\tn = ws.receiveFrame(buffer, sizeof(buffer), flags);\n\tassertTrue (n == 2);\n\tassertTrue ((flags & WebSocket::FRAME_OP_BITMASK) == WebSocket::FRAME_OP_CLOSE);\n\n\tserver.stop();\n}\n", "label": "network"}
{"project": "poco", "file": "WebSocketTest.cpp", "func": "void WebSocketTest::testWebSocketLarge()\n{\n\tconst int msgSize = 64000;\n\n\tPoco::Net::SecureServerSocket ss(0);\n\tPoco::Net::HTTPServer server(new WebSocketRequestHandlerFactory(msgSize), ss, new Poco::Net::HTTPServerParams);\n\tserver.start();\n\n\tPoco::Thread::sleep(200);\n\n\tHTTPSClientSession cs(\"127.0.0.1\", ss.address().port());\n\tHTTPRequest request(HTTPRequest::HTTP_GET, \"/ws\");\n\tHTTPResponse response;\n\tWebSocket ws(cs, request, response);\n\tws.setSendBufferSize(msgSize);\n\tws.setReceiveBufferSize(msgSize);\n\tstd::string payload(msgSize, 'x');\n\tSocketStream sstr(ws);\n\tsstr << payload;\n\tsstr.flush();\n\n\tchar buffer[msgSize + 1] = {};\n\tint flags;\n\tint n = 0;\n\tdo\n\t{\n\t\tn += ws.receiveFrame(buffer + n, sizeof(buffer) - n, flags);\n\t} while (n > 0 && n < msgSize);\n\n\tassertTrue (n == payload.size());\n\tassertTrue (payload.compare(0, payload.size(), buffer, 0, n) == 0);\n}\n", "label": "network"}
{"project": "poco", "file": "WebSocketTest.cpp", "func": "void WebSocketTest::setUp()\n{\n}\n", "label": "network"}
{"project": "poco", "file": "WebSocketTest.cpp", "func": "void WebSocketTest::tearDown()\n{\n}\n", "label": "network"}
{"project": "poco", "file": "WebSocketTest.cpp", "func": "CppUnit::Test* WebSocketTest::suite()\n{\n\tCppUnit::TestSuite* pSuite = new CppUnit::TestSuite(\"WebSocketTest\");\n\n\tCppUnit_addTest(pSuite, WebSocketTest, testWebSocket);\n\tCppUnit_addTest(pSuite, WebSocketTest, testWebSocketLarge);\n\n\treturn pSuite;\n}\n", "label": "network"}
{"project": "poco", "file": "WinCEDriver.cpp", "func": "\tint main(const std::vector<std::string>& args)\n\t{\n\t\tCppUnit::TestRunner runner;\n\t\trunner.addTest(\"NetSSLTestSuite\", NetSSLTestSuite::suite());\n\t\treturn runner.run(_targs) ? 0 : 1;\n\t}\n", "label": "network"}
{"project": "poco", "file": "WinCEDriver.cpp", "func": "\tvoid setup(const std::vector<std::string>& args)\n\t{\n\t\tchar* argv[] =\n\t\t{\n\t\t\tconst_cast<char*>(args[0].c_str())\n\t\t};\n\t\t\n\t\tinit(1, argv);\n\t\tfor (std::size_t i = 0; i < args.size(); ++i)\n\t\t\t_targs.push_back(args[i]);\n\t}\n", "label": "network"}
{"project": "poco", "file": "WinCEDriver.cpp", "func": "\tvoid initialize(Poco::Util::Application& self)\n\t{\n\t\tloadConfiguration(); // load default configuration files, if present\n\t\tPoco::Util::Application::initialize(self);\n\t}\n", "label": "network"}
{"project": "poco", "file": "WinCEDriver.cpp", "func": "int _tmain(int argc, wchar_t* argv[])\n{\n\tstd::vector<std::string> args;\n\tfor (int i = 0; i < argc; ++i)\n\t{\n\t\tchar buffer[1024];\n\t\tstd::wcstombs(buffer, argv[i], sizeof(buffer));\n\t\targs.push_back(std::string(buffer));\n\t}\n\n\tNetSSLApp app;\n\ttry\n\t{\n\t\tapp.setup(args);\n\t\treturn app.run();\n\t}\n\tcatch (Poco::Exception& exc)\n\t{\n\t\tstd::cout << exc.displayText() << std::endl;\n\t\treturn 1;\n\t}\n}\n", "label": "network"}
{"project": "poco", "file": "WinDriver.cpp", "func": "\tvoid TestMain()\n\t{\n\t\tNetSSLApp app;\n\t\tstd::string argv(\"TestSuite\");\n\t\tconst char* pArgv = argv.c_str();\n\t\ttry\n\t\t{\n\t\t\tapp.init(1, (char**)&pArgv);\n\t\t\tapp.run();\n\t\t}\n\t\tcatch (Poco::Exception& exc)\n\t\t{\n\t\t\tapp.logger().log(exc);\n\t\t}\n\t}\n", "label": "network"}
{"project": "qemu", "file": "tlscredsx509.c", "func": "static bool\nqcrypto_tls_creds_x509_prop_get_loaded(Object *obj G_GNUC_UNUSED,\n                                       Error **errp G_GNUC_UNUSED)\n{\n    return false;\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlscredsx509.c", "func": "static void\nqcrypto_tls_creds_x509_prop_set_sanity(Object *obj,\n                                       bool value,\n                                       Error **errp G_GNUC_UNUSED)\n{\n    QCryptoTLSCredsX509 *creds = QCRYPTO_TLS_CREDS_X509(obj);\n\n    creds->sanityCheck = value;\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlscredsx509.c", "func": "static void\nqcrypto_tls_creds_x509_prop_set_passwordid(Object *obj,\n                                           const char *value,\n                                           Error **errp G_GNUC_UNUSED)\n{\n    QCryptoTLSCredsX509 *creds = QCRYPTO_TLS_CREDS_X509(obj);\n\n    creds->passwordid = g_strdup(value);\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlscredsx509.c", "func": "static char *\nqcrypto_tls_creds_x509_prop_get_passwordid(Object *obj,\n                                           Error **errp G_GNUC_UNUSED)\n{\n    QCryptoTLSCredsX509 *creds = QCRYPTO_TLS_CREDS_X509(obj);\n\n    return g_strdup(creds->passwordid);\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlscredsx509.c", "func": "static bool\nqcrypto_tls_creds_x509_prop_get_sanity(Object *obj,\n                                       Error **errp G_GNUC_UNUSED)\n{\n    QCryptoTLSCredsX509 *creds = QCRYPTO_TLS_CREDS_X509(obj);\n\n    return creds->sanityCheck;\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlscredsx509.c", "func": "static bool\nqcrypto_tls_creds_x509_reload(QCryptoTLSCreds *creds, Error **errp)\n{\n    return false;\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlscredsx509.c", "func": "static void\nqcrypto_tls_creds_x509_init(Object *obj)\n{\n    QCryptoTLSCredsX509 *creds = QCRYPTO_TLS_CREDS_X509(obj);\n\n    creds->sanityCheck = true;\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlscredsx509.c", "func": "static void\nqcrypto_tls_creds_x509_finalize(Object *obj)\n{\n    QCryptoTLSCredsX509 *creds = QCRYPTO_TLS_CREDS_X509(obj);\n\n    g_free(creds->passwordid);\n    qcrypto_tls_creds_x509_unload(creds);\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlscredsx509.c", "func": "static void\nqcrypto_tls_creds_x509_class_init(ObjectClass *oc, void *data)\n{\n    UserCreatableClass *ucc = USER_CREATABLE_CLASS(oc);\n    QCryptoTLSCredsClass *ctcc = QCRYPTO_TLS_CREDS_CLASS(oc);\n\n    ctcc->reload = qcrypto_tls_creds_x509_reload;\n\n    ucc->complete = qcrypto_tls_creds_x509_complete;\n\n    object_class_property_add_bool(oc, \"loaded\",\n                                   qcrypto_tls_creds_x509_prop_get_loaded,\n                                   NULL);\n    object_class_property_add_bool(oc, \"sanity-check\",\n                                   qcrypto_tls_creds_x509_prop_get_sanity,\n                                   qcrypto_tls_creds_x509_prop_set_sanity);\n    object_class_property_add_str(oc, \"passwordid\",\n                                  qcrypto_tls_creds_x509_prop_get_passwordid,\n                                  qcrypto_tls_creds_x509_prop_set_passwordid);\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlscredsx509.c", "func": "static void\nqcrypto_tls_creds_x509_register_types(void)\n{\n    type_register_static(&qcrypto_tls_creds_x509_info);\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlssession.c", "func": "QCryptoTLSSession *\nqcrypto_tls_session_new(QCryptoTLSCreds *creds G_GNUC_UNUSED,\n                        const char *hostname G_GNUC_UNUSED,\n                        const char *authzid G_GNUC_UNUSED,\n                        QCryptoTLSCredsEndpoint endpoint G_GNUC_UNUSED,\n                        Error **errp)\n{\n    error_setg(errp, \"TLS requires GNUTLS support\");\n    return NULL;\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlssession.c", "func": "void\nqcrypto_tls_session_free(QCryptoTLSSession *sess G_GNUC_UNUSED)\n{\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlssession.c", "func": "int\nqcrypto_tls_session_check_credentials(QCryptoTLSSession *sess G_GNUC_UNUSED,\n                                      Error **errp)\n{\n    error_setg(errp, \"TLS requires GNUTLS support\");\n    return -1;\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlssession.c", "func": "void\nqcrypto_tls_session_set_callbacks(\n    QCryptoTLSSession *sess G_GNUC_UNUSED,\n    QCryptoTLSSessionWriteFunc writeFunc G_GNUC_UNUSED,\n    QCryptoTLSSessionReadFunc readFunc G_GNUC_UNUSED,\n    void *opaque G_GNUC_UNUSED)\n{\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlssession.c", "func": "ssize_t\nqcrypto_tls_session_write(QCryptoTLSSession *sess,\n                          const char *buf,\n                          size_t len)\n{\n    errno = -EIO;\n    return -1;\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlssession.c", "func": "ssize_t\nqcrypto_tls_session_read(QCryptoTLSSession *sess,\n                         char *buf,\n                         size_t len)\n{\n    errno = -EIO;\n    return -1;\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlssession.c", "func": "int\nqcrypto_tls_session_handshake(QCryptoTLSSession *sess,\n                              Error **errp)\n{\n    error_setg(errp, \"TLS requires GNUTLS support\");\n    return -1;\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlssession.c", "func": "QCryptoTLSSessionHandshakeStatus\nqcrypto_tls_session_get_handshake_status(QCryptoTLSSession *sess)\n{\n    return QCRYPTO_TLS_HANDSHAKE_COMPLETE;\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlssession.c", "func": "int\nqcrypto_tls_session_get_key_size(QCryptoTLSSession *sess,\n                                 Error **errp)\n{\n    error_setg(errp, \"TLS requires GNUTLS support\");\n    return -1;\n}\n", "label": "crypto"}
{"project": "qemu", "file": "tlssession.c", "func": "char *\nqcrypto_tls_session_get_peer_name(QCryptoTLSSession *sess)\n{\n    return NULL;\n}\n", "label": "crypto"}
{"project": "qemu", "file": "xts.c", "func": "static inline void xts_uint128_xor(xts_uint128 *D,\n                                   const xts_uint128 *S1,\n                                   const xts_uint128 *S2)\n{\n    D->u[0] = S1->u[0] ^ S2->u[0];\n    D->u[1] = S1->u[1] ^ S2->u[1];\n}\n", "label": "crypto"}
{"project": "qemu", "file": "xts.c", "func": "static inline void xts_uint128_cpu_to_les(xts_uint128 *v)\n{\n    cpu_to_le64s(&v->u[0]);\n    cpu_to_le64s(&v->u[1]);\n}\n", "label": "crypto"}
{"project": "qemu", "file": "xts.c", "func": "static inline void xts_uint128_le_to_cpus(xts_uint128 *v)\n{\n    le64_to_cpus(&v->u[0]);\n    le64_to_cpus(&v->u[1]);\n}\n", "label": "crypto"}
{"project": "qemu", "file": "xts.c", "func": "static void xts_mult_x(xts_uint128 *I)\n{\n    uint64_t tt;\n\n    xts_uint128_le_to_cpus(I);\n\n    tt = I->u[0] >> 63;\n    I->u[0] <<= 1;\n\n    if (I->u[1] >> 63) {\n        I->u[0] ^= 0x87;\n    }\n    I->u[1] <<= 1;\n    I->u[1] |= tt;\n\n    xts_uint128_cpu_to_les(I);\n}\n", "label": "crypto"}
{"project": "qemu", "file": "xts.c", "func": "static inline void xts_tweak_encdec(const void *ctx,\n                                    xts_cipher_func *func,\n                                    const xts_uint128 *src,\n                                    xts_uint128 *dst,\n                                    xts_uint128 *iv)\n{\n    /* tweak encrypt block i */\n    xts_uint128_xor(dst, src, iv);\n\n    func(ctx, XTS_BLOCK_SIZE, dst->b, dst->b);\n\n    xts_uint128_xor(dst, dst, iv);\n\n    /* LFSR the tweak */\n    xts_mult_x(iv);\n}\n", "label": "crypto"}
{"project": "qemu", "file": "xts.c", "func": "void xts_decrypt(const void *datactx,\n                 const void *tweakctx,\n                 xts_cipher_func *encfunc,\n                 xts_cipher_func *decfunc,\n                 uint8_t *iv,\n                 size_t length,\n                 uint8_t *dst,\n                 const uint8_t *src)\n{\n    xts_uint128 PP, CC, T;\n    unsigned long i, m, mo, lim;\n\n    /* get number of blocks */\n    m = length >> 4;\n    mo = length & 15;\n\n    /* must have at least one full block */\n    g_assert(m != 0);\n\n    if (mo == 0) {\n        lim = m;\n    } else {\n        lim = m - 1;\n    }\n\n    /* encrypt the iv */\n    encfunc(tweakctx, XTS_BLOCK_SIZE, T.b, iv);\n\n    if (QEMU_PTR_IS_ALIGNED(src, sizeof(uint64_t)) &&\n        QEMU_PTR_IS_ALIGNED(dst, sizeof(uint64_t))) {\n        xts_uint128 *S = (xts_uint128 *)src;\n        xts_uint128 *D = (xts_uint128 *)dst;\n        for (i = 0; i < lim; i++, S++, D++) {\n            xts_tweak_encdec(datactx, decfunc, S, D, &T);\n        }\n    } else {\n        xts_uint128 D;\n\n        for (i = 0; i < lim; i++) {\n            memcpy(&D, src, XTS_BLOCK_SIZE);\n            xts_tweak_encdec(datactx, decfunc, &D, &D, &T);\n            memcpy(dst, &D, XTS_BLOCK_SIZE);\n            src += XTS_BLOCK_SIZE;\n            dst += XTS_BLOCK_SIZE;\n        }\n    }\n\n    /* if length is not a multiple of XTS_BLOCK_SIZE then */\n    if (mo > 0) {\n        xts_uint128 S, D;\n        memcpy(&CC, &T, XTS_BLOCK_SIZE);\n        xts_mult_x(&CC);\n\n        /* PP = tweak decrypt block m-1 */\n        memcpy(&S, src, XTS_BLOCK_SIZE);\n        xts_tweak_encdec(datactx, decfunc, &S, &PP, &CC);\n\n        /* Pm = first length % XTS_BLOCK_SIZE bytes of PP */\n        for (i = 0; i < mo; i++) {\n            CC.b[i] = src[XTS_BLOCK_SIZE + i];\n            dst[XTS_BLOCK_SIZE + i] = PP.b[i];\n        }\n        for (; i < XTS_BLOCK_SIZE; i++) {\n            CC.b[i] = PP.b[i];\n        }\n\n        /* Pm-1 = Tweak uncrypt CC */\n        xts_tweak_encdec(datactx, decfunc, &CC, &D, &T);\n        memcpy(dst, &D, XTS_BLOCK_SIZE);\n    }\n\n    /* Decrypt the iv back */\n    decfunc(tweakctx, XTS_BLOCK_SIZE, iv, T.b);\n}\n", "label": "crypto"}
{"project": "qemu", "file": "xts.c", "func": "void xts_encrypt(const void *datactx,\n                 const void *tweakctx,\n                 xts_cipher_func *encfunc,\n                 xts_cipher_func *decfunc,\n                 uint8_t *iv,\n                 size_t length,\n                 uint8_t *dst,\n                 const uint8_t *src)\n{\n    xts_uint128 PP, CC, T;\n    unsigned long i, m, mo, lim;\n\n    /* get number of blocks */\n    m = length >> 4;\n    mo = length & 15;\n\n    /* must have at least one full block */\n    g_assert(m != 0);\n\n    if (mo == 0) {\n        lim = m;\n    } else {\n        lim = m - 1;\n    }\n\n    /* encrypt the iv */\n    encfunc(tweakctx, XTS_BLOCK_SIZE, T.b, iv);\n\n    if (QEMU_PTR_IS_ALIGNED(src, sizeof(uint64_t)) &&\n        QEMU_PTR_IS_ALIGNED(dst, sizeof(uint64_t))) {\n        xts_uint128 *S = (xts_uint128 *)src;\n        xts_uint128 *D = (xts_uint128 *)dst;\n        for (i = 0; i < lim; i++, S++, D++) {\n            xts_tweak_encdec(datactx, encfunc, S, D, &T);\n        }\n    } else {\n        xts_uint128 D;\n\n        for (i = 0; i < lim; i++) {\n            memcpy(&D, src, XTS_BLOCK_SIZE);\n            xts_tweak_encdec(datactx, encfunc, &D, &D, &T);\n            memcpy(dst, &D, XTS_BLOCK_SIZE);\n\n            dst += XTS_BLOCK_SIZE;\n            src += XTS_BLOCK_SIZE;\n        }\n    }\n\n    /* if length is not a multiple of XTS_BLOCK_SIZE then */\n    if (mo > 0) {\n        xts_uint128 S, D;\n        /* CC = tweak encrypt block m-1 */\n        memcpy(&S, src, XTS_BLOCK_SIZE);\n        xts_tweak_encdec(datactx, encfunc, &S, &CC, &T);\n\n        /* Cm = first length % XTS_BLOCK_SIZE bytes of CC */\n        for (i = 0; i < mo; i++) {\n            PP.b[i] = src[XTS_BLOCK_SIZE + i];\n            dst[XTS_BLOCK_SIZE + i] = CC.b[i];\n        }\n\n        for (; i < XTS_BLOCK_SIZE; i++) {\n            PP.b[i] = CC.b[i];\n        }\n\n        /* Cm-1 = Tweak encrypt PP */\n        xts_tweak_encdec(datactx, encfunc, &PP, &D, &T);\n        memcpy(dst, &D, XTS_BLOCK_SIZE);\n    }\n\n    /* Decrypt the iv back */\n    decfunc(tweakctx, XTS_BLOCK_SIZE, iv, T.b);\n}\n", "label": "crypto"}
{"project": "qemu", "file": "vhost-user.c", "func": "static int vhost_user_start(int queues, NetClientState *ncs[],\n                            VhostUserState *be)\n{\n    VhostNetOptions options;\n    struct vhost_net *net = NULL;\n    NetVhostUserState *s;\n    int max_queues;\n    int i;\n\n    options.backend_type = VHOST_BACKEND_TYPE_USER;\n\n    for (i = 0; i < queues; i++) {\n        assert(ncs[i]->info->type == NET_CLIENT_DRIVER_VHOST_USER);\n\n        s = DO_UPCAST(NetVhostUserState, nc, ncs[i]);\n\n        options.net_backend = ncs[i];\n        options.opaque      = be;\n        options.busyloop_timeout = 0;\n        options.nvqs = 2;\n        net = vhost_net_init(&options);\n        if (!net) {\n            error_report(\"failed to init vhost_net for queue %d\", i);\n            goto err;\n        }\n\n        if (i == 0) {\n            max_queues = vhost_net_get_max_queues(net);\n            if (queues > max_queues) {\n                error_report(\"you are asking more queues than supported: %d\",\n                             max_queues);\n                goto err;\n            }\n        }\n\n        if (s->vhost_net) {\n            vhost_net_cleanup(s->vhost_net);\n            g_free(s->vhost_net);\n        }\n        s->vhost_net = net;\n    }\n\n    return 0;\n\nerr:\n    if (net) {\n        vhost_net_cleanup(net);\n        g_free(net);\n    }\n    vhost_user_stop(i, ncs);\n    return -1;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-user.c", "func": "static ssize_t vhost_user_receive(NetClientState *nc, const uint8_t *buf,\n                                  size_t size)\n{\n    /* In case of RARP (message size is 60) notify backup to send a fake RARP.\n       This fake RARP will be sent by backend only for guest\n       without GUEST_ANNOUNCE capability.\n     */\n    if (size == 60) {\n        NetVhostUserState *s = DO_UPCAST(NetVhostUserState, nc, nc);\n        int r;\n        static int display_rarp_failure = 1;\n        char mac_addr[6];\n\n        /* extract guest mac address from the RARP message */\n        memcpy(mac_addr, &buf[6], 6);\n\n        r = vhost_net_notify_migration_done(s->vhost_net, mac_addr);\n\n        if ((r != 0) && (display_rarp_failure)) {\n            fprintf(stderr,\n                    \"Vhost user backend fails to broadcast fake RARP\\n\");\n            fflush(stderr);\n            display_rarp_failure = 0;\n        }\n    }\n\n    return size;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-user.c", "func": "static void net_vhost_user_cleanup(NetClientState *nc)\n{\n    NetVhostUserState *s = DO_UPCAST(NetVhostUserState, nc, nc);\n\n    if (s->vhost_net) {\n        vhost_net_cleanup(s->vhost_net);\n        g_free(s->vhost_net);\n        s->vhost_net = NULL;\n    }\n    if (nc->queue_index == 0) {\n        if (s->watch) {\n            g_source_remove(s->watch);\n            s->watch = 0;\n        }\n        qemu_chr_fe_deinit(&s->chr, true);\n        if (s->vhost_user) {\n            vhost_user_cleanup(s->vhost_user);\n            g_free(s->vhost_user);\n            s->vhost_user = NULL;\n        }\n    }\n\n    qemu_purge_queued_packets(nc);\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-user.c", "func": "static int vhost_user_set_vnet_endianness(NetClientState *nc,\n                                          bool enable)\n{\n    /* Nothing to do.  If the server supports\n     * VHOST_USER_PROTOCOL_F_CROSS_ENDIAN, it will get the\n     * vnet header endianness from there.  If it doesn't, negotiation\n     * fails.\n     */\n    return 0;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-user.c", "func": "static bool vhost_user_has_vnet_hdr(NetClientState *nc)\n{\n    assert(nc->info->type == NET_CLIENT_DRIVER_VHOST_USER);\n\n    return true;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-user.c", "func": "static bool vhost_user_has_ufo(NetClientState *nc)\n{\n    assert(nc->info->type == NET_CLIENT_DRIVER_VHOST_USER);\n\n    return true;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-user.c", "func": "static bool vhost_user_check_peer_type(NetClientState *nc, ObjectClass *oc,\n                                       Error **errp)\n{\n    const char *driver = object_class_get_name(oc);\n\n    if (!g_str_has_prefix(driver, \"virtio-net-\")) {\n        error_setg(errp, \"vhost-user requires frontend driver virtio-net-*\");\n        return false;\n    }\n\n    return true;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-user.c", "func": "static gboolean net_vhost_user_watch(void *do_not_use, GIOCondition cond,\n                                     void *opaque)\n{\n    NetVhostUserState *s = opaque;\n\n    qemu_chr_fe_disconnect(&s->chr);\n\n    return TRUE;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-user.c", "func": "static void chr_closed_bh(void *opaque)\n{\n    const char *name = opaque;\n    NetClientState *ncs[MAX_QUEUE_NUM];\n    NetVhostUserState *s;\n    Error *err = NULL;\n    int queues, i;\n\n    queues = qemu_find_net_clients_except(name, ncs,\n                                          NET_CLIENT_DRIVER_NIC,\n                                          MAX_QUEUE_NUM);\n    assert(queues < MAX_QUEUE_NUM);\n\n    s = DO_UPCAST(NetVhostUserState, nc, ncs[0]);\n\n    for (i = queues -1; i >= 0; i--) {\n        s = DO_UPCAST(NetVhostUserState, nc, ncs[i]);\n\n        if (s->vhost_net) {\n            s->acked_features = vhost_net_get_acked_features(s->vhost_net);\n        }\n    }\n\n    qmp_set_link(name, false, &err);\n\n    qemu_chr_fe_set_handlers(&s->chr, NULL, NULL, net_vhost_user_event,\n                             NULL, opaque, NULL, true);\n\n    if (err) {\n        error_report_err(err);\n    }\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-user.c", "func": "static void net_vhost_user_event(void *opaque, QEMUChrEvent event)\n{\n    const char *name = opaque;\n    NetClientState *ncs[MAX_QUEUE_NUM];\n    NetVhostUserState *s;\n    Chardev *chr;\n    Error *err = NULL;\n    int queues;\n\n    queues = qemu_find_net_clients_except(name, ncs,\n                                          NET_CLIENT_DRIVER_NIC,\n                                          MAX_QUEUE_NUM);\n    assert(queues < MAX_QUEUE_NUM);\n\n    s = DO_UPCAST(NetVhostUserState, nc, ncs[0]);\n    chr = qemu_chr_fe_get_driver(&s->chr);\n    trace_vhost_user_event(chr->label, event);\n    switch (event) {\n    case CHR_EVENT_OPENED:\n        if (vhost_user_start(queues, ncs, s->vhost_user) < 0) {\n            qemu_chr_fe_disconnect(&s->chr);\n            return;\n        }\n        s->watch = qemu_chr_fe_add_watch(&s->chr, G_IO_HUP,\n                                         net_vhost_user_watch, s);\n        qmp_set_link(name, true, &err);\n        s->started = true;\n        break;\n    case CHR_EVENT_CLOSED:\n        /* a close event may happen during a read/write, but vhost\n         * code assumes the vhost_dev remains setup, so delay the\n         * stop & clear to idle.\n         * FIXME: better handle failure in vhost code, remove bh\n         */\n        if (s->watch) {\n            AioContext *ctx = qemu_get_current_aio_context();\n\n            g_source_remove(s->watch);\n            s->watch = 0;\n            qemu_chr_fe_set_handlers(&s->chr, NULL, NULL, NULL, NULL,\n                                     NULL, NULL, false);\n\n            aio_bh_schedule_oneshot(ctx, chr_closed_bh, opaque);\n        }\n        break;\n    case CHR_EVENT_BREAK:\n    case CHR_EVENT_MUX_IN:\n    case CHR_EVENT_MUX_OUT:\n        /* Ignore */\n        break;\n    }\n\n    if (err) {\n        error_report_err(err);\n    }\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-user.c", "func": "static int net_vhost_user_init(NetClientState *peer, const char *device,\n                               const char *name, Chardev *chr,\n                               int queues)\n{\n    Error *err = NULL;\n    NetClientState *nc, *nc0 = NULL;\n    NetVhostUserState *s = NULL;\n    VhostUserState *user;\n    int i;\n\n    assert(name);\n    assert(queues > 0);\n\n    user = g_new0(struct VhostUserState, 1);\n    for (i = 0; i < queues; i++) {\n        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);\n        snprintf(nc->info_str, sizeof(nc->info_str), \"vhost-user%d to %s\",\n                 i, chr->label);\n        nc->queue_index = i;\n        if (!nc0) {\n            nc0 = nc;\n            s = DO_UPCAST(NetVhostUserState, nc, nc);\n            if (!qemu_chr_fe_init(&s->chr, chr, &err) ||\n                !vhost_user_init(user, &s->chr, &err)) {\n                error_report_err(err);\n                goto err;\n            }\n        }\n        s = DO_UPCAST(NetVhostUserState, nc, nc);\n        s->vhost_user = user;\n    }\n\n    s = DO_UPCAST(NetVhostUserState, nc, nc0);\n    do {\n        if (qemu_chr_fe_wait_connected(&s->chr, &err) < 0) {\n            error_report_err(err);\n            goto err;\n        }\n        qemu_chr_fe_set_handlers(&s->chr, NULL, NULL,\n                                 net_vhost_user_event, NULL, nc0->name, NULL,\n                                 true);\n    } while (!s->started);\n\n    assert(s->vhost_net);\n\n    return 0;\n\nerr:\n    if (user) {\n        vhost_user_cleanup(user);\n        g_free(user);\n        if (s) {\n            s->vhost_user = NULL;\n        }\n    }\n    if (nc0) {\n        qemu_del_net_client(nc0);\n    }\n\n    return -1;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-user.c", "func": "static Chardev *net_vhost_claim_chardev(\n    const NetdevVhostUserOptions *opts, Error **errp)\n{\n    Chardev *chr = qemu_chr_find(opts->chardev);\n\n    if (chr == NULL) {\n        error_setg(errp, \"chardev \\\"%s\\\" not found\", opts->chardev);\n        return NULL;\n    }\n\n    if (!qemu_chr_has_feature(chr, QEMU_CHAR_FEATURE_RECONNECTABLE)) {\n        error_setg(errp, \"chardev \\\"%s\\\" is not reconnectable\",\n                   opts->chardev);\n        return NULL;\n    }\n    if (!qemu_chr_has_feature(chr, QEMU_CHAR_FEATURE_FD_PASS)) {\n        error_setg(errp, \"chardev \\\"%s\\\" does not support FD passing\",\n                   opts->chardev);\n        return NULL;\n    }\n\n    return chr;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-user.c", "func": "int net_init_vhost_user(const Netdev *netdev, const char *name,\n                        NetClientState *peer, Error **errp)\n{\n    int queues;\n    const NetdevVhostUserOptions *vhost_user_opts;\n    Chardev *chr;\n\n    assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER);\n    vhost_user_opts = &netdev->u.vhost_user;\n\n    chr = net_vhost_claim_chardev(vhost_user_opts, errp);\n    if (!chr) {\n        return -1;\n    }\n\n    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;\n    if (queues < 1 || queues > MAX_QUEUE_NUM) {\n        error_setg(errp,\n                   \"vhost-user number of queues must be in range [1, %d]\",\n                   MAX_QUEUE_NUM);\n        return -1;\n    }\n\n    return net_vhost_user_init(peer, \"vhost_user\", name, chr, queues);\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-vdpa.c", "func": "VHostNetState *vhost_vdpa_get_vhost_net(NetClientState *nc)\n{\n    VhostVDPAState *s = DO_UPCAST(VhostVDPAState, nc, nc);\n    assert(nc->info->type == NET_CLIENT_DRIVER_VHOST_VDPA);\n    return s->vhost_net;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-vdpa.c", "func": "static int vhost_vdpa_net_check_device_id(struct vhost_net *net)\n{\n    uint32_t device_id;\n    int ret;\n    struct vhost_dev *hdev;\n\n    hdev = (struct vhost_dev *)&net->dev;\n    ret = hdev->vhost_ops->vhost_get_device_id(hdev, &device_id);\n    if (device_id != VIRTIO_ID_NET) {\n        return -ENOTSUP;\n    }\n    return ret;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-vdpa.c", "func": "static int vhost_vdpa_add(NetClientState *ncs, void *be,\n                          int queue_pair_index, int nvqs)\n{\n    VhostNetOptions options;\n    struct vhost_net *net = NULL;\n    VhostVDPAState *s;\n    int ret;\n\n    options.backend_type = VHOST_BACKEND_TYPE_VDPA;\n    assert(ncs->info->type == NET_CLIENT_DRIVER_VHOST_VDPA);\n    s = DO_UPCAST(VhostVDPAState, nc, ncs);\n    options.net_backend = ncs;\n    options.opaque      = be;\n    options.busyloop_timeout = 0;\n    options.nvqs = nvqs;\n\n    net = vhost_net_init(&options);\n    if (!net) {\n        error_report(\"failed to init vhost_net for queue\");\n        goto err_init;\n    }\n    s->vhost_net = net;\n    ret = vhost_vdpa_net_check_device_id(net);\n    if (ret) {\n        goto err_check;\n    }\n    return 0;\nerr_check:\n    vhost_net_cleanup(net);\n    g_free(net);\nerr_init:\n    return -1;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-vdpa.c", "func": "static void vhost_vdpa_cleanup(NetClientState *nc)\n{\n    VhostVDPAState *s = DO_UPCAST(VhostVDPAState, nc, nc);\n\n    if (s->vhost_net) {\n        vhost_net_cleanup(s->vhost_net);\n        g_free(s->vhost_net);\n        s->vhost_net = NULL;\n    }\n     if (s->vhost_vdpa.device_fd >= 0) {\n        qemu_close(s->vhost_vdpa.device_fd);\n        s->vhost_vdpa.device_fd = -1;\n    }\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-vdpa.c", "func": "static bool vhost_vdpa_has_vnet_hdr(NetClientState *nc)\n{\n    assert(nc->info->type == NET_CLIENT_DRIVER_VHOST_VDPA);\n\n    return true;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-vdpa.c", "func": "static bool vhost_vdpa_has_ufo(NetClientState *nc)\n{\n    assert(nc->info->type == NET_CLIENT_DRIVER_VHOST_VDPA);\n    VhostVDPAState *s = DO_UPCAST(VhostVDPAState, nc, nc);\n    uint64_t features = 0;\n    features |= (1ULL << VIRTIO_NET_F_HOST_UFO);\n    features = vhost_net_get_features(s->vhost_net, features);\n    return !!(features & (1ULL << VIRTIO_NET_F_HOST_UFO));\n\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-vdpa.c", "func": "static bool vhost_vdpa_check_peer_type(NetClientState *nc, ObjectClass *oc,\n                                       Error **errp)\n{\n    const char *driver = object_class_get_name(oc);\n\n    if (!g_str_has_prefix(driver, \"virtio-net-\")) {\n        error_setg(errp, \"vhost-vdpa requires frontend driver virtio-net-*\");\n        return false;\n    }\n\n    return true;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-vdpa.c", "func": "static ssize_t vhost_vdpa_receive(NetClientState *nc, const uint8_t *buf,\n                                  size_t size)\n{\n    return 0;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-vdpa.c", "func": "static NetClientState *net_vhost_vdpa_init(NetClientState *peer,\n                                           const char *device,\n                                           const char *name,\n                                           int vdpa_device_fd,\n                                           int queue_pair_index,\n                                           int nvqs,\n                                           bool is_datapath)\n{\n    NetClientState *nc = NULL;\n    VhostVDPAState *s;\n    int ret = 0;\n    assert(name);\n    if (is_datapath) {\n        nc = qemu_new_net_client(&net_vhost_vdpa_info, peer, device,\n                                 name);\n    } else {\n        nc = qemu_new_net_control_client(&net_vhost_vdpa_info, peer,\n                                         device, name);\n    }\n    snprintf(nc->info_str, sizeof(nc->info_str), TYPE_VHOST_VDPA);\n    s = DO_UPCAST(VhostVDPAState, nc, nc);\n\n    s->vhost_vdpa.device_fd = vdpa_device_fd;\n    s->vhost_vdpa.index = queue_pair_index;\n    ret = vhost_vdpa_add(nc, (void *)&s->vhost_vdpa, queue_pair_index, nvqs);\n    if (ret) {\n        qemu_del_net_client(nc);\n        return NULL;\n    }\n    return nc;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-vdpa.c", "func": "static int vhost_vdpa_get_max_queue_pairs(int fd, int *has_cvq, Error **errp)\n{\n    unsigned long config_size = offsetof(struct vhost_vdpa_config, buf);\n    g_autofree struct vhost_vdpa_config *config = NULL;\n    __virtio16 *max_queue_pairs;\n    uint64_t features;\n    int ret;\n\n    ret = ioctl(fd, VHOST_GET_FEATURES, &features);\n    if (ret) {\n        error_setg(errp, \"Fail to query features from vhost-vDPA device\");\n        return ret;\n    }\n\n    if (features & (1 << VIRTIO_NET_F_CTRL_VQ)) {\n        *has_cvq = 1;\n    } else {\n        *has_cvq = 0;\n    }\n\n    if (features & (1 << VIRTIO_NET_F_MQ)) {\n        config = g_malloc0(config_size + sizeof(*max_queue_pairs));\n        config->off = offsetof(struct virtio_net_config, max_virtqueue_pairs);\n        config->len = sizeof(*max_queue_pairs);\n\n        ret = ioctl(fd, VHOST_VDPA_GET_CONFIG, config);\n        if (ret) {\n            error_setg(errp, \"Fail to get config from vhost-vDPA device\");\n            return -ret;\n        }\n\n        max_queue_pairs = (__virtio16 *)&config->buf;\n\n        return lduw_le_p(max_queue_pairs);\n    }\n\n    return 1;\n}\n", "label": "network"}
{"project": "qemu", "file": "vhost-vdpa.c", "func": "int net_init_vhost_vdpa(const Netdev *netdev, const char *name,\n                        NetClientState *peer, Error **errp)\n{\n    const NetdevVhostVDPAOptions *opts;\n    int vdpa_device_fd;\n    g_autofree NetClientState **ncs = NULL;\n    NetClientState *nc;\n    int queue_pairs, i, has_cvq = 0;\n\n    assert(netdev->type == NET_CLIENT_DRIVER_VHOST_VDPA);\n    opts = &netdev->u.vhost_vdpa;\n    if (!opts->vhostdev) {\n        error_setg(errp, \"vdpa character device not specified with vhostdev\");\n        return -1;\n    }\n\n    vdpa_device_fd = qemu_open(opts->vhostdev, O_RDWR, errp);\n    if (vdpa_device_fd == -1) {\n        return -errno;\n    }\n\n    queue_pairs = vhost_vdpa_get_max_queue_pairs(vdpa_device_fd,\n                                                 &has_cvq, errp);\n    if (queue_pairs < 0) {\n        qemu_close(vdpa_device_fd);\n        return queue_pairs;\n    }\n\n    ncs = g_malloc0(sizeof(*ncs) * queue_pairs);\n\n    for (i = 0; i < queue_pairs; i++) {\n        ncs[i] = net_vhost_vdpa_init(peer, TYPE_VHOST_VDPA, name,\n                                     vdpa_device_fd, i, 2, true);\n        if (!ncs[i])\n            goto err;\n    }\n\n    if (has_cvq) {\n        nc = net_vhost_vdpa_init(peer, TYPE_VHOST_VDPA, name,\n                                 vdpa_device_fd, i, 1, false);\n        if (!nc)\n            goto err;\n    }\n\n    return 0;\n\nerr:\n    if (i) {\n        for (i--; i >= 0; i--) {\n            qemu_del_net_client(ncs[i]);\n        }\n    }\n    qemu_close(vdpa_device_fd);\n\n    return -1;\n}\n", "label": "network"}
{"project": "qemu", "file": "vmnet-host.c", "func": "static bool validate_options(const Netdev *netdev, Error **errp)\n{\n    const NetdevVmnetHostOptions *options = &(netdev->u.vmnet_host);\n\n#if defined(MAC_OS_VERSION_11_0) && \\\n    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0\n\n    QemuUUID net_uuid;\n    if (options->has_net_uuid &&\n        qemu_uuid_parse(options->net_uuid, &net_uuid) < 0) {\n        error_setg(errp, \"Invalid UUID provided in 'net-uuid'\");\n        return false;\n    }\n#else\n    if (options->has_isolated) {\n        error_setg(errp,\n                   \"vmnet-host.isolated feature is \"\n                   \"unavailable: outdated vmnet.framework API\");\n        return false;\n    }\n\n    if (options->has_net_uuid) {\n        error_setg(errp,\n                   \"vmnet-host.net-uuid feature is \"\n                   \"unavailable: outdated vmnet.framework API\");\n        return false;\n    }\n#endif\n\n    if ((options->has_start_address ||\n         options->has_end_address ||\n         options->has_subnet_mask) &&\n        !(options->has_start_address &&\n          options->has_end_address &&\n          options->has_subnet_mask)) {\n        error_setg(errp,\n                   \"'start-address', 'end-address', 'subnet-mask' \"\n                   \"should be provided together\");\n        return false;\n    }\n\n    return true;\n}\n", "label": "network"}
{"project": "qemu", "file": "vmnet-host.c", "func": "static xpc_object_t build_if_desc(const Netdev *netdev)\n{\n    const NetdevVmnetHostOptions *options = &(netdev->u.vmnet_host);\n    xpc_object_t if_desc = xpc_dictionary_create(NULL, NULL, 0);\n\n    xpc_dictionary_set_uint64(if_desc,\n                              vmnet_operation_mode_key,\n                              VMNET_HOST_MODE);\n\n#if defined(MAC_OS_VERSION_11_0) && \\\n    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0\n\n    xpc_dictionary_set_bool(if_desc,\n                            vmnet_enable_isolation_key,\n                            options->isolated);\n\n    QemuUUID net_uuid;\n    if (options->has_net_uuid) {\n        qemu_uuid_parse(options->net_uuid, &net_uuid);\n        xpc_dictionary_set_uuid(if_desc,\n                                vmnet_network_identifier_key,\n                                net_uuid.data);\n    }\n#endif\n\n    if (options->has_start_address) {\n        xpc_dictionary_set_string(if_desc,\n                                  vmnet_start_address_key,\n                                  options->start_address);\n        xpc_dictionary_set_string(if_desc,\n                                  vmnet_end_address_key,\n                                  options->end_address);\n        xpc_dictionary_set_string(if_desc,\n                                  vmnet_subnet_mask_key,\n                                  options->subnet_mask);\n    }\n\n    return if_desc;\n}\n", "label": "network"}
{"project": "qemu", "file": "vmnet-host.c", "func": "int net_init_vmnet_host(const Netdev *netdev, const char *name,\n                        NetClientState *peer, Error **errp)\n{\n    NetClientState *nc = qemu_new_net_client(&net_vmnet_host_info,\n                                             peer, \"vmnet-host\", name);\n    xpc_object_t if_desc;\n    int result = -1;\n\n    if (!validate_options(netdev, errp)) {\n        return result;\n    }\n\n    if_desc = build_if_desc(netdev);\n    result = vmnet_if_create(nc, if_desc, errp);\n    xpc_release(if_desc);\n    return result;\n}\n", "label": "network"}
{"project": "qemu", "file": "vmnet-shared.c", "func": "static bool validate_options(const Netdev *netdev, Error **errp)\n{\n    const NetdevVmnetSharedOptions *options = &(netdev->u.vmnet_shared);\n\n#if !defined(MAC_OS_VERSION_11_0) || \\\n    MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_VERSION_11_0\n    if (options->has_isolated) {\n        error_setg(errp,\n                   \"vmnet-shared.isolated feature is \"\n                   \"unavailable: outdated vmnet.framework API\");\n        return false;\n    }\n#endif\n\n    if ((options->has_start_address ||\n         options->has_end_address ||\n         options->has_subnet_mask) &&\n        !(options->has_start_address &&\n          options->has_end_address &&\n          options->has_subnet_mask)) {\n        error_setg(errp,\n                   \"'start-address', 'end-address', 'subnet-mask' \"\n                   \"should be provided together\"\n        );\n        return false;\n    }\n\n    return true;\n}\n", "label": "network"}
{"project": "qemu", "file": "vmnet-shared.c", "func": "static xpc_object_t build_if_desc(const Netdev *netdev)\n{\n    const NetdevVmnetSharedOptions *options = &(netdev->u.vmnet_shared);\n    xpc_object_t if_desc = xpc_dictionary_create(NULL, NULL, 0);\n\n    xpc_dictionary_set_uint64(\n        if_desc,\n        vmnet_operation_mode_key,\n        VMNET_SHARED_MODE\n    );\n\n    if (options->has_nat66_prefix) {\n        xpc_dictionary_set_string(if_desc,\n                                  vmnet_nat66_prefix_key,\n                                  options->nat66_prefix);\n    }\n\n    if (options->has_start_address) {\n        xpc_dictionary_set_string(if_desc,\n                                  vmnet_start_address_key,\n                                  options->start_address);\n        xpc_dictionary_set_string(if_desc,\n                                  vmnet_end_address_key,\n                                  options->end_address);\n        xpc_dictionary_set_string(if_desc,\n                                  vmnet_subnet_mask_key,\n                                  options->subnet_mask);\n    }\n\n#if defined(MAC_OS_VERSION_11_0) && \\\n    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0\n    xpc_dictionary_set_bool(\n        if_desc,\n        vmnet_enable_isolation_key,\n        options->isolated\n    );\n#endif\n\n    return if_desc;\n}\n", "label": "network"}
{"project": "qemu", "file": "vmnet-shared.c", "func": "int net_init_vmnet_shared(const Netdev *netdev, const char *name,\n                          NetClientState *peer, Error **errp)\n{\n    NetClientState *nc = qemu_new_net_client(&net_vmnet_shared_info,\n                                             peer, \"vmnet-shared\", name);\n    xpc_object_t if_desc;\n    int result = -1;\n\n    if (!validate_options(netdev, errp)) {\n        return result;\n    }\n\n    if_desc = build_if_desc(netdev);\n    result = vmnet_if_create(nc, if_desc, errp);\n    xpc_release(if_desc);\n    return result;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_core.c", "func": "uint8_t can_dlc2len(uint8_t can_dlc)\n{\n    return dlc2len[can_dlc & 0x0F];\n}\n", "label": "network"}
{"project": "qemu", "file": "can_core.c", "func": "uint8_t can_len2dlc(uint8_t len)\n{\n    if (unlikely(len > 64)) {\n        return 0xF;\n    }\n\n    return len2dlc[len];\n}\n", "label": "network"}
{"project": "qemu", "file": "can_core.c", "func": "static void can_bus_instance_init(Object *object)\n{\n    CanBusState *bus = (CanBusState *)object;\n\n    QTAILQ_INIT(&bus->clients);\n}\n", "label": "network"}
{"project": "qemu", "file": "can_core.c", "func": "int can_bus_insert_client(CanBusState *bus, CanBusClientState *client)\n{\n    client->bus = bus;\n    QTAILQ_INSERT_TAIL(&bus->clients, client, next);\n    return 0;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_core.c", "func": "int can_bus_remove_client(CanBusClientState *client)\n{\n    CanBusState *bus = client->bus;\n    if (bus == NULL) {\n        return 0;\n    }\n\n    QTAILQ_REMOVE(&bus->clients, client, next);\n    client->bus = NULL;\n    return 1;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_core.c", "func": "ssize_t can_bus_client_send(CanBusClientState *client,\n             const struct qemu_can_frame *frames, size_t frames_cnt)\n{\n    int ret = 0;\n    CanBusState *bus = client->bus;\n    CanBusClientState *peer;\n    if (bus == NULL) {\n        return -1;\n    }\n\n    QTAILQ_FOREACH(peer, &bus->clients, next) {\n        if (peer->info->can_receive(peer)) {\n            if (peer == client) {\n                /* No loopback support for now */\n                continue;\n            }\n            if (peer->info->receive(peer, frames, frames_cnt) > 0) {\n                ret = 1;\n            }\n        }\n    }\n\n    return ret;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_core.c", "func": "int can_bus_filter_match(struct qemu_can_filter *filter, qemu_canid_t can_id)\n{\n    int m;\n    if (((can_id | filter->can_mask) & QEMU_CAN_ERR_FLAG)) {\n        return (filter->can_mask & QEMU_CAN_ERR_FLAG) != 0;\n    }\n    m = (can_id & filter->can_mask) == (filter->can_id & filter->can_mask);\n    return filter->can_id & QEMU_CAN_INV_FILTER ? !m : m;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_core.c", "func": "int can_bus_client_set_filters(CanBusClientState *client,\n             const struct qemu_can_filter *filters, size_t filters_cnt)\n{\n    return 0;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_core.c", "func": "static bool can_bus_can_be_deleted(UserCreatable *uc)\n{\n    return false;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_core.c", "func": "static void can_bus_class_init(ObjectClass *klass,\n                                void *class_data G_GNUC_UNUSED)\n{\n    UserCreatableClass *uc_klass = USER_CREATABLE_CLASS(klass);\n\n    uc_klass->can_be_deleted = can_bus_can_be_deleted;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_core.c", "func": "static void can_bus_register_types(void)\n{\n    type_register_static(&can_bus_info);\n}\n", "label": "network"}
{"project": "qemu", "file": "can_host.c", "func": "static void can_host_disconnect(CanHostState *ch)\n{\n    CanHostClass *chc = CAN_HOST_GET_CLASS(ch);\n\n    can_bus_remove_client(&ch->bus_client);\n    chc->disconnect(ch);\n}\n", "label": "network"}
{"project": "qemu", "file": "can_host.c", "func": "static void can_host_connect(CanHostState *ch, Error **errp)\n{\n    CanHostClass *chc = CAN_HOST_GET_CLASS(ch);\n    Error *local_err = NULL;\n\n    if (ch->bus == NULL) {\n        error_setg(errp, \"'canbus' property not set\");\n        return;\n    }\n\n    chc->connect(ch, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    can_bus_insert_client(ch->bus, &ch->bus_client);\n}\n", "label": "network"}
{"project": "qemu", "file": "can_host.c", "func": "static void can_host_unparent(Object *obj)\n{\n    can_host_disconnect(CAN_HOST(obj));\n}\n", "label": "network"}
{"project": "qemu", "file": "can_host.c", "func": "static void can_host_complete(UserCreatable *uc, Error **errp)\n{\n    can_host_connect(CAN_HOST(uc), errp);\n}\n", "label": "network"}
{"project": "qemu", "file": "can_host.c", "func": "static void can_host_class_init(ObjectClass *klass,\n                                void *class_data G_GNUC_UNUSED)\n{\n    UserCreatableClass *uc_klass = USER_CREATABLE_CLASS(klass);\n\n    object_class_property_add_link(klass, \"canbus\", TYPE_CAN_BUS,\n                                   offsetof(CanHostState, bus),\n                                   object_property_allow_set_link,\n                                   OBJ_PROP_LINK_STRONG);\n\n    klass->unparent = can_host_unparent;\n    uc_klass->complete = can_host_complete;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_host.c", "func": "static void can_host_register_types(void)\n{\n    type_register_static(&can_host_info);\n}\n", "label": "network"}
{"project": "qemu", "file": "can_socketcan.c", "func": "static void can_host_socketcan_display_msg(struct qemu_can_frame *msg)\n{\n    int i;\n    FILE *logfile = qemu_log_trylock();\n\n    if (logfile) {\n        fprintf(logfile, \"[cansocketcan]: %03X [%01d] %s %s\",\n                msg->can_id & QEMU_CAN_EFF_MASK,\n                msg->can_dlc,\n                msg->can_id & QEMU_CAN_EFF_FLAG ? \"EFF\" : \"SFF\",\n                msg->can_id & QEMU_CAN_RTR_FLAG ? \"RTR\" : \"DAT\");\n\n        for (i = 0; i < msg->can_dlc; i++) {\n            fprintf(logfile, \" %02X\", msg->data[i]);\n        }\n        fprintf(logfile, \"\\n\");\n        qemu_log_unlock(logfile);\n    }\n}\n", "label": "network"}
{"project": "qemu", "file": "can_socketcan.c", "func": "static void can_host_socketcan_read(void *opaque)\n{\n    CanHostSocketCAN *c = opaque;\n    CanHostState *ch = CAN_HOST(c);\n\n    /* CAN_READ_BUF_LEN for multiple messages syscall is possible for future */\n    c->bufcnt = read(c->fd, c->buf, sizeof(qemu_can_frame));\n    if (c->bufcnt < 0) {\n        warn_report(\"CAN bus host read failed (%s)\", strerror(errno));\n        return;\n    }\n\n    if (!ch->bus_client.fd_mode) {\n        c->buf[0].flags = 0;\n    } else {\n        if (c->bufcnt > CAN_MTU) {\n            c->buf[0].flags |= QEMU_CAN_FRMF_TYPE_FD;\n        }\n    }\n\n    can_bus_client_send(&ch->bus_client, c->buf, 1);\n\n    if (DEBUG_CAN) {\n        can_host_socketcan_display_msg(c->buf);\n    }\n}\n", "label": "network"}
{"project": "qemu", "file": "can_socketcan.c", "func": "static bool can_host_socketcan_can_receive(CanBusClientState *client)\n{\n    return true;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_socketcan.c", "func": "static ssize_t can_host_socketcan_receive(CanBusClientState *client,\n                            const qemu_can_frame *frames, size_t frames_cnt)\n{\n    CanHostState *ch = container_of(client, CanHostState, bus_client);\n    CanHostSocketCAN *c = CAN_HOST_SOCKETCAN(ch);\n\n    size_t len;\n    int res;\n\n    if (c->fd < 0) {\n        return -1;\n    }\n    if (frames->flags & QEMU_CAN_FRMF_TYPE_FD) {\n        if (!ch->bus_client.fd_mode) {\n            return 0;\n        }\n        len = CANFD_MTU;\n    } else {\n        len = CAN_MTU;\n\n    }\n\n    res = write(c->fd, frames, len);\n\n    if (!res) {\n        warn_report(\"[cansocketcan]: write message to host returns zero\");\n        return -1;\n    }\n\n    if (res != len) {\n        if (res < 0) {\n            warn_report(\"[cansocketcan]: write to host failed (%s)\",\n                        strerror(errno));\n        } else {\n            warn_report(\"[cansocketcan]: write to host truncated\");\n        }\n        return -1;\n    }\n\n    return 1;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_socketcan.c", "func": "static void can_host_socketcan_disconnect(CanHostState *ch)\n{\n    CanHostSocketCAN *c = CAN_HOST_SOCKETCAN(ch);\n\n    if (c->fd >= 0) {\n        qemu_set_fd_handler(c->fd, NULL, NULL, c);\n        close(c->fd);\n        c->fd = -1;\n    }\n\n    g_free(c->rfilter);\n    c->rfilter = NULL;\n    c->rfilter_num = 0;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_socketcan.c", "func": "static void can_host_socketcan_connect(CanHostState *ch, Error **errp)\n{\n    CanHostSocketCAN *c = CAN_HOST_SOCKETCAN(ch);\n    int s; /* can raw socket */\n    int mtu;\n    int enable_canfd = 1;\n    struct sockaddr_can addr;\n    struct ifreq ifr;\n\n    if (!c->ifname) {\n        error_setg(errp, \"'if' property not set\");\n        return;\n    }\n\n    /* open socket */\n    s = qemu_socket(PF_CAN, SOCK_RAW, CAN_RAW);\n    if (s < 0) {\n        error_setg_errno(errp, errno, \"failed to create CAN_RAW socket\");\n        return;\n    }\n\n    addr.can_family = AF_CAN;\n    memset(&ifr.ifr_name, 0, sizeof(ifr.ifr_name));\n    strcpy(ifr.ifr_name, c->ifname);\n    /* check if the frame fits into the CAN netdevice */\n    if (ioctl(s, SIOCGIFINDEX, &ifr) < 0) {\n        error_setg_errno(errp, errno,\n                         \"SocketCAN host interface %s not available\",\n                         c->ifname);\n        goto fail;\n    }\n    addr.can_ifindex = ifr.ifr_ifindex;\n\n    if (ioctl(s, SIOCGIFMTU, &ifr) < 0) {\n        error_setg_errno(errp, errno,\n                         \"SocketCAN host interface %s SIOCGIFMTU failed\",\n                         c->ifname);\n        goto fail;\n    }\n    mtu = ifr.ifr_mtu;\n\n    if (mtu >= CANFD_MTU) {\n        /* interface is ok - try to switch the socket into CAN FD mode */\n        if (setsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES,\n                        &enable_canfd, sizeof(enable_canfd))) {\n            warn_report(\"SocketCAN host interface %s enabling CAN FD failed\",\n                        c->ifname);\n        } else {\n            c->parent.bus_client.fd_mode = true;\n        }\n    }\n\n    c->err_mask = 0xffffffff; /* Receive error frame. */\n    setsockopt(s, SOL_CAN_RAW, CAN_RAW_ERR_FILTER,\n                   &c->err_mask, sizeof(c->err_mask));\n\n    c->rfilter_num = 1;\n    c->rfilter = g_new(struct qemu_can_filter, c->rfilter_num);\n\n    /* Receive all data frame. If |= CAN_INV_FILTER no data. */\n    c->rfilter[0].can_id = 0;\n    c->rfilter[0].can_mask = 0;\n    c->rfilter[0].can_mask &= ~CAN_ERR_FLAG;\n\n    setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, c->rfilter,\n               c->rfilter_num * sizeof(struct qemu_can_filter));\n\n    if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n        error_setg_errno(errp, errno, \"failed to bind to host interface %s\",\n                         c->ifname);\n        goto fail;\n    }\n\n    c->fd = s;\n    ch->bus_client.info = &can_host_socketcan_bus_client_info;\n    qemu_set_fd_handler(c->fd, can_host_socketcan_read, NULL, c);\n    return;\n\nfail:\n    close(s);\n    g_free(c->rfilter);\n    c->rfilter = NULL;\n    c->rfilter_num = 0;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_socketcan.c", "func": "static char *can_host_socketcan_get_if(Object *obj, Error **errp)\n{\n    CanHostSocketCAN *c = CAN_HOST_SOCKETCAN(obj);\n\n    return g_strdup(c->ifname);\n}\n", "label": "network"}
{"project": "qemu", "file": "can_socketcan.c", "func": "static void can_host_socketcan_set_if(Object *obj, const char *value,\n                                      Error **errp)\n{\n    CanHostSocketCAN *c = CAN_HOST_SOCKETCAN(obj);\n    struct ifreq ifr;\n\n    if (strlen(value) >= sizeof(ifr.ifr_name)) {\n        error_setg(errp, \"CAN interface name longer than %zd characters\",\n                   sizeof(ifr.ifr_name) - 1);\n        return;\n    }\n\n    if (c->fd != -1) {\n        error_setg(errp, \"CAN interface already connected\");\n        return;\n    }\n\n    g_free(c->ifname);\n    c->ifname = g_strdup(value);\n}\n", "label": "network"}
{"project": "qemu", "file": "can_socketcan.c", "func": "static void can_host_socketcan_instance_init(Object *obj)\n{\n    CanHostSocketCAN *c = CAN_HOST_SOCKETCAN(obj);\n\n    c->fd = -1;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_socketcan.c", "func": "static void can_host_socketcan_class_init(ObjectClass *klass,\n                                          void *class_data G_GNUC_UNUSED)\n{\n    CanHostClass *chc = CAN_HOST_CLASS(klass);\n\n    object_class_property_add_str(klass, \"if\",\n                                  can_host_socketcan_get_if,\n                                  can_host_socketcan_set_if);\n    chc->connect = can_host_socketcan_connect;\n    chc->disconnect = can_host_socketcan_disconnect;\n}\n", "label": "network"}
{"project": "qemu", "file": "can_socketcan.c", "func": "static void can_host_register_types(void)\n{\n    type_register_static(&can_host_socketcan_info);\n}\n", "label": "network"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_write_pixels_copy(VncState *vs,\n                                  void *pixels, int size)\n{\n    vnc_write(vs, pixels, size);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_convert_pixel(VncState *vs, uint8_t *buf, uint32_t v)\n{\n    uint8_t r, g, b;\n\n#if VNC_SERVER_FB_FORMAT == PIXMAN_FORMAT(32, PIXMAN_TYPE_ARGB, 0, 8, 8, 8)\n    r = (((v & 0x00ff0000) >> 16) << vs->client_pf.rbits) >> 8;\n    g = (((v & 0x0000ff00) >>  8) << vs->client_pf.gbits) >> 8;\n    b = (((v & 0x000000ff) >>  0) << vs->client_pf.bbits) >> 8;\n#else\n# error need some bits here if you change VNC_SERVER_FB_FORMAT\n#endif\n    v = (r << vs->client_pf.rshift) |\n        (g << vs->client_pf.gshift) |\n        (b << vs->client_pf.bshift);\n    switch (vs->client_pf.bytes_per_pixel) {\n    case 1:\n        buf[0] = v;\n        break;\n    case 2:\n        if (vs->client_be) {\n            buf[0] = v >> 8;\n            buf[1] = v;\n        } else {\n            buf[1] = v >> 8;\n            buf[0] = v;\n        }\n        break;\n    default:\n    case 4:\n        if (vs->client_be) {\n            buf[0] = v >> 24;\n            buf[1] = v >> 16;\n            buf[2] = v >> 8;\n            buf[3] = v;\n        } else {\n            buf[3] = v >> 24;\n            buf[2] = v >> 16;\n            buf[1] = v >> 8;\n            buf[0] = v;\n        }\n        break;\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_write_pixels_generic(VncState *vs,\n                                     void *pixels1, int size)\n{\n    uint8_t buf[4];\n\n    if (VNC_SERVER_FB_BYTES == 4) {\n        uint32_t *pixels = pixels1;\n        int n, i;\n        n = size >> 2;\n        for (i = 0; i < n; i++) {\n            vnc_convert_pixel(vs, buf, pixels[i]);\n            vnc_write(vs, buf, vs->client_pf.bytes_per_pixel);\n        }\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "int vnc_raw_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    int i;\n    uint8_t *row;\n    VncDisplay *vd = vs->vd;\n\n    row = vnc_server_fb_ptr(vd, x, y);\n    for (i = 0; i < h; i++) {\n        vs->write_pixels(vs, row, w * VNC_SERVER_FB_BYTES);\n        row += vnc_server_fb_stride(vd);\n    }\n    return 1;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "int vnc_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    int n = 0;\n\n    switch(vs->vnc_encoding) {\n        case VNC_ENCODING_ZLIB:\n            n = vnc_zlib_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_HEXTILE:\n            vnc_framebuffer_update(vs, x, y, w, h, VNC_ENCODING_HEXTILE);\n            n = vnc_hextile_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_TIGHT:\n            n = vnc_tight_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_TIGHT_PNG:\n            n = vnc_tight_png_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_ZRLE:\n            n = vnc_zrle_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_ZYWRLE:\n            n = vnc_zywrle_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        default:\n            vnc_framebuffer_update(vs, x, y, w, h, VNC_ENCODING_RAW);\n            n = vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n            break;\n    }\n    return n;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_mouse_set(DisplayChangeListener *dcl,\n                          int x, int y, int visible)\n{\n    /* can we ask the client(s) to move the pointer ??? */\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int vnc_cursor_define(VncState *vs)\n{\n    QEMUCursor *c = vs->vd->cursor;\n    int isize;\n\n    if (!vs->vd->cursor) {\n        return -1;\n    }\n\n    if (vnc_has_feature(vs, VNC_FEATURE_ALPHA_CURSOR)) {\n        vnc_lock_output(vs);\n        vnc_write_u8(vs,  VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs,  0);  /*  padding     */\n        vnc_write_u16(vs, 1);  /*  # of rects  */\n        vnc_framebuffer_update(vs, c->hot_x, c->hot_y, c->width, c->height,\n                               VNC_ENCODING_ALPHA_CURSOR);\n        vnc_write_s32(vs, VNC_ENCODING_RAW);\n        vnc_write(vs, c->data, c->width * c->height * 4);\n        vnc_unlock_output(vs);\n        return 0;\n    }\n    if (vnc_has_feature(vs, VNC_FEATURE_RICH_CURSOR)) {\n        vnc_lock_output(vs);\n        vnc_write_u8(vs,  VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs,  0);  /*  padding     */\n        vnc_write_u16(vs, 1);  /*  # of rects  */\n        vnc_framebuffer_update(vs, c->hot_x, c->hot_y, c->width, c->height,\n                               VNC_ENCODING_RICH_CURSOR);\n        isize = c->width * c->height * vs->client_pf.bytes_per_pixel;\n        vnc_write_pixels_generic(vs, c->data, isize);\n        vnc_write(vs, vs->vd->cursor_mask, vs->vd->cursor_msize);\n        vnc_unlock_output(vs);\n        return 0;\n    }\n    return -1;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_dpy_cursor_define(DisplayChangeListener *dcl,\n                                  QEMUCursor *c)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs;\n\n    cursor_put(vd->cursor);\n    g_free(vd->cursor_mask);\n\n    vd->cursor = c;\n    cursor_get(vd->cursor);\n    vd->cursor_msize = cursor_get_mono_bpl(c) * c->height;\n    vd->cursor_mask = g_malloc0(vd->cursor_msize);\n    cursor_get_mono_mask(c, 0, vd->cursor_mask);\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_cursor_define(vs);\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int find_and_clear_dirty_height(VncState *vs,\n                                       int y, int last_x, int x, int height)\n{\n    int h;\n\n    for (h = 1; h < (height - y); h++) {\n        if (!test_bit(last_x, vs->dirty[y + h])) {\n            break;\n        }\n        bitmap_clear(vs->dirty[y + h], last_x, x - last_x);\n    }\n\n    return h;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_update_throttle_offset(VncState *vs)\n{\n    size_t offset =\n        vs->client_width * vs->client_height * vs->client_pf.bytes_per_pixel;\n\n    if (vs->audio_cap) {\n        int bps;\n        switch (vs->as.fmt) {\n        default:\n        case  AUDIO_FORMAT_U8:\n        case  AUDIO_FORMAT_S8:\n            bps = 1;\n            break;\n        case  AUDIO_FORMAT_U16:\n        case  AUDIO_FORMAT_S16:\n            bps = 2;\n            break;\n        case  AUDIO_FORMAT_U32:\n        case  AUDIO_FORMAT_S32:\n            bps = 4;\n            break;\n        }\n        offset += vs->as.freq * bps * vs->as.nchannels;\n    }\n\n    /* Put a floor of 1MB on offset, so that if we have a large pending\n     * buffer and the display is resized to a small size & back again\n     * we don't suddenly apply a tiny send limit\n     */\n    offset = MAX(offset, 1024 * 1024);\n\n    if (vs->throttle_output_offset != offset) {\n        trace_vnc_client_throttle_threshold(\n            vs, vs->ioc, vs->throttle_output_offset, offset, vs->client_width,\n            vs->client_height, vs->client_pf.bytes_per_pixel, vs->audio_cap);\n    }\n\n    vs->throttle_output_offset = offset;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static bool vnc_should_update(VncState *vs)\n{\n    switch (vs->update) {\n    case VNC_STATE_UPDATE_NONE:\n        break;\n    case VNC_STATE_UPDATE_INCREMENTAL:\n        /* Only allow incremental updates if the pending send queue\n         * is less than the permitted threshold, and the job worker\n         * is completely idle.\n         */\n        if (vs->output.offset < vs->throttle_output_offset &&\n            vs->job_update == VNC_STATE_UPDATE_NONE) {\n            return true;\n        }\n        trace_vnc_client_throttle_incremental(\n            vs, vs->ioc, vs->job_update, vs->output.offset);\n        break;\n    case VNC_STATE_UPDATE_FORCE:\n        /* Only allow forced updates if the pending send queue\n         * does not contain a previous forced update, and the\n         * job worker is completely idle.\n         *\n         * Note this means we'll queue a forced update, even if\n         * the output buffer size is otherwise over the throttle\n         * output limit.\n         */\n        if (vs->force_update_offset == 0 &&\n            vs->job_update == VNC_STATE_UPDATE_NONE) {\n            return true;\n        }\n        trace_vnc_client_throttle_forced(\n            vs, vs->ioc, vs->job_update, vs->force_update_offset);\n        break;\n    }\n    return false;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int vnc_update_client(VncState *vs, int has_dirty)\n{\n    VncDisplay *vd = vs->vd;\n    VncJob *job;\n    int y;\n    int height, width;\n    int n = 0;\n\n    if (vs->disconnecting) {\n        vnc_disconnect_finish(vs);\n        return 0;\n    }\n\n    vs->has_dirty += has_dirty;\n    if (!vnc_should_update(vs)) {\n        return 0;\n    }\n\n    if (!vs->has_dirty && vs->update != VNC_STATE_UPDATE_FORCE) {\n        return 0;\n    }\n\n    /*\n     * Send screen updates to the vnc client using the server\n     * surface and server dirty map.  guest surface updates\n     * happening in parallel don't disturb us, the next pass will\n     * send them to the client.\n     */\n    job = vnc_job_new(vs);\n\n    height = pixman_image_get_height(vd->server);\n    width = pixman_image_get_width(vd->server);\n\n    y = 0;\n    for (;;) {\n        int x, h;\n        unsigned long x2;\n        unsigned long offset = find_next_bit((unsigned long *) &vs->dirty,\n                                             height * VNC_DIRTY_BPL(vs),\n                                             y * VNC_DIRTY_BPL(vs));\n        if (offset == height * VNC_DIRTY_BPL(vs)) {\n            /* no more dirty bits */\n            break;\n        }\n        y = offset / VNC_DIRTY_BPL(vs);\n        x = offset % VNC_DIRTY_BPL(vs);\n        x2 = find_next_zero_bit((unsigned long *) &vs->dirty[y],\n                                VNC_DIRTY_BPL(vs), x);\n        bitmap_clear(vs->dirty[y], x, x2 - x);\n        h = find_and_clear_dirty_height(vs, y, x, x2, height);\n        x2 = MIN(x2, width / VNC_DIRTY_PIXELS_PER_BIT);\n        if (x2 > x) {\n            n += vnc_job_add_rect(job, x * VNC_DIRTY_PIXELS_PER_BIT, y,\n                                  (x2 - x) * VNC_DIRTY_PIXELS_PER_BIT, h);\n        }\n        if (!x && x2 == width / VNC_DIRTY_PIXELS_PER_BIT) {\n            y += h;\n            if (y == height) {\n                break;\n            }\n        }\n    }\n\n    vs->job_update = vs->update;\n    vs->update = VNC_STATE_UPDATE_NONE;\n    vnc_job_push(job);\n    vs->has_dirty = 0;\n    return n;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void audio_capture_notify(void *opaque, audcnotification_e cmd)\n{\n    VncState *vs = opaque;\n\n    assert(vs->magic == VNC_MAGIC);\n    switch (cmd) {\n    case AUD_CNOTIFY_DISABLE:\n        trace_vnc_msg_server_audio_end(vs, vs->ioc);\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n        vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_END);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n        break;\n\n    case AUD_CNOTIFY_ENABLE:\n        trace_vnc_msg_server_audio_begin(vs, vs->ioc);\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n        vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_BEGIN);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n        break;\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void audio_capture_destroy(void *opaque)\n{\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void audio_capture(void *opaque, const void *buf, int size)\n{\n    VncState *vs = opaque;\n\n    assert(vs->magic == VNC_MAGIC);\n    trace_vnc_msg_server_audio_data(vs, vs->ioc, buf, size);\n    vnc_lock_output(vs);\n    if (vs->output.offset < vs->throttle_output_offset) {\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n        vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_DATA);\n        vnc_write_u32(vs, size);\n        vnc_write(vs, buf, size);\n    } else {\n        trace_vnc_client_throttle_audio(vs, vs->ioc, vs->output.offset);\n    }\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void audio_add(VncState *vs)\n{\n    struct audio_capture_ops ops;\n\n    if (vs->audio_cap) {\n        error_report(\"audio already running\");\n        return;\n    }\n\n    ops.notify = audio_capture_notify;\n    ops.destroy = audio_capture_destroy;\n    ops.capture = audio_capture;\n\n    vs->audio_cap = AUD_add_capture(vs->vd->audio_state, &vs->as, &ops, vs);\n    if (!vs->audio_cap) {\n        error_report(\"Failed to add audio capture\");\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void audio_del(VncState *vs)\n{\n    if (vs->audio_cap) {\n        AUD_del_capture(vs->audio_cap, vs);\n        vs->audio_cap = NULL;\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_disconnect_start(VncState *vs)\n{\n    if (vs->disconnecting) {\n        return;\n    }\n    trace_vnc_client_disconnect_start(vs, vs->ioc);\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_DISCONNECTED);\n    if (vs->ioc_tag) {\n        g_source_remove(vs->ioc_tag);\n        vs->ioc_tag = 0;\n    }\n    qio_channel_close(vs->ioc, NULL);\n    vs->disconnecting = TRUE;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_disconnect_finish(VncState *vs)\n{\n    int i;\n\n    trace_vnc_client_disconnect_finish(vs, vs->ioc);\n\n    vnc_jobs_join(vs); /* Wait encoding jobs */\n\n    vnc_lock_output(vs);\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_DISCONNECTED);\n\n    buffer_free(&vs->input);\n    buffer_free(&vs->output);\n\n    qapi_free_VncClientInfo(vs->info);\n\n    vnc_zlib_clear(vs);\n    vnc_tight_clear(vs);\n    vnc_zrle_clear(vs);\n\n#ifdef CONFIG_VNC_SASL\n    vnc_sasl_client_cleanup(vs);\n#endif /* CONFIG_VNC_SASL */\n    audio_del(vs);\n    qkbd_state_lift_all_keys(vs->vd->kbd);\n\n    if (vs->mouse_mode_notifier.notify != NULL) {\n        qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n    }\n    QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n    if (QTAILQ_EMPTY(&vs->vd->clients)) {\n        /* last client gone */\n        vnc_update_server_surface(vs->vd);\n    }\n    vnc_unlock_output(vs);\n\n    if (vs->cbpeer.notifier.notify) {\n        qemu_clipboard_peer_unregister(&vs->cbpeer);\n    }\n\n    qemu_mutex_destroy(&vs->output_mutex);\n    if (vs->bh != NULL) {\n        qemu_bh_delete(vs->bh);\n    }\n    buffer_free(&vs->jobs_buffer);\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n        g_free(vs->lossy_rect[i]);\n    }\n    g_free(vs->lossy_rect);\n\n    object_unref(OBJECT(vs->ioc));\n    vs->ioc = NULL;\n    object_unref(OBJECT(vs->sioc));\n    vs->sioc = NULL;\n    vs->magic = 0;\n    g_free(vs->zrle);\n    g_free(vs->tight);\n    g_free(vs);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "size_t vnc_client_io_error(VncState *vs, ssize_t ret, Error *err)\n{\n    if (ret <= 0) {\n        if (ret == 0) {\n            trace_vnc_client_eof(vs, vs->ioc);\n            vnc_disconnect_start(vs);\n        } else if (ret != QIO_CHANNEL_ERR_BLOCK) {\n            trace_vnc_client_io_error(vs, vs->ioc,\n                                      err ? error_get_pretty(err) : \"Unknown\");\n            vnc_disconnect_start(vs);\n        }\n\n        error_free(err);\n        return 0;\n    }\n    return ret;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_client_error(VncState *vs)\n{\n    VNC_DEBUG(\"Closing down client sock: protocol error\\n\");\n    vnc_disconnect_start(vs);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "size_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n{\n    Error *err = NULL;\n    ssize_t ret;\n    ret = qio_channel_write(vs->ioc, (const char *)data, datalen, &err);\n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n    return vnc_client_io_error(vs, ret, err);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static size_t vnc_client_write_plain(VncState *vs)\n{\n    size_t offset;\n    size_t ret;\n\n#ifdef CONFIG_VNC_SASL\n    VNC_DEBUG(\"Write Plain: Pending output %p size %zd offset %zd. Wait SSF %d\\n\",\n              vs->output.buffer, vs->output.capacity, vs->output.offset,\n              vs->sasl.waitWriteSSF);\n\n    if (vs->sasl.conn &&\n        vs->sasl.runSSF &&\n        vs->sasl.waitWriteSSF) {\n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->sasl.waitWriteSSF);\n        if (ret)\n            vs->sasl.waitWriteSSF -= ret;\n    } else\n#endif /* CONFIG_VNC_SASL */\n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->output.offset);\n    if (!ret)\n        return 0;\n\n    if (ret >= vs->force_update_offset) {\n        if (vs->force_update_offset != 0) {\n            trace_vnc_client_unthrottle_forced(vs, vs->ioc);\n        }\n        vs->force_update_offset = 0;\n    } else {\n        vs->force_update_offset -= ret;\n    }\n    offset = vs->output.offset;\n    buffer_advance(&vs->output, ret);\n    if (offset >= vs->throttle_output_offset &&\n        vs->output.offset < vs->throttle_output_offset) {\n        trace_vnc_client_unthrottle_incremental(vs, vs->ioc, vs->output.offset);\n    }\n\n    if (vs->output.offset == 0) {\n        if (vs->ioc_tag) {\n            g_source_remove(vs->ioc_tag);\n        }\n        vs->ioc_tag = qio_channel_add_watch(\n            vs->ioc, G_IO_IN | G_IO_HUP | G_IO_ERR,\n            vnc_client_io, vs, NULL);\n    }\n\n    return ret;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_client_write_locked(VncState *vs)\n{\n#ifdef CONFIG_VNC_SASL\n    if (vs->sasl.conn &&\n        vs->sasl.runSSF &&\n        !vs->sasl.waitWriteSSF) {\n        vnc_client_write_sasl(vs);\n    } else\n#endif /* CONFIG_VNC_SASL */\n    {\n        vnc_client_write_plain(vs);\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_client_write(VncState *vs)\n{\n    assert(vs->magic == VNC_MAGIC);\n    vnc_lock_output(vs);\n    if (vs->output.offset) {\n        vnc_client_write_locked(vs);\n    } else if (vs->ioc != NULL) {\n        if (vs->ioc_tag) {\n            g_source_remove(vs->ioc_tag);\n        }\n        vs->ioc_tag = qio_channel_add_watch(\n            vs->ioc, G_IO_IN | G_IO_HUP | G_IO_ERR,\n            vnc_client_io, vs, NULL);\n    }\n    vnc_unlock_output(vs);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_read_when(VncState *vs, VncReadEvent *func, size_t expecting)\n{\n    vs->read_handler = func;\n    vs->read_handler_expect = expecting;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "size_t vnc_client_read_buf(VncState *vs, uint8_t *data, size_t datalen)\n{\n    ssize_t ret;\n    Error *err = NULL;\n    ret = qio_channel_read(vs->ioc, (char *)data, datalen, &err);\n    VNC_DEBUG(\"Read wire %p %zd -> %ld\\n\", data, datalen, ret);\n    return vnc_client_io_error(vs, ret, err);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static size_t vnc_client_read_plain(VncState *vs)\n{\n    size_t ret;\n    VNC_DEBUG(\"Read plain %p size %zd offset %zd\\n\",\n              vs->input.buffer, vs->input.capacity, vs->input.offset);\n    buffer_reserve(&vs->input, 4096);\n    ret = vnc_client_read_buf(vs, buffer_end(&vs->input), 4096);\n    if (!ret)\n        return 0;\n    vs->input.offset += ret;\n    return ret;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_jobs_bh(void *opaque)\n{\n    VncState *vs = opaque;\n\n    assert(vs->magic == VNC_MAGIC);\n    vnc_jobs_consume_buffer(vs);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int vnc_client_read(VncState *vs)\n{\n    size_t ret;\n\n#ifdef CONFIG_VNC_SASL\n    if (vs->sasl.conn && vs->sasl.runSSF)\n        ret = vnc_client_read_sasl(vs);\n    else\n#endif /* CONFIG_VNC_SASL */\n        ret = vnc_client_read_plain(vs);\n    if (!ret) {\n        if (vs->disconnecting) {\n            vnc_disconnect_finish(vs);\n            return -1;\n        }\n        return 0;\n    }\n\n    while (vs->read_handler && vs->input.offset >= vs->read_handler_expect) {\n        size_t len = vs->read_handler_expect;\n        int ret;\n\n        ret = vs->read_handler(vs, vs->input.buffer, len);\n        if (vs->disconnecting) {\n            vnc_disconnect_finish(vs);\n            return -1;\n        }\n\n        if (!ret) {\n            buffer_advance(&vs->input, len);\n        } else {\n            vs->read_handler_expect = ret;\n        }\n    }\n    return 0;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "gboolean vnc_client_io(QIOChannel *ioc G_GNUC_UNUSED,\n                       GIOCondition condition, void *opaque)\n{\n    VncState *vs = opaque;\n\n    assert(vs->magic == VNC_MAGIC);\n\n    if (condition & (G_IO_HUP | G_IO_ERR)) {\n        vnc_disconnect_start(vs);\n        return TRUE;\n    }\n\n    if (condition & G_IO_IN) {\n        if (vnc_client_read(vs) < 0) {\n            /* vs is free()ed here */\n            return TRUE;\n        }\n    }\n    if (condition & G_IO_OUT) {\n        vnc_client_write(vs);\n    }\n\n    if (vs->disconnecting) {\n        if (vs->ioc_tag != 0) {\n            g_source_remove(vs->ioc_tag);\n        }\n        vs->ioc_tag = 0;\n    }\n    return TRUE;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_write(VncState *vs, const void *data, size_t len)\n{\n    assert(vs->magic == VNC_MAGIC);\n    if (vs->disconnecting) {\n        return;\n    }\n    /* Protection against malicious client/guest to prevent our output\n     * buffer growing without bound if client stops reading data. This\n     * should rarely trigger, because we have earlier throttling code\n     * which stops issuing framebuffer updates and drops audio data\n     * if the throttle_output_offset value is exceeded. So we only reach\n     * this higher level if a huge number of pseudo-encodings get\n     * triggered while data can't be sent on the socket.\n     *\n     * NB throttle_output_offset can be zero during early protocol\n     * handshake, or from the job thread's VncState clone\n     */\n    if (vs->throttle_output_offset != 0 &&\n        (vs->output.offset / VNC_THROTTLE_OUTPUT_LIMIT_SCALE) >\n        vs->throttle_output_offset) {\n        trace_vnc_client_output_limit(vs, vs->ioc, vs->output.offset,\n                                      vs->throttle_output_offset);\n        vnc_disconnect_start(vs);\n        return;\n    }\n    buffer_reserve(&vs->output, len);\n\n    if (vs->ioc != NULL && buffer_empty(&vs->output)) {\n        if (vs->ioc_tag) {\n            g_source_remove(vs->ioc_tag);\n        }\n        vs->ioc_tag = qio_channel_add_watch(\n            vs->ioc, G_IO_IN | G_IO_HUP | G_IO_ERR | G_IO_OUT,\n            vnc_client_io, vs, NULL);\n    }\n\n    buffer_append(&vs->output, data, len);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_write_s32(VncState *vs, int32_t value)\n{\n    vnc_write_u32(vs, *(uint32_t *)&value);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_write_u32(VncState *vs, uint32_t value)\n{\n    uint8_t buf[4];\n\n    buf[0] = (value >> 24) & 0xFF;\n    buf[1] = (value >> 16) & 0xFF;\n    buf[2] = (value >>  8) & 0xFF;\n    buf[3] = value & 0xFF;\n\n    vnc_write(vs, buf, 4);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_write_u16(VncState *vs, uint16_t value)\n{\n    uint8_t buf[2];\n\n    buf[0] = (value >> 8) & 0xFF;\n    buf[1] = value & 0xFF;\n\n    vnc_write(vs, buf, 2);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_write_u8(VncState *vs, uint8_t value)\n{\n    vnc_write(vs, (char *)&value, 1);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_flush(VncState *vs)\n{\n    vnc_lock_output(vs);\n    if (vs->ioc != NULL && vs->output.offset) {\n        vnc_client_write_locked(vs);\n    }\n    if (vs->disconnecting) {\n        if (vs->ioc_tag != 0) {\n            g_source_remove(vs->ioc_tag);\n        }\n        vs->ioc_tag = 0;\n    }\n    vnc_unlock_output(vs);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static uint8_t read_u8(uint8_t *data, size_t offset)\n{\n    return data[offset];\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static uint16_t read_u16(uint8_t *data, size_t offset)\n{\n    return ((data[offset] & 0xFF) << 8) | (data[offset + 1] & 0xFF);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int32_t read_s32(uint8_t *data, size_t offset)\n{\n    return (int32_t)((data[offset] << 24) | (data[offset + 1] << 16) |\n                     (data[offset + 2] << 8) | data[offset + 3]);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "uint32_t read_u32(uint8_t *data, size_t offset)\n{\n    return ((data[offset] << 24) | (data[offset + 1] << 16) |\n            (data[offset + 2] << 8) | data[offset + 3]);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void check_pointer_type_change(Notifier *notifier, void *data)\n{\n    VncState *vs = container_of(notifier, VncState, mouse_mode_notifier);\n    int absolute = qemu_input_is_absolute();\n\n    if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE) && vs->absolute != absolute) {\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs, 0);\n        vnc_write_u16(vs, 1);\n        vnc_framebuffer_update(vs, absolute, 0,\n                               pixman_image_get_width(vs->vd->server),\n                               pixman_image_get_height(vs->vd->server),\n                               VNC_ENCODING_POINTER_TYPE_CHANGE);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    }\n    vs->absolute = absolute;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void pointer_event(VncState *vs, int button_mask, int x, int y)\n{\n    static uint32_t bmap[INPUT_BUTTON__MAX] = {\n        [INPUT_BUTTON_LEFT]       = 0x01,\n        [INPUT_BUTTON_MIDDLE]     = 0x02,\n        [INPUT_BUTTON_RIGHT]      = 0x04,\n        [INPUT_BUTTON_WHEEL_UP]   = 0x08,\n        [INPUT_BUTTON_WHEEL_DOWN] = 0x10,\n    };\n    QemuConsole *con = vs->vd->dcl.con;\n    int width = pixman_image_get_width(vs->vd->server);\n    int height = pixman_image_get_height(vs->vd->server);\n\n    if (vs->last_bmask != button_mask) {\n        qemu_input_update_buttons(con, bmap, vs->last_bmask, button_mask);\n        vs->last_bmask = button_mask;\n    }\n\n    if (vs->absolute) {\n        qemu_input_queue_abs(con, INPUT_AXIS_X, x, 0, width);\n        qemu_input_queue_abs(con, INPUT_AXIS_Y, y, 0, height);\n    } else if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE)) {\n        qemu_input_queue_rel(con, INPUT_AXIS_X, x - 0x7FFF);\n        qemu_input_queue_rel(con, INPUT_AXIS_Y, y - 0x7FFF);\n    } else {\n        if (vs->last_x != -1) {\n            qemu_input_queue_rel(con, INPUT_AXIS_X, x - vs->last_x);\n            qemu_input_queue_rel(con, INPUT_AXIS_Y, y - vs->last_y);\n        }\n        vs->last_x = x;\n        vs->last_y = y;\n    }\n    qemu_input_event_sync();\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void press_key(VncState *vs, QKeyCode qcode)\n{\n    qkbd_state_key_event(vs->vd->kbd, qcode, true);\n    qkbd_state_key_event(vs->vd->kbd, qcode, false);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_led_state_change(VncState *vs)\n{\n    if (!vnc_has_feature(vs, VNC_FEATURE_LED_STATE)) {\n        return;\n    }\n\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1);\n    vnc_framebuffer_update(vs, 0, 0, 1, 1, VNC_ENCODING_LED_STATE);\n    vnc_write_u8(vs, vs->vd->ledstate);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void kbd_leds(void *opaque, int ledstate)\n{\n    VncDisplay *vd = opaque;\n    VncState *client;\n\n    trace_vnc_key_guest_leds((ledstate & QEMU_CAPS_LOCK_LED),\n                             (ledstate & QEMU_NUM_LOCK_LED),\n                             (ledstate & QEMU_SCROLL_LOCK_LED));\n\n    if (ledstate == vd->ledstate) {\n        return;\n    }\n\n    vd->ledstate = ledstate;\n\n    QTAILQ_FOREACH(client, &vd->clients, next) {\n        vnc_led_state_change(client);\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void do_key_event(VncState *vs, int down, int keycode, int sym)\n{\n    QKeyCode qcode = qemu_input_key_number_to_qcode(keycode);\n\n    /* QEMU console switch */\n    switch (qcode) {\n    case Q_KEY_CODE_1 ... Q_KEY_CODE_9: /* '1' to '9' keys */\n        if (vs->vd->dcl.con == NULL && down &&\n            qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_CTRL) &&\n            qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_ALT)) {\n            /* Reset the modifiers sent to the current console */\n            qkbd_state_lift_all_keys(vs->vd->kbd);\n            console_select(qcode - Q_KEY_CODE_1);\n            return;\n        }\n    default:\n        break;\n    }\n\n    /* Turn off the lock state sync logic if the client support the led\n       state extension.\n    */\n    if (down && vs->vd->lock_key_sync &&\n        !vnc_has_feature(vs, VNC_FEATURE_LED_STATE) &&\n        keycode_is_keypad(vs->vd->kbd_layout, keycode)) {\n        /* If the numlock state needs to change then simulate an additional\n           keypress before sending this one.  This will happen if the user\n           toggles numlock away from the VNC window.\n        */\n        if (keysym_is_numlock(vs->vd->kbd_layout, sym & 0xFFFF)) {\n            if (!qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_NUMLOCK)) {\n                trace_vnc_key_sync_numlock(true);\n                press_key(vs, Q_KEY_CODE_NUM_LOCK);\n            }\n        } else {\n            if (qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_NUMLOCK)) {\n                trace_vnc_key_sync_numlock(false);\n                press_key(vs, Q_KEY_CODE_NUM_LOCK);\n            }\n        }\n    }\n\n    if (down && vs->vd->lock_key_sync &&\n        !vnc_has_feature(vs, VNC_FEATURE_LED_STATE) &&\n        ((sym >= 'A' && sym <= 'Z') || (sym >= 'a' && sym <= 'z'))) {\n        /* If the capslock state needs to change then simulate an additional\n           keypress before sending this one.  This will happen if the user\n           toggles capslock away from the VNC window.\n        */\n        int uppercase = !!(sym >= 'A' && sym <= 'Z');\n        bool shift = qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_SHIFT);\n        bool capslock = qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_CAPSLOCK);\n        if (capslock) {\n            if (uppercase == shift) {\n                trace_vnc_key_sync_capslock(false);\n                press_key(vs, Q_KEY_CODE_CAPS_LOCK);\n            }\n        } else {\n            if (uppercase != shift) {\n                trace_vnc_key_sync_capslock(true);\n                press_key(vs, Q_KEY_CODE_CAPS_LOCK);\n            }\n        }\n    }\n\n    qkbd_state_key_event(vs->vd->kbd, qcode, down);\n    if (!qemu_console_is_graphic(NULL)) {\n        bool numlock = qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_NUMLOCK);\n        bool control = qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_CTRL);\n        /* QEMU console emulation */\n        if (down) {\n            switch (keycode) {\n            case 0x2a:                          /* Left Shift */\n            case 0x36:                          /* Right Shift */\n            case 0x1d:                          /* Left CTRL */\n            case 0x9d:                          /* Right CTRL */\n            case 0x38:                          /* Left ALT */\n            case 0xb8:                          /* Right ALT */\n                break;\n            case 0xc8:\n                kbd_put_keysym(QEMU_KEY_UP);\n                break;\n            case 0xd0:\n                kbd_put_keysym(QEMU_KEY_DOWN);\n                break;\n            case 0xcb:\n                kbd_put_keysym(QEMU_KEY_LEFT);\n                break;\n            case 0xcd:\n                kbd_put_keysym(QEMU_KEY_RIGHT);\n                break;\n            case 0xd3:\n                kbd_put_keysym(QEMU_KEY_DELETE);\n                break;\n            case 0xc7:\n                kbd_put_keysym(QEMU_KEY_HOME);\n                break;\n            case 0xcf:\n                kbd_put_keysym(QEMU_KEY_END);\n                break;\n            case 0xc9:\n                kbd_put_keysym(QEMU_KEY_PAGEUP);\n                break;\n            case 0xd1:\n                kbd_put_keysym(QEMU_KEY_PAGEDOWN);\n                break;\n\n            case 0x47:\n                kbd_put_keysym(numlock ? '7' : QEMU_KEY_HOME);\n                break;\n            case 0x48:\n                kbd_put_keysym(numlock ? '8' : QEMU_KEY_UP);\n                break;\n            case 0x49:\n                kbd_put_keysym(numlock ? '9' : QEMU_KEY_PAGEUP);\n                break;\n            case 0x4b:\n                kbd_put_keysym(numlock ? '4' : QEMU_KEY_LEFT);\n                break;\n            case 0x4c:\n                kbd_put_keysym('5');\n                break;\n            case 0x4d:\n                kbd_put_keysym(numlock ? '6' : QEMU_KEY_RIGHT);\n                break;\n            case 0x4f:\n                kbd_put_keysym(numlock ? '1' : QEMU_KEY_END);\n                break;\n            case 0x50:\n                kbd_put_keysym(numlock ? '2' : QEMU_KEY_DOWN);\n                break;\n            case 0x51:\n                kbd_put_keysym(numlock ? '3' : QEMU_KEY_PAGEDOWN);\n                break;\n            case 0x52:\n                kbd_put_keysym('0');\n                break;\n            case 0x53:\n                kbd_put_keysym(numlock ? '.' : QEMU_KEY_DELETE);\n                break;\n\n            case 0xb5:\n                kbd_put_keysym('/');\n                break;\n            case 0x37:\n                kbd_put_keysym('*');\n                break;\n            case 0x4a:\n                kbd_put_keysym('-');\n                break;\n            case 0x4e:\n                kbd_put_keysym('+');\n                break;\n            case 0x9c:\n                kbd_put_keysym('\\n');\n                break;\n\n            default:\n                if (control) {\n                    kbd_put_keysym(sym & 0x1f);\n                } else {\n                    kbd_put_keysym(sym);\n                }\n                break;\n            }\n        }\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static const char *code2name(int keycode)\n{\n    return QKeyCode_str(qemu_input_key_number_to_qcode(keycode));\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void key_event(VncState *vs, int down, uint32_t sym)\n{\n    int keycode;\n    int lsym = sym;\n\n    if (lsym >= 'A' && lsym <= 'Z' && qemu_console_is_graphic(NULL)) {\n        lsym = lsym - 'A' + 'a';\n    }\n\n    keycode = keysym2scancode(vs->vd->kbd_layout, lsym & 0xFFFF,\n                              vs->vd->kbd, down) & SCANCODE_KEYMASK;\n    trace_vnc_key_event_map(down, sym, keycode, code2name(keycode));\n    do_key_event(vs, down, keycode, sym);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void ext_key_event(VncState *vs, int down,\n                          uint32_t sym, uint16_t keycode)\n{\n    /* if the user specifies a keyboard layout, always use it */\n    if (keyboard_layout) {\n        key_event(vs, down, sym);\n    } else {\n        trace_vnc_key_event_ext(down, sym, keycode, code2name(keycode));\n        do_key_event(vs, down, keycode, sym);\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void framebuffer_update_request(VncState *vs, int incremental,\n                                       int x, int y, int w, int h)\n{\n    if (incremental) {\n        if (vs->update != VNC_STATE_UPDATE_FORCE) {\n            vs->update = VNC_STATE_UPDATE_INCREMENTAL;\n        }\n    } else {\n        vs->update = VNC_STATE_UPDATE_FORCE;\n        vnc_set_area_dirty(vs->dirty, vs->vd, x, y, w, h);\n        if (vnc_has_feature(vs, VNC_FEATURE_RESIZE_EXT)) {\n            vnc_desktop_resize_ext(vs, 0);\n        }\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void send_ext_key_event_ack(VncState *vs)\n{\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1);\n    vnc_framebuffer_update(vs, 0, 0,\n                           pixman_image_get_width(vs->vd->server),\n                           pixman_image_get_height(vs->vd->server),\n                           VNC_ENCODING_EXT_KEY_EVENT);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void send_ext_audio_ack(VncState *vs)\n{\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1);\n    vnc_framebuffer_update(vs, 0, 0,\n                           pixman_image_get_width(vs->vd->server),\n                           pixman_image_get_height(vs->vd->server),\n                           VNC_ENCODING_AUDIO);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void send_xvp_message(VncState *vs, int code)\n{\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_XVP);\n    vnc_write_u8(vs, 0); /* pad */\n    vnc_write_u8(vs, 1); /* version */\n    vnc_write_u8(vs, code);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void set_encodings(VncState *vs, int32_t *encodings, size_t n_encodings)\n{\n    int i;\n    unsigned int enc = 0;\n\n    vs->features = 0;\n    vs->vnc_encoding = 0;\n    vs->tight->compression = 9;\n    vs->tight->quality = -1; /* Lossless by default */\n    vs->absolute = -1;\n\n    /*\n     * Start from the end because the encodings are sent in order of preference.\n     * This way the preferred encoding (first encoding defined in the array)\n     * will be set at the end of the loop.\n     */\n    for (i = n_encodings - 1; i >= 0; i--) {\n        enc = encodings[i];\n        switch (enc) {\n        case VNC_ENCODING_RAW:\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_HEXTILE:\n            vs->features |= VNC_FEATURE_HEXTILE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_TIGHT:\n            vs->features |= VNC_FEATURE_TIGHT_MASK;\n            vs->vnc_encoding = enc;\n            break;\n#ifdef CONFIG_PNG\n        case VNC_ENCODING_TIGHT_PNG:\n            vs->features |= VNC_FEATURE_TIGHT_PNG_MASK;\n            vs->vnc_encoding = enc;\n            break;\n#endif\n        case VNC_ENCODING_ZLIB:\n            /*\n             * VNC_ENCODING_ZRLE compresses better than VNC_ENCODING_ZLIB.\n             * So prioritize ZRLE, even if the client hints that it prefers\n             * ZLIB.\n             */\n            if ((vs->features & VNC_FEATURE_ZRLE_MASK) == 0) {\n                vs->features |= VNC_FEATURE_ZLIB_MASK;\n                vs->vnc_encoding = enc;\n            }\n            break;\n        case VNC_ENCODING_ZRLE:\n            vs->features |= VNC_FEATURE_ZRLE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_ZYWRLE:\n            vs->features |= VNC_FEATURE_ZYWRLE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_DESKTOPRESIZE:\n            vs->features |= VNC_FEATURE_RESIZE_MASK;\n            break;\n        case VNC_ENCODING_DESKTOP_RESIZE_EXT:\n            vs->features |= VNC_FEATURE_RESIZE_EXT_MASK;\n            break;\n        case VNC_ENCODING_POINTER_TYPE_CHANGE:\n            vs->features |= VNC_FEATURE_POINTER_TYPE_CHANGE_MASK;\n            break;\n        case VNC_ENCODING_RICH_CURSOR:\n            vs->features |= VNC_FEATURE_RICH_CURSOR_MASK;\n            break;\n        case VNC_ENCODING_ALPHA_CURSOR:\n            vs->features |= VNC_FEATURE_ALPHA_CURSOR_MASK;\n            break;\n        case VNC_ENCODING_EXT_KEY_EVENT:\n            send_ext_key_event_ack(vs);\n            break;\n        case VNC_ENCODING_AUDIO:\n            send_ext_audio_ack(vs);\n            break;\n        case VNC_ENCODING_WMVi:\n            vs->features |= VNC_FEATURE_WMVI_MASK;\n            break;\n        case VNC_ENCODING_LED_STATE:\n            vs->features |= VNC_FEATURE_LED_STATE_MASK;\n            break;\n        case VNC_ENCODING_XVP:\n            if (vs->vd->power_control) {\n                vs->features |= VNC_FEATURE_XVP;\n                send_xvp_message(vs, VNC_XVP_CODE_INIT);\n            }\n            break;\n        case VNC_ENCODING_CLIPBOARD_EXT:\n            vs->features |= VNC_FEATURE_CLIPBOARD_EXT_MASK;\n            vnc_server_cut_text_caps(vs);\n            break;\n        case VNC_ENCODING_COMPRESSLEVEL0 ... VNC_ENCODING_COMPRESSLEVEL0 + 9:\n            vs->tight->compression = (enc & 0x0F);\n            break;\n        case VNC_ENCODING_QUALITYLEVEL0 ... VNC_ENCODING_QUALITYLEVEL0 + 9:\n            if (vs->vd->lossy) {\n                vs->tight->quality = (enc & 0x0F);\n            }\n            break;\n        default:\n            VNC_DEBUG(\"Unknown encoding: %d (0x%.8x): %d\\n\", i, enc, enc);\n            break;\n        }\n    }\n    vnc_desktop_resize(vs);\n    check_pointer_type_change(&vs->mouse_mode_notifier, NULL);\n    vnc_led_state_change(vs);\n    vnc_cursor_define(vs);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void set_pixel_conversion(VncState *vs)\n{\n    pixman_format_code_t fmt = qemu_pixman_get_format(&vs->client_pf);\n\n    if (fmt == VNC_SERVER_FB_FORMAT) {\n        vs->write_pixels = vnc_write_pixels_copy;\n        vnc_hextile_set_pixel_conversion(vs, 0);\n    } else {\n        vs->write_pixels = vnc_write_pixels_generic;\n        vnc_hextile_set_pixel_conversion(vs, 1);\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void send_color_map(VncState *vs)\n{\n    int i;\n\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_SET_COLOUR_MAP_ENTRIES);\n    vnc_write_u8(vs,  0);    /* padding     */\n    vnc_write_u16(vs, 0);    /* first color */\n    vnc_write_u16(vs, 256);  /* # of colors */\n\n    for (i = 0; i < 256; i++) {\n        PixelFormat *pf = &vs->client_pf;\n\n        vnc_write_u16(vs, (((i >> pf->rshift) & pf->rmax) << (16 - pf->rbits)));\n        vnc_write_u16(vs, (((i >> pf->gshift) & pf->gmax) << (16 - pf->gbits)));\n        vnc_write_u16(vs, (((i >> pf->bshift) & pf->bmax) << (16 - pf->bbits)));\n    }\n    vnc_unlock_output(vs);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void set_pixel_format(VncState *vs, int bits_per_pixel,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n        /* Expose a reasonable default 256 color map */\n        bits_per_pixel = 8;\n        red_max = 7;\n        green_max = 7;\n        blue_max = 3;\n        red_shift = 0;\n        green_shift = 3;\n        blue_shift = 6;\n    }\n\n    switch (bits_per_pixel) {\n    case 8:\n    case 16:\n    case 32:\n        break;\n    default:\n        vnc_client_error(vs);\n        return;\n    }\n\n    vs->client_pf.rmax = red_max ? red_max : 0xFF;\n    vs->client_pf.rbits = ctpopl(red_max);\n    vs->client_pf.rshift = red_shift;\n    vs->client_pf.rmask = red_max << red_shift;\n    vs->client_pf.gmax = green_max ? green_max : 0xFF;\n    vs->client_pf.gbits = ctpopl(green_max);\n    vs->client_pf.gshift = green_shift;\n    vs->client_pf.gmask = green_max << green_shift;\n    vs->client_pf.bmax = blue_max ? blue_max : 0xFF;\n    vs->client_pf.bbits = ctpopl(blue_max);\n    vs->client_pf.bshift = blue_shift;\n    vs->client_pf.bmask = blue_max << blue_shift;\n    vs->client_pf.bits_per_pixel = bits_per_pixel;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n\n    if (!true_color_flag) {\n        send_color_map(vs);\n    }\n\n    set_pixel_conversion(vs);\n\n    graphic_hw_invalidate(vs->vd->dcl.con);\n    graphic_hw_update(vs->vd->dcl.con);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void pixel_format_message (VncState *vs) {\n    char pad[3] = { 0, 0, 0 };\n\n    vs->client_pf = qemu_default_pixelformat(32);\n\n    vnc_write_u8(vs, vs->client_pf.bits_per_pixel); /* bits-per-pixel */\n    vnc_write_u8(vs, vs->client_pf.depth); /* depth */\n\n#if HOST_BIG_ENDIAN\n    vnc_write_u8(vs, 1);             /* big-endian-flag */\n#else\n    vnc_write_u8(vs, 0);             /* big-endian-flag */\n#endif\n    vnc_write_u8(vs, 1);             /* true-color-flag */\n    vnc_write_u16(vs, vs->client_pf.rmax);     /* red-max */\n    vnc_write_u16(vs, vs->client_pf.gmax);     /* green-max */\n    vnc_write_u16(vs, vs->client_pf.bmax);     /* blue-max */\n    vnc_write_u8(vs, vs->client_pf.rshift);    /* red-shift */\n    vnc_write_u8(vs, vs->client_pf.gshift);    /* green-shift */\n    vnc_write_u8(vs, vs->client_pf.bshift);    /* blue-shift */\n    vnc_write(vs, pad, 3);           /* padding */\n\n    vnc_hextile_set_pixel_conversion(vs, 0);\n    vs->write_pixels = vnc_write_pixels_copy;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_colordepth(VncState *vs)\n{\n    if (vnc_has_feature(vs, VNC_FEATURE_WMVI)) {\n        /* Sending a WMVi message to notify the client*/\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs, 0);\n        vnc_write_u16(vs, 1); /* number of rects */\n        vnc_framebuffer_update(vs, 0, 0,\n                               vs->client_width,\n                               vs->client_height,\n                               VNC_ENCODING_WMVi);\n        pixel_format_message(vs);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    } else {\n        set_pixel_conversion(vs);\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n{\n    int i;\n    uint16_t limit;\n    uint32_t freq;\n    VncDisplay *vd = vs->vd;\n\n    if (data[0] > 3) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n    }\n\n    switch (data[0]) {\n    case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:\n        if (len == 1)\n            return 20;\n\n        set_pixel_format(vs, read_u8(data, 4),\n                         read_u8(data, 6), read_u8(data, 7),\n                         read_u16(data, 8), read_u16(data, 10),\n                         read_u16(data, 12), read_u8(data, 14),\n                         read_u8(data, 15), read_u8(data, 16));\n        break;\n    case VNC_MSG_CLIENT_SET_ENCODINGS:\n        if (len == 1)\n            return 4;\n\n        if (len == 4) {\n            limit = read_u16(data, 2);\n            if (limit > 0)\n                return 4 + (limit * 4);\n        } else\n            limit = read_u16(data, 2);\n\n        for (i = 0; i < limit; i++) {\n            int32_t val = read_s32(data, 4 + (i * 4));\n            memcpy(data + 4 + (i * 4), &val, sizeof(val));\n        }\n\n        set_encodings(vs, (int32_t *)(data + 4), limit);\n        break;\n    case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:\n        if (len == 1)\n            return 10;\n\n        framebuffer_update_request(vs,\n                                   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),\n                                   read_u16(data, 6), read_u16(data, 8));\n        break;\n    case VNC_MSG_CLIENT_KEY_EVENT:\n        if (len == 1)\n            return 8;\n\n        key_event(vs, read_u8(data, 1), read_u32(data, 4));\n        break;\n    case VNC_MSG_CLIENT_POINTER_EVENT:\n        if (len == 1)\n            return 6;\n\n        pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n        break;\n    case VNC_MSG_CLIENT_CUT_TEXT:\n        if (len == 1) {\n            return 8;\n        }\n        if (len == 8) {\n            uint32_t dlen = abs(read_s32(data, 4));\n            if (dlen > (1 << 20)) {\n                error_report(\"vnc: client_cut_text msg payload has %u bytes\"\n                             \" which exceeds our limit of 1MB.\", dlen);\n                vnc_client_error(vs);\n                break;\n            }\n            if (dlen > 0) {\n                return 8 + dlen;\n            }\n        }\n\n        if (read_s32(data, 4) < 0) {\n            vnc_client_cut_text_ext(vs, abs(read_s32(data, 4)),\n                                    read_u32(data, 8), data + 12);\n            break;\n        }\n        vnc_client_cut_text(vs, read_u32(data, 4), data + 8);\n        break;\n    case VNC_MSG_CLIENT_XVP:\n        if (!(vs->features & VNC_FEATURE_XVP)) {\n            error_report(\"vnc: xvp client message while disabled\");\n            vnc_client_error(vs);\n            break;\n        }\n        if (len == 1) {\n            return 4;\n        }\n        if (len == 4) {\n            uint8_t version = read_u8(data, 2);\n            uint8_t action = read_u8(data, 3);\n\n            if (version != 1) {\n                error_report(\"vnc: xvp client message version %d != 1\",\n                             version);\n                vnc_client_error(vs);\n                break;\n            }\n\n            switch (action) {\n            case VNC_XVP_ACTION_SHUTDOWN:\n                qemu_system_powerdown_request();\n                break;\n            case VNC_XVP_ACTION_REBOOT:\n                send_xvp_message(vs, VNC_XVP_CODE_FAIL);\n                break;\n            case VNC_XVP_ACTION_RESET:\n                qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);\n                break;\n            default:\n                send_xvp_message(vs, VNC_XVP_CODE_FAIL);\n                break;\n            }\n        }\n        break;\n    case VNC_MSG_CLIENT_QEMU:\n        if (len == 1)\n            return 2;\n\n        switch (read_u8(data, 1)) {\n        case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:\n            if (len == 2)\n                return 12;\n\n            ext_key_event(vs, read_u16(data, 2),\n                          read_u32(data, 4), read_u32(data, 8));\n            break;\n        case VNC_MSG_CLIENT_QEMU_AUDIO:\n            if (len == 2)\n                return 4;\n\n            switch (read_u16 (data, 2)) {\n            case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:\n                trace_vnc_msg_client_audio_enable(vs, vs->ioc);\n                audio_add(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:\n                trace_vnc_msg_client_audio_disable(vs, vs->ioc);\n                audio_del(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:\n                if (len == 4)\n                    return 10;\n                switch (read_u8(data, 4)) {\n                case 0: vs->as.fmt = AUDIO_FORMAT_U8; break;\n                case 1: vs->as.fmt = AUDIO_FORMAT_S8; break;\n                case 2: vs->as.fmt = AUDIO_FORMAT_U16; break;\n                case 3: vs->as.fmt = AUDIO_FORMAT_S16; break;\n                case 4: vs->as.fmt = AUDIO_FORMAT_U32; break;\n                case 5: vs->as.fmt = AUDIO_FORMAT_S32; break;\n                default:\n                    VNC_DEBUG(\"Invalid audio format %d\\n\", read_u8(data, 4));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.nchannels = read_u8(data, 5);\n                if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n                    VNC_DEBUG(\"Invalid audio channel count %d\\n\",\n                              read_u8(data, 5));\n                    vnc_client_error(vs);\n                    break;\n                }\n                freq = read_u32(data, 6);\n                /* No official limit for protocol, but 48khz is a sensible\n                 * upper bound for trustworthy clients, and this limit\n                 * protects calculations involving 'vs->as.freq' later.\n                 */\n                if (freq > 48000) {\n                    VNC_DEBUG(\"Invalid audio frequency %u > 48000\", freq);\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.freq = freq;\n                trace_vnc_msg_client_audio_format(\n                    vs, vs->ioc, vs->as.fmt, vs->as.nchannels, vs->as.freq);\n                break;\n            default:\n                VNC_DEBUG(\"Invalid audio message %d\\n\", read_u8(data, 4));\n                vnc_client_error(vs);\n                break;\n            }\n            break;\n\n        default:\n            VNC_DEBUG(\"Msg: %d\\n\", read_u16(data, 0));\n            vnc_client_error(vs);\n            break;\n        }\n        break;\n    case VNC_MSG_CLIENT_SET_DESKTOP_SIZE:\n    {\n        size_t size;\n        uint8_t screens;\n        int w, h;\n\n        if (len < 8) {\n            return 8;\n        }\n\n        screens = read_u8(data, 6);\n        size    = 8 + screens * 16;\n        if (len < size) {\n            return size;\n        }\n        w = read_u16(data, 2);\n        h = read_u16(data, 4);\n\n        trace_vnc_msg_client_set_desktop_size(vs, vs->ioc, w, h, screens);\n        if (dpy_ui_info_supported(vs->vd->dcl.con)) {\n            QemuUIInfo info;\n            memset(&info, 0, sizeof(info));\n            info.width = w;\n            info.height = h;\n            dpy_set_ui_info(vs->vd->dcl.con, &info, false);\n            vnc_desktop_resize_ext(vs, 4 /* Request forwarded */);\n        } else {\n            vnc_desktop_resize_ext(vs, 3 /* Invalid screen layout */);\n        }\n\n        break;\n    }\n    default:\n        VNC_DEBUG(\"Msg: %d\\n\", data[0]);\n        vnc_client_error(vs);\n        break;\n    }\n\n    vnc_update_throttle_offset(vs);\n    vnc_read_when(vs, protocol_client_msg, 1);\n    return 0;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int protocol_client_init(VncState *vs, uint8_t *data, size_t len)\n{\n    char buf[1024];\n    VncShareMode mode;\n    int size;\n\n    mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;\n    switch (vs->vd->share_policy) {\n    case VNC_SHARE_POLICY_IGNORE:\n        /*\n         * Ignore the shared flag.  Nothing to do here.\n         *\n         * Doesn't conform to the rfb spec but is traditional qemu\n         * behavior, thus left here as option for compatibility\n         * reasons.\n         */\n        break;\n    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:\n        /*\n         * Policy: Allow clients ask for exclusive access.\n         *\n         * Implementation: When a client asks for exclusive access,\n         * disconnect all others. Shared connects are allowed as long\n         * as no exclusive connection exists.\n         *\n         * This is how the rfb spec suggests to handle the shared flag.\n         */\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n            VncState *client;\n            QTAILQ_FOREACH(client, &vs->vd->clients, next) {\n                if (vs == client) {\n                    continue;\n                }\n                if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&\n                    client->share_mode != VNC_SHARE_MODE_SHARED) {\n                    continue;\n                }\n                vnc_disconnect_start(client);\n            }\n        }\n        if (mode == VNC_SHARE_MODE_SHARED) {\n            if (vs->vd->num_exclusive > 0) {\n                vnc_disconnect_start(vs);\n                return 0;\n            }\n        }\n        break;\n    case VNC_SHARE_POLICY_FORCE_SHARED:\n        /*\n         * Policy: Shared connects only.\n         * Implementation: Disallow clients asking for exclusive access.\n         *\n         * Useful for shared desktop sessions where you don't want\n         * someone forgetting to say -shared when running the vnc\n         * client disconnect everybody else.\n         */\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n            vnc_disconnect_start(vs);\n            return 0;\n        }\n        break;\n    }\n    vnc_set_share_mode(vs, mode);\n\n    if (vs->vd->num_shared > vs->vd->connections_limit) {\n        vnc_disconnect_start(vs);\n        return 0;\n    }\n\n    assert(pixman_image_get_width(vs->vd->server) < 65536 &&\n           pixman_image_get_width(vs->vd->server) >= 0);\n    assert(pixman_image_get_height(vs->vd->server) < 65536 &&\n           pixman_image_get_height(vs->vd->server) >= 0);\n    vs->client_width = pixman_image_get_width(vs->vd->server);\n    vs->client_height = pixman_image_get_height(vs->vd->server);\n    vnc_write_u16(vs, vs->client_width);\n    vnc_write_u16(vs, vs->client_height);\n\n    pixel_format_message(vs);\n\n    if (qemu_name) {\n        size = snprintf(buf, sizeof(buf), \"QEMU (%s)\", qemu_name);\n        if (size > sizeof(buf)) {\n            size = sizeof(buf);\n        }\n    } else {\n        size = snprintf(buf, sizeof(buf), \"QEMU\");\n    }\n\n    vnc_write_u32(vs, size);\n    vnc_write(vs, buf, size);\n    vnc_flush(vs);\n\n    vnc_client_cache_auth(vs);\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n\n    return 0;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void start_client_init(VncState *vs)\n{\n    vnc_read_when(vs, protocol_client_init, 1);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void authentication_failed(VncState *vs)\n{\n    vnc_write_u32(vs, 1); /* Reject auth */\n    if (vs->minor >= 8) {\n        static const char err[] = \"Authentication failed\";\n        vnc_write_u32(vs, sizeof(err));\n        vnc_write(vs, err, sizeof(err));\n    }\n    vnc_flush(vs);\n    vnc_client_error(vs);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void\nvnc_munge_des_rfb_key(unsigned char *key, size_t nkey)\n{\n    size_t i;\n    for (i = 0; i < nkey; i++) {\n        uint8_t r = key[i];\n        r = (r & 0xf0) >> 4 | (r & 0x0f) << 4;\n        r = (r & 0xcc) >> 2 | (r & 0x33) << 2;\n        r = (r & 0xaa) >> 1 | (r & 0x55) << 1;\n        key[i] = r;\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int protocol_client_auth_vnc(VncState *vs, uint8_t *data, size_t len)\n{\n    unsigned char response[VNC_AUTH_CHALLENGE_SIZE];\n    size_t i, pwlen;\n    unsigned char key[8];\n    time_t now = time(NULL);\n    QCryptoCipher *cipher = NULL;\n    Error *err = NULL;\n\n    if (!vs->vd->password) {\n        trace_vnc_auth_fail(vs, vs->auth, \"password is not set\", \"\");\n        goto reject;\n    }\n    if (vs->vd->expires < now) {\n        trace_vnc_auth_fail(vs, vs->auth, \"password is expired\", \"\");\n        goto reject;\n    }\n\n    memcpy(response, vs->challenge, VNC_AUTH_CHALLENGE_SIZE);\n\n    /* Calculate the expected challenge response */\n    pwlen = strlen(vs->vd->password);\n    for (i=0; i<sizeof(key); i++)\n        key[i] = i<pwlen ? vs->vd->password[i] : 0;\n    vnc_munge_des_rfb_key(key, sizeof(key));\n\n    cipher = qcrypto_cipher_new(\n        QCRYPTO_CIPHER_ALG_DES,\n        QCRYPTO_CIPHER_MODE_ECB,\n        key, G_N_ELEMENTS(key),\n        &err);\n    if (!cipher) {\n        trace_vnc_auth_fail(vs, vs->auth, \"cannot create cipher\",\n                            error_get_pretty(err));\n        error_free(err);\n        goto reject;\n    }\n\n    if (qcrypto_cipher_encrypt(cipher,\n                               vs->challenge,\n                               response,\n                               VNC_AUTH_CHALLENGE_SIZE,\n                               &err) < 0) {\n        trace_vnc_auth_fail(vs, vs->auth, \"cannot encrypt challenge response\",\n                            error_get_pretty(err));\n        error_free(err);\n        goto reject;\n    }\n\n    /* Compare expected vs actual challenge response */\n    if (memcmp(response, data, VNC_AUTH_CHALLENGE_SIZE) != 0) {\n        trace_vnc_auth_fail(vs, vs->auth, \"mis-matched challenge response\", \"\");\n        goto reject;\n    } else {\n        trace_vnc_auth_pass(vs, vs->auth);\n        vnc_write_u32(vs, 0); /* Accept auth */\n        vnc_flush(vs);\n\n        start_client_init(vs);\n    }\n\n    qcrypto_cipher_free(cipher);\n    return 0;\n\nreject:\n    authentication_failed(vs);\n    qcrypto_cipher_free(cipher);\n    return 0;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void start_auth_vnc(VncState *vs)\n{\n    Error *err = NULL;\n\n    if (qcrypto_random_bytes(vs->challenge, sizeof(vs->challenge), &err)) {\n        trace_vnc_auth_fail(vs, vs->auth, \"cannot get random bytes\",\n                            error_get_pretty(err));\n        error_free(err);\n        authentication_failed(vs);\n        return;\n    }\n\n    /* Send client a 'random' challenge */\n    vnc_write(vs, vs->challenge, sizeof(vs->challenge));\n    vnc_flush(vs);\n\n    vnc_read_when(vs, protocol_client_auth_vnc, sizeof(vs->challenge));\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int protocol_client_auth(VncState *vs, uint8_t *data, size_t len)\n{\n    /* We only advertise 1 auth scheme at a time, so client\n     * must pick the one we sent. Verify this */\n    if (data[0] != vs->auth) { /* Reject auth */\n       trace_vnc_auth_reject(vs, vs->auth, (int)data[0]);\n       authentication_failed(vs);\n    } else { /* Accept requested auth */\n       trace_vnc_auth_start(vs, vs->auth);\n       switch (vs->auth) {\n       case VNC_AUTH_NONE:\n           if (vs->minor >= 8) {\n               vnc_write_u32(vs, 0); /* Accept auth completion */\n               vnc_flush(vs);\n           }\n           trace_vnc_auth_pass(vs, vs->auth);\n           start_client_init(vs);\n           break;\n\n       case VNC_AUTH_VNC:\n           start_auth_vnc(vs);\n           break;\n\n       case VNC_AUTH_VENCRYPT:\n           start_auth_vencrypt(vs);\n           break;\n\n#ifdef CONFIG_VNC_SASL\n       case VNC_AUTH_SASL:\n           start_auth_sasl(vs);\n           break;\n#endif /* CONFIG_VNC_SASL */\n\n       default: /* Should not be possible, but just in case */\n           trace_vnc_auth_fail(vs, vs->auth, \"Unhandled auth method\", \"\");\n           authentication_failed(vs);\n       }\n    }\n    return 0;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int protocol_version(VncState *vs, uint8_t *version, size_t len)\n{\n    char local[13];\n\n    memcpy(local, version, 12);\n    local[12] = 0;\n\n    if (sscanf(local, \"RFB %03d.%03d\\n\", &vs->major, &vs->minor) != 2) {\n        VNC_DEBUG(\"Malformed protocol version %s\\n\", local);\n        vnc_client_error(vs);\n        return 0;\n    }\n    VNC_DEBUG(\"Client request protocol version %d.%d\\n\", vs->major, vs->minor);\n    if (vs->major != 3 ||\n        (vs->minor != 3 &&\n         vs->minor != 4 &&\n         vs->minor != 5 &&\n         vs->minor != 7 &&\n         vs->minor != 8)) {\n        VNC_DEBUG(\"Unsupported client version\\n\");\n        vnc_write_u32(vs, VNC_AUTH_INVALID);\n        vnc_flush(vs);\n        vnc_client_error(vs);\n        return 0;\n    }\n    /* Some broken clients report v3.4 or v3.5, which spec requires to be treated\n     * as equivalent to v3.3 by servers\n     */\n    if (vs->minor == 4 || vs->minor == 5)\n        vs->minor = 3;\n\n    if (vs->minor == 3) {\n        trace_vnc_auth_start(vs, vs->auth);\n        if (vs->auth == VNC_AUTH_NONE) {\n            vnc_write_u32(vs, vs->auth);\n            vnc_flush(vs);\n            trace_vnc_auth_pass(vs, vs->auth);\n            start_client_init(vs);\n       } else if (vs->auth == VNC_AUTH_VNC) {\n            VNC_DEBUG(\"Tell client VNC auth\\n\");\n            vnc_write_u32(vs, vs->auth);\n            vnc_flush(vs);\n            start_auth_vnc(vs);\n       } else {\n            trace_vnc_auth_fail(vs, vs->auth,\n                                \"Unsupported auth method for v3.3\", \"\");\n            vnc_write_u32(vs, VNC_AUTH_INVALID);\n            vnc_flush(vs);\n            vnc_client_error(vs);\n       }\n    } else {\n        vnc_write_u8(vs, 1); /* num auth */\n        vnc_write_u8(vs, vs->auth);\n        vnc_read_when(vs, protocol_client_auth, 1);\n        vnc_flush(vs);\n    }\n\n    return 0;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static VncRectStat *vnc_stat_rect(VncDisplay *vd, int x, int y)\n{\n    struct VncSurface *vs = &vd->guest;\n\n    return &vs->stats[y / VNC_STAT_RECT][x / VNC_STAT_RECT];\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_sent_lossy_rect(VncState *vs, int x, int y, int w, int h)\n{\n    int i, j;\n\n    w = (x + w) / VNC_STAT_RECT;\n    h = (y + h) / VNC_STAT_RECT;\n    x /= VNC_STAT_RECT;\n    y /= VNC_STAT_RECT;\n\n    for (j = y; j <= h; j++) {\n        for (i = x; i <= w; i++) {\n            vs->lossy_rect[j][i] = 1;\n        }\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int vnc_refresh_lossy_rect(VncDisplay *vd, int x, int y)\n{\n    VncState *vs;\n    int sty = y / VNC_STAT_RECT;\n    int stx = x / VNC_STAT_RECT;\n    int has_dirty = 0;\n\n    y = QEMU_ALIGN_DOWN(y, VNC_STAT_RECT);\n    x = QEMU_ALIGN_DOWN(x, VNC_STAT_RECT);\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        int j;\n\n        /* kernel send buffers are full -> refresh later */\n        if (vs->output.offset) {\n            continue;\n        }\n\n        if (!vs->lossy_rect[sty][stx]) {\n            continue;\n        }\n\n        vs->lossy_rect[sty][stx] = 0;\n        for (j = 0; j < VNC_STAT_RECT; ++j) {\n            bitmap_set(vs->dirty[y + j],\n                       x / VNC_DIRTY_PIXELS_PER_BIT,\n                       VNC_STAT_RECT / VNC_DIRTY_PIXELS_PER_BIT);\n        }\n        has_dirty++;\n    }\n\n    return has_dirty;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int vnc_update_stats(VncDisplay *vd,  struct timeval * tv)\n{\n    int width = MIN(pixman_image_get_width(vd->guest.fb),\n                    pixman_image_get_width(vd->server));\n    int height = MIN(pixman_image_get_height(vd->guest.fb),\n                     pixman_image_get_height(vd->server));\n    int x, y;\n    struct timeval res;\n    int has_dirty = 0;\n\n    for (y = 0; y < height; y += VNC_STAT_RECT) {\n        for (x = 0; x < width; x += VNC_STAT_RECT) {\n            VncRectStat *rect = vnc_stat_rect(vd, x, y);\n\n            rect->updated = false;\n        }\n    }\n\n    qemu_timersub(tv, &VNC_REFRESH_STATS, &res);\n\n    if (timercmp(&vd->guest.last_freq_check, &res, >)) {\n        return has_dirty;\n    }\n    vd->guest.last_freq_check = *tv;\n\n    for (y = 0; y < height; y += VNC_STAT_RECT) {\n        for (x = 0; x < width; x += VNC_STAT_RECT) {\n            VncRectStat *rect= vnc_stat_rect(vd, x, y);\n            int count = ARRAY_SIZE(rect->times);\n            struct timeval min, max;\n\n            if (!timerisset(&rect->times[count - 1])) {\n                continue ;\n            }\n\n            max = rect->times[(rect->idx + count - 1) % count];\n            qemu_timersub(tv, &max, &res);\n\n            if (timercmp(&res, &VNC_REFRESH_LOSSY, >)) {\n                rect->freq = 0;\n                has_dirty += vnc_refresh_lossy_rect(vd, x, y);\n                memset(rect->times, 0, sizeof (rect->times));\n                continue ;\n            }\n\n            min = rect->times[rect->idx];\n            max = rect->times[(rect->idx + count - 1) % count];\n            qemu_timersub(&max, &min, &res);\n\n            rect->freq = res.tv_sec + res.tv_usec / 1000000.;\n            rect->freq /= count;\n            rect->freq = 1. / rect->freq;\n        }\n    }\n    return has_dirty;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "double vnc_update_freq(VncState *vs, int x, int y, int w, int h)\n{\n    int i, j;\n    double total = 0;\n    int num = 0;\n\n    x =  QEMU_ALIGN_DOWN(x, VNC_STAT_RECT);\n    y =  QEMU_ALIGN_DOWN(y, VNC_STAT_RECT);\n\n    for (j = y; j <= y + h; j += VNC_STAT_RECT) {\n        for (i = x; i <= x + w; i += VNC_STAT_RECT) {\n            total += vnc_stat_rect(vs->vd, i, j)->freq;\n            num++;\n        }\n    }\n\n    if (num) {\n        return total / num;\n    } else {\n        return 0;\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_rect_updated(VncDisplay *vd, int x, int y, struct timeval * tv)\n{\n    VncRectStat *rect;\n\n    rect = vnc_stat_rect(vd, x, y);\n    if (rect->updated) {\n        return ;\n    }\n    rect->times[rect->idx] = *tv;\n    rect->idx = (rect->idx + 1) % ARRAY_SIZE(rect->times);\n    rect->updated = true;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int vnc_refresh_server_surface(VncDisplay *vd)\n{\n    int width = MIN(pixman_image_get_width(vd->guest.fb),\n                    pixman_image_get_width(vd->server));\n    int height = MIN(pixman_image_get_height(vd->guest.fb),\n                     pixman_image_get_height(vd->server));\n    int cmp_bytes, server_stride, line_bytes, guest_ll, guest_stride, y = 0;\n    uint8_t *guest_row0 = NULL, *server_row0;\n    VncState *vs;\n    int has_dirty = 0;\n    pixman_image_t *tmpbuf = NULL;\n    unsigned long offset;\n    int x;\n    uint8_t *guest_ptr, *server_ptr;\n\n    struct timeval tv = { 0, 0 };\n\n    if (!vd->non_adaptive) {\n        gettimeofday(&tv, NULL);\n        has_dirty = vnc_update_stats(vd, &tv);\n    }\n\n    offset = find_next_bit((unsigned long *) &vd->guest.dirty,\n                           height * VNC_DIRTY_BPL(&vd->guest), 0);\n    if (offset == height * VNC_DIRTY_BPL(&vd->guest)) {\n        /* no dirty bits in guest surface */\n        return has_dirty;\n    }\n\n    /*\n     * Walk through the guest dirty map.\n     * Check and copy modified bits from guest to server surface.\n     * Update server dirty map.\n     */\n    server_row0 = (uint8_t *)pixman_image_get_data(vd->server);\n    server_stride = guest_stride = guest_ll =\n        pixman_image_get_stride(vd->server);\n    cmp_bytes = MIN(VNC_DIRTY_PIXELS_PER_BIT * VNC_SERVER_FB_BYTES,\n                    server_stride);\n    if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n        int width = pixman_image_get_width(vd->server);\n        tmpbuf = qemu_pixman_linebuf_create(VNC_SERVER_FB_FORMAT, width);\n    } else {\n        int guest_bpp =\n            PIXMAN_FORMAT_BPP(pixman_image_get_format(vd->guest.fb));\n        guest_row0 = (uint8_t *)pixman_image_get_data(vd->guest.fb);\n        guest_stride = pixman_image_get_stride(vd->guest.fb);\n        guest_ll = pixman_image_get_width(vd->guest.fb)\n                   * DIV_ROUND_UP(guest_bpp, 8);\n    }\n    line_bytes = MIN(server_stride, guest_ll);\n\n    for (;;) {\n        y = offset / VNC_DIRTY_BPL(&vd->guest);\n        x = offset % VNC_DIRTY_BPL(&vd->guest);\n\n        server_ptr = server_row0 + y * server_stride + x * cmp_bytes;\n\n        if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n            qemu_pixman_linebuf_fill(tmpbuf, vd->guest.fb, width, 0, y);\n            guest_ptr = (uint8_t *)pixman_image_get_data(tmpbuf);\n        } else {\n            guest_ptr = guest_row0 + y * guest_stride;\n        }\n        guest_ptr += x * cmp_bytes;\n\n        for (; x < DIV_ROUND_UP(width, VNC_DIRTY_PIXELS_PER_BIT);\n             x++, guest_ptr += cmp_bytes, server_ptr += cmp_bytes) {\n            int _cmp_bytes = cmp_bytes;\n            if (!test_and_clear_bit(x, vd->guest.dirty[y])) {\n                continue;\n            }\n            if ((x + 1) * cmp_bytes > line_bytes) {\n                _cmp_bytes = line_bytes - x * cmp_bytes;\n            }\n            assert(_cmp_bytes >= 0);\n            if (memcmp(server_ptr, guest_ptr, _cmp_bytes) == 0) {\n                continue;\n            }\n            memcpy(server_ptr, guest_ptr, _cmp_bytes);\n            if (!vd->non_adaptive) {\n                vnc_rect_updated(vd, x * VNC_DIRTY_PIXELS_PER_BIT,\n                                 y, &tv);\n            }\n            QTAILQ_FOREACH(vs, &vd->clients, next) {\n                set_bit(x, vs->dirty[y]);\n            }\n            has_dirty++;\n        }\n\n        y++;\n        offset = find_next_bit((unsigned long *) &vd->guest.dirty,\n                               height * VNC_DIRTY_BPL(&vd->guest),\n                               y * VNC_DIRTY_BPL(&vd->guest));\n        if (offset == height * VNC_DIRTY_BPL(&vd->guest)) {\n            /* no more dirty bits */\n            break;\n        }\n    }\n    qemu_pixman_image_unref(tmpbuf);\n    return has_dirty;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_refresh(DisplayChangeListener *dcl)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs, *vn;\n    int has_dirty, rects = 0;\n\n    if (QTAILQ_EMPTY(&vd->clients)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_MAX);\n        return;\n    }\n\n    graphic_hw_update(vd->dcl.con);\n\n    if (vnc_trylock_display(vd)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n        return;\n    }\n\n    has_dirty = vnc_refresh_server_surface(vd);\n    vnc_unlock_display(vd);\n\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n        rects += vnc_update_client(vs, has_dirty);\n        /* vs might be free()ed here */\n    }\n\n    if (has_dirty && rects) {\n        vd->dcl.update_interval /= 2;\n        if (vd->dcl.update_interval < VNC_REFRESH_INTERVAL_BASE) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;\n        }\n    } else {\n        vd->dcl.update_interval += VNC_REFRESH_INTERVAL_INC;\n        if (vd->dcl.update_interval > VNC_REFRESH_INTERVAL_MAX) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;\n        }\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_connect(VncDisplay *vd, QIOChannelSocket *sioc,\n                        bool skipauth, bool websocket)\n{\n    VncState *vs = g_new0(VncState, 1);\n    bool first_client = QTAILQ_EMPTY(&vd->clients);\n    int i;\n\n    trace_vnc_client_connect(vs, sioc);\n    vs->zrle = g_new0(VncZrle, 1);\n    vs->tight = g_new0(VncTight, 1);\n    vs->magic = VNC_MAGIC;\n    vs->sioc = sioc;\n    object_ref(OBJECT(vs->sioc));\n    vs->ioc = QIO_CHANNEL(sioc);\n    object_ref(OBJECT(vs->ioc));\n    vs->vd = vd;\n\n    buffer_init(&vs->input,          \"vnc-input/%p\", sioc);\n    buffer_init(&vs->output,         \"vnc-output/%p\", sioc);\n    buffer_init(&vs->jobs_buffer,    \"vnc-jobs_buffer/%p\", sioc);\n\n    buffer_init(&vs->tight->tight,    \"vnc-tight/%p\", sioc);\n    buffer_init(&vs->tight->zlib,     \"vnc-tight-zlib/%p\", sioc);\n    buffer_init(&vs->tight->gradient, \"vnc-tight-gradient/%p\", sioc);\n#ifdef CONFIG_VNC_JPEG\n    buffer_init(&vs->tight->jpeg,     \"vnc-tight-jpeg/%p\", sioc);\n#endif\n#ifdef CONFIG_PNG\n    buffer_init(&vs->tight->png,      \"vnc-tight-png/%p\", sioc);\n#endif\n    buffer_init(&vs->zlib.zlib,      \"vnc-zlib/%p\", sioc);\n    buffer_init(&vs->zrle->zrle,      \"vnc-zrle/%p\", sioc);\n    buffer_init(&vs->zrle->fb,        \"vnc-zrle-fb/%p\", sioc);\n    buffer_init(&vs->zrle->zlib,      \"vnc-zrle-zlib/%p\", sioc);\n\n    if (skipauth) {\n        vs->auth = VNC_AUTH_NONE;\n        vs->subauth = VNC_AUTH_INVALID;\n    } else {\n        if (websocket) {\n            vs->auth = vd->ws_auth;\n            vs->subauth = VNC_AUTH_INVALID;\n        } else {\n            vs->auth = vd->auth;\n            vs->subauth = vd->subauth;\n        }\n    }\n    VNC_DEBUG(\"Client sioc=%p ws=%d auth=%d subauth=%d\\n\",\n              sioc, websocket, vs->auth, vs->subauth);\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n        vs->lossy_rect[i] = g_new0(uint8_t, VNC_STAT_COLS);\n    }\n\n    VNC_DEBUG(\"New client on socket %p\\n\", vs->sioc);\n    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n    qio_channel_set_blocking(vs->ioc, false, NULL);\n    if (vs->ioc_tag) {\n        g_source_remove(vs->ioc_tag);\n    }\n    if (websocket) {\n        vs->websocket = 1;\n        if (vd->tlscreds) {\n            vs->ioc_tag = qio_channel_add_watch(\n                vs->ioc, G_IO_IN | G_IO_HUP | G_IO_ERR,\n                vncws_tls_handshake_io, vs, NULL);\n        } else {\n            vs->ioc_tag = qio_channel_add_watch(\n                vs->ioc, G_IO_IN | G_IO_HUP | G_IO_ERR,\n                vncws_handshake_io, vs, NULL);\n        }\n    } else {\n        vs->ioc_tag = qio_channel_add_watch(\n            vs->ioc, G_IO_IN | G_IO_HUP | G_IO_ERR,\n            vnc_client_io, vs, NULL);\n    }\n\n    vnc_client_cache_addr(vs);\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n    vs->last_x = -1;\n    vs->last_y = -1;\n\n    vs->as.freq = 44100;\n    vs->as.nchannels = 2;\n    vs->as.fmt = AUDIO_FORMAT_S16;\n    vs->as.endianness = 0;\n\n    qemu_mutex_init(&vs->output_mutex);\n    vs->bh = qemu_bh_new(vnc_jobs_bh, vs);\n\n    QTAILQ_INSERT_TAIL(&vd->clients, vs, next);\n    if (first_client) {\n        vnc_update_server_surface(vd);\n    }\n\n    graphic_hw_update(vd->dcl.con);\n\n    if (!vs->websocket) {\n        vnc_start_protocol(vs);\n    }\n\n    if (vd->num_connecting > vd->connections_limit) {\n        QTAILQ_FOREACH(vs, &vd->clients, next) {\n            if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) {\n                vnc_disconnect_start(vs);\n                return;\n            }\n        }\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_start_protocol(VncState *vs)\n{\n    vnc_write(vs, \"RFB 003.008\\n\", 12);\n    vnc_flush(vs);\n    vnc_read_when(vs, protocol_version, 12);\n\n    vs->mouse_mode_notifier.notify = check_pointer_type_change;\n    qemu_add_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_listen_io(QIONetListener *listener,\n                          QIOChannelSocket *cioc,\n                          void *opaque)\n{\n    VncDisplay *vd = opaque;\n    bool isWebsock = listener == vd->wslistener;\n\n    qio_channel_set_name(QIO_CHANNEL(cioc),\n                         isWebsock ? \"vnc-ws-server\" : \"vnc-server\");\n    qio_channel_set_delay(QIO_CHANNEL(cioc), false);\n    vnc_connect(vd, cioc, false, isWebsock);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_display_init(const char *id, Error **errp)\n{\n    VncDisplay *vd;\n\n    if (vnc_display_find(id) != NULL) {\n        return;\n    }\n    vd = g_malloc0(sizeof(*vd));\n\n    vd->id = strdup(id);\n    QTAILQ_INSERT_TAIL(&vnc_displays, vd, next);\n\n    QTAILQ_INIT(&vd->clients);\n    vd->expires = TIME_MAX;\n\n    if (keyboard_layout) {\n        trace_vnc_key_map_init(keyboard_layout);\n        vd->kbd_layout = init_keyboard_layout(name2keysym,\n                                              keyboard_layout, errp);\n    } else {\n        vd->kbd_layout = init_keyboard_layout(name2keysym, \"en-us\", errp);\n    }\n\n    if (!vd->kbd_layout) {\n        return;\n    }\n\n    vd->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n    vd->connections_limit = 32;\n\n    qemu_mutex_init(&vd->mutex);\n    vnc_start_worker_thread();\n\n    vd->dcl.ops = &dcl_ops;\n    register_displaychangelistener(&vd->dcl);\n    vd->kbd = qkbd_state_init(vd->dcl.con);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_display_close(VncDisplay *vd)\n{\n    if (!vd) {\n        return;\n    }\n    vd->is_unix = false;\n\n    if (vd->listener) {\n        qio_net_listener_disconnect(vd->listener);\n        object_unref(OBJECT(vd->listener));\n    }\n    vd->listener = NULL;\n\n    if (vd->wslistener) {\n        qio_net_listener_disconnect(vd->wslistener);\n        object_unref(OBJECT(vd->wslistener));\n    }\n    vd->wslistener = NULL;\n\n    vd->auth = VNC_AUTH_INVALID;\n    vd->subauth = VNC_AUTH_INVALID;\n    if (vd->tlscreds) {\n        object_unref(OBJECT(vd->tlscreds));\n        vd->tlscreds = NULL;\n    }\n    if (vd->tlsauthz) {\n        object_unparent(OBJECT(vd->tlsauthz));\n        vd->tlsauthz = NULL;\n    }\n    g_free(vd->tlsauthzid);\n    vd->tlsauthzid = NULL;\n    if (vd->lock_key_sync) {\n        qemu_remove_led_event_handler(vd->led);\n        vd->led = NULL;\n    }\n#ifdef CONFIG_VNC_SASL\n    if (vd->sasl.authz) {\n        object_unparent(OBJECT(vd->sasl.authz));\n        vd->sasl.authz = NULL;\n    }\n    g_free(vd->sasl.authzid);\n    vd->sasl.authzid = NULL;\n#endif\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "int vnc_display_password(const char *id, const char *password)\n{\n    VncDisplay *vd = vnc_display_find(id);\n\n    if (!vd) {\n        return -EINVAL;\n    }\n    if (vd->auth == VNC_AUTH_NONE) {\n        error_printf_unless_qmp(\"If you want use passwords please enable \"\n                                \"password auth using '-vnc ${dpy},password'.\\n\");\n        return -EINVAL;\n    }\n\n    g_free(vd->password);\n    vd->password = g_strdup(password);\n\n    return 0;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "int vnc_display_pw_expire(const char *id, time_t expires)\n{\n    VncDisplay *vd = vnc_display_find(id);\n\n    if (!vd) {\n        return -EINVAL;\n    }\n\n    vd->expires = expires;\n    return 0;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_display_print_local_addr(VncDisplay *vd)\n{\n    SocketAddress *addr;\n\n    if (!vd->listener || !vd->listener->nsioc) {\n        return;\n    }\n\n    addr = qio_channel_socket_get_local_address(vd->listener->sioc[0], NULL);\n    if (!addr) {\n        return;\n    }\n\n    if (addr->type != SOCKET_ADDRESS_TYPE_INET) {\n        qapi_free_SocketAddress(addr);\n        return;\n    }\n    error_printf_unless_qmp(\"VNC server running on %s:%s\\n\",\n                            addr->u.inet.host,\n                            addr->u.inet.port);\n    qapi_free_SocketAddress(addr);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int\nvnc_display_setup_auth(int *auth,\n                       int *subauth,\n                       QCryptoTLSCreds *tlscreds,\n                       bool password,\n                       bool sasl,\n                       bool websocket,\n                       Error **errp)\n{\n    /*\n     * We have a choice of 3 authentication options\n     *\n     *   1. none\n     *   2. vnc\n     *   3. sasl\n     *\n     * The channel can be run in 2 modes\n     *\n     *   1. clear\n     *   2. tls\n     *\n     * And TLS can use 2 types of credentials\n     *\n     *   1. anon\n     *   2. x509\n     *\n     * We thus have 9 possible logical combinations\n     *\n     *   1. clear + none\n     *   2. clear + vnc\n     *   3. clear + sasl\n     *   4. tls + anon + none\n     *   5. tls + anon + vnc\n     *   6. tls + anon + sasl\n     *   7. tls + x509 + none\n     *   8. tls + x509 + vnc\n     *   9. tls + x509 + sasl\n     *\n     * These need to be mapped into the VNC auth schemes\n     * in an appropriate manner. In regular VNC, all the\n     * TLS options get mapped into VNC_AUTH_VENCRYPT\n     * sub-auth types.\n     *\n     * In websockets, the https:// protocol already provides\n     * TLS support, so there is no need to make use of the\n     * VeNCrypt extension. Furthermore, websockets browser\n     * clients could not use VeNCrypt even if they wanted to,\n     * as they cannot control when the TLS handshake takes\n     * place. Thus there is no option but to rely on https://,\n     * meaning combinations 4->6 and 7->9 will be mapped to\n     * VNC auth schemes in the same way as combos 1->3.\n     *\n     * Regardless of fact that we have a different mapping to\n     * VNC auth mechs for plain VNC vs websockets VNC, the end\n     * result has the same security characteristics.\n     */\n    if (websocket || !tlscreds) {\n        if (password) {\n            VNC_DEBUG(\"Initializing VNC server with password auth\\n\");\n            *auth = VNC_AUTH_VNC;\n        } else if (sasl) {\n            VNC_DEBUG(\"Initializing VNC server with SASL auth\\n\");\n            *auth = VNC_AUTH_SASL;\n        } else {\n            VNC_DEBUG(\"Initializing VNC server with no auth\\n\");\n            *auth = VNC_AUTH_NONE;\n        }\n        *subauth = VNC_AUTH_INVALID;\n    } else {\n        bool is_x509 = object_dynamic_cast(OBJECT(tlscreds),\n                                           TYPE_QCRYPTO_TLS_CREDS_X509) != NULL;\n        bool is_anon = object_dynamic_cast(OBJECT(tlscreds),\n                                           TYPE_QCRYPTO_TLS_CREDS_ANON) != NULL;\n\n        if (!is_x509 && !is_anon) {\n            error_setg(errp,\n                       \"Unsupported TLS cred type %s\",\n                       object_get_typename(OBJECT(tlscreds)));\n            return -1;\n        }\n        *auth = VNC_AUTH_VENCRYPT;\n        if (password) {\n            if (is_x509) {\n                VNC_DEBUG(\"Initializing VNC server with x509 password auth\\n\");\n                *subauth = VNC_AUTH_VENCRYPT_X509VNC;\n            } else {\n                VNC_DEBUG(\"Initializing VNC server with TLS password auth\\n\");\n                *subauth = VNC_AUTH_VENCRYPT_TLSVNC;\n            }\n\n        } else if (sasl) {\n            if (is_x509) {\n                VNC_DEBUG(\"Initializing VNC server with x509 SASL auth\\n\");\n                *subauth = VNC_AUTH_VENCRYPT_X509SASL;\n            } else {\n                VNC_DEBUG(\"Initializing VNC server with TLS SASL auth\\n\");\n                *subauth = VNC_AUTH_VENCRYPT_TLSSASL;\n            }\n        } else {\n            if (is_x509) {\n                VNC_DEBUG(\"Initializing VNC server with x509 no auth\\n\");\n                *subauth = VNC_AUTH_VENCRYPT_X509NONE;\n            } else {\n                VNC_DEBUG(\"Initializing VNC server with TLS no auth\\n\");\n                *subauth = VNC_AUTH_VENCRYPT_TLSNONE;\n            }\n        }\n    }\n    return 0;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int vnc_display_get_address(const char *addrstr,\n                                   bool websocket,\n                                   bool reverse,\n                                   int displaynum,\n                                   int to,\n                                   bool has_ipv4,\n                                   bool has_ipv6,\n                                   bool ipv4,\n                                   bool ipv6,\n                                   SocketAddress **retaddr,\n                                   Error **errp)\n{\n    int ret = -1;\n    SocketAddress *addr = NULL;\n\n    addr = g_new0(SocketAddress, 1);\n\n    if (strncmp(addrstr, \"unix:\", 5) == 0) {\n        addr->type = SOCKET_ADDRESS_TYPE_UNIX;\n        addr->u.q_unix.path = g_strdup(addrstr + 5);\n\n        if (websocket) {\n            error_setg(errp, \"UNIX sockets not supported with websock\");\n            goto cleanup;\n        }\n\n        if (to) {\n            error_setg(errp, \"Port range not support with UNIX socket\");\n            goto cleanup;\n        }\n        ret = 0;\n    } else {\n        const char *port;\n        size_t hostlen;\n        unsigned long long baseport = 0;\n        InetSocketAddress *inet;\n\n        port = strrchr(addrstr, ':');\n        if (!port) {\n            if (websocket) {\n                hostlen = 0;\n                port = addrstr;\n            } else {\n                error_setg(errp, \"no vnc port specified\");\n                goto cleanup;\n            }\n        } else {\n            hostlen = port - addrstr;\n            port++;\n            if (*port == '\\0') {\n                error_setg(errp, \"vnc port cannot be empty\");\n                goto cleanup;\n            }\n        }\n\n        addr->type = SOCKET_ADDRESS_TYPE_INET;\n        inet = &addr->u.inet;\n        if (addrstr[0] == '[' && addrstr[hostlen - 1] == ']') {\n            inet->host = g_strndup(addrstr + 1, hostlen - 2);\n        } else {\n            inet->host = g_strndup(addrstr, hostlen);\n        }\n        /* plain VNC port is just an offset, for websocket\n         * port is absolute */\n        if (websocket) {\n            if (g_str_equal(addrstr, \"\") ||\n                g_str_equal(addrstr, \"on\")) {\n                if (displaynum == -1) {\n                    error_setg(errp, \"explicit websocket port is required\");\n                    goto cleanup;\n                }\n                inet->port = g_strdup_printf(\n                    \"%d\", displaynum + 5700);\n                if (to) {\n                    inet->has_to = true;\n                    inet->to = to + 5700;\n                }\n            } else {\n                inet->port = g_strdup(port);\n            }\n        } else {\n            int offset = reverse ? 0 : 5900;\n            if (parse_uint_full(port, &baseport, 10) < 0) {\n                error_setg(errp, \"can't convert to a number: %s\", port);\n                goto cleanup;\n            }\n            if (baseport > 65535 ||\n                baseport + offset > 65535) {\n                error_setg(errp, \"port %s out of range\", port);\n                goto cleanup;\n            }\n            inet->port = g_strdup_printf(\n                \"%d\", (int)baseport + offset);\n\n            if (to) {\n                inet->has_to = true;\n                inet->to = to + offset;\n            }\n        }\n\n        inet->ipv4 = ipv4;\n        inet->has_ipv4 = has_ipv4;\n        inet->ipv6 = ipv6;\n        inet->has_ipv6 = has_ipv6;\n\n        ret = baseport;\n    }\n\n    *retaddr = addr;\n\n cleanup:\n    if (ret < 0) {\n        qapi_free_SocketAddress(addr);\n    }\n    return ret;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int vnc_display_get_addresses(QemuOpts *opts,\n                                     bool reverse,\n                                     SocketAddressList **saddr_list_ret,\n                                     SocketAddressList **wsaddr_list_ret,\n                                     Error **errp)\n{\n    SocketAddress *saddr = NULL;\n    SocketAddress *wsaddr = NULL;\n    g_autoptr(SocketAddressList) saddr_list = NULL;\n    SocketAddressList **saddr_tail = &saddr_list;\n    SocketAddress *single_saddr = NULL;\n    g_autoptr(SocketAddressList) wsaddr_list = NULL;\n    SocketAddressList **wsaddr_tail = &wsaddr_list;\n    QemuOptsIter addriter;\n    const char *addr;\n    int to = qemu_opt_get_number(opts, \"to\", 0);\n    bool has_ipv4 = qemu_opt_get(opts, \"ipv4\");\n    bool has_ipv6 = qemu_opt_get(opts, \"ipv6\");\n    bool ipv4 = qemu_opt_get_bool(opts, \"ipv4\", false);\n    bool ipv6 = qemu_opt_get_bool(opts, \"ipv6\", false);\n    int displaynum = -1;\n\n    addr = qemu_opt_get(opts, \"vnc\");\n    if (addr == NULL || g_str_equal(addr, \"none\")) {\n        return 0;\n    }\n    if (qemu_opt_get(opts, \"websocket\") &&\n        !qcrypto_hash_supports(QCRYPTO_HASH_ALG_SHA1)) {\n        error_setg(errp,\n                   \"SHA1 hash support is required for websockets\");\n        return -1;\n    }\n\n    qemu_opt_iter_init(&addriter, opts, \"vnc\");\n    while ((addr = qemu_opt_iter_next(&addriter)) != NULL) {\n        int rv;\n        rv = vnc_display_get_address(addr, false, reverse, 0, to,\n                                     has_ipv4, has_ipv6,\n                                     ipv4, ipv6,\n                                     &saddr, errp);\n        if (rv < 0) {\n            return -1;\n        }\n        /* Historical compat - first listen address can be used\n         * to set the default websocket port\n         */\n        if (displaynum == -1) {\n            displaynum = rv;\n        }\n        QAPI_LIST_APPEND(saddr_tail, saddr);\n    }\n\n    if (saddr_list && !saddr_list->next) {\n        single_saddr = saddr_list->value;\n    } else {\n        /*\n         * If we had multiple primary displays, we don't do defaults\n         * for websocket, and require explicit config instead.\n         */\n        displaynum = -1;\n    }\n\n    qemu_opt_iter_init(&addriter, opts, \"websocket\");\n    while ((addr = qemu_opt_iter_next(&addriter)) != NULL) {\n        if (vnc_display_get_address(addr, true, reverse, displaynum, to,\n                                    has_ipv4, has_ipv6,\n                                    ipv4, ipv6,\n                                    &wsaddr, errp) < 0) {\n            return -1;\n        }\n\n        /* Historical compat - if only a single listen address was\n         * provided, then this is used to set the default listen\n         * address for websocket too\n         */\n        if (single_saddr &&\n            single_saddr->type == SOCKET_ADDRESS_TYPE_INET &&\n            wsaddr->type == SOCKET_ADDRESS_TYPE_INET &&\n            g_str_equal(wsaddr->u.inet.host, \"\") &&\n            !g_str_equal(single_saddr->u.inet.host, \"\")) {\n            g_free(wsaddr->u.inet.host);\n            wsaddr->u.inet.host = g_strdup(single_saddr->u.inet.host);\n        }\n\n        QAPI_LIST_APPEND(wsaddr_tail, wsaddr);\n    }\n\n    *saddr_list_ret = g_steal_pointer(&saddr_list);\n    *wsaddr_list_ret = g_steal_pointer(&wsaddr_list);\n    return 0;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int vnc_display_connect(VncDisplay *vd,\n                               SocketAddressList *saddr_list,\n                               SocketAddressList *wsaddr_list,\n                               Error **errp)\n{\n    /* connect to viewer */\n    QIOChannelSocket *sioc = NULL;\n    if (wsaddr_list) {\n        error_setg(errp, \"Cannot use websockets in reverse mode\");\n        return -1;\n    }\n    if (!saddr_list || saddr_list->next) {\n        error_setg(errp, \"Expected a single address in reverse mode\");\n        return -1;\n    }\n    /* TODO SOCKET_ADDRESS_TYPE_FD when fd has AF_UNIX */\n    vd->is_unix = saddr_list->value->type == SOCKET_ADDRESS_TYPE_UNIX;\n    sioc = qio_channel_socket_new();\n    qio_channel_set_name(QIO_CHANNEL(sioc), \"vnc-reverse\");\n    if (qio_channel_socket_connect_sync(sioc, saddr_list->value, errp) < 0) {\n        object_unref(OBJECT(sioc));\n        return -1;\n    }\n    vnc_connect(vd, sioc, false, false);\n    object_unref(OBJECT(sioc));\n    return 0;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static int vnc_display_listen(VncDisplay *vd,\n                              SocketAddressList *saddr_list,\n                              SocketAddressList *wsaddr_list,\n                              Error **errp)\n{\n    SocketAddressList *el;\n\n    if (saddr_list) {\n        vd->listener = qio_net_listener_new();\n        qio_net_listener_set_name(vd->listener, \"vnc-listen\");\n        for (el = saddr_list; el; el = el->next) {\n            if (qio_net_listener_open_sync(vd->listener,\n                                           el->value, 1,\n                                           errp) < 0)  {\n                return -1;\n            }\n        }\n\n        qio_net_listener_set_client_func(vd->listener,\n                                         vnc_listen_io, vd, NULL);\n    }\n\n    if (wsaddr_list) {\n        vd->wslistener = qio_net_listener_new();\n        qio_net_listener_set_name(vd->wslistener, \"vnc-ws-listen\");\n        for (el = wsaddr_list; el; el = el->next) {\n            if (qio_net_listener_open_sync(vd->wslistener,\n                                           el->value, 1,\n                                           errp) < 0)  {\n                return -1;\n            }\n        }\n\n        qio_net_listener_set_client_func(vd->wslistener,\n                                         vnc_listen_io, vd, NULL);\n    }\n\n    return 0;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "bool vnc_display_update(DisplayUpdateOptionsVNC *arg, Error **errp)\n{\n    VncDisplay *vd = vnc_display_find(NULL);\n\n    if (!vd) {\n        error_setg(errp, \"Can not find vnc display\");\n        return false;\n    }\n\n    if (arg->has_addresses) {\n        if (vd->listener) {\n            qio_net_listener_disconnect(vd->listener);\n            object_unref(OBJECT(vd->listener));\n            vd->listener = NULL;\n        }\n\n        if (vnc_display_listen(vd, arg->addresses, NULL, errp) < 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_display_open(const char *id, Error **errp)\n{\n    VncDisplay *vd = vnc_display_find(id);\n    QemuOpts *opts = qemu_opts_find(&qemu_vnc_opts, id);\n    g_autoptr(SocketAddressList) saddr_list = NULL;\n    g_autoptr(SocketAddressList) wsaddr_list = NULL;\n    const char *share, *device_id;\n    QemuConsole *con;\n    bool password = false;\n    bool reverse = false;\n    const char *credid;\n    bool sasl = false;\n    const char *tlsauthz;\n    const char *saslauthz;\n    int lock_key_sync = 1;\n    int key_delay_ms;\n    const char *audiodev;\n    const char *passwordSecret;\n\n    if (!vd) {\n        error_setg(errp, \"VNC display not active\");\n        return;\n    }\n    vnc_display_close(vd);\n\n    if (!opts) {\n        return;\n    }\n\n    reverse = qemu_opt_get_bool(opts, \"reverse\", false);\n    if (vnc_display_get_addresses(opts, reverse, &saddr_list, &wsaddr_list,\n                                  errp) < 0) {\n        goto fail;\n    }\n\n\n    passwordSecret = qemu_opt_get(opts, \"password-secret\");\n    if (passwordSecret) {\n        if (qemu_opt_get(opts, \"password\")) {\n            error_setg(errp,\n                       \"'password' flag is redundant with 'password-secret'\");\n            goto fail;\n        }\n        vd->password = qcrypto_secret_lookup_as_utf8(passwordSecret,\n                                                     errp);\n        if (!vd->password) {\n            goto fail;\n        }\n        password = true;\n    } else {\n        password = qemu_opt_get_bool(opts, \"password\", false);\n    }\n    if (password) {\n        if (!qcrypto_cipher_supports(\n                QCRYPTO_CIPHER_ALG_DES, QCRYPTO_CIPHER_MODE_ECB)) {\n            error_setg(errp,\n                       \"Cipher backend does not support DES algorithm\");\n            goto fail;\n        }\n    }\n\n    lock_key_sync = qemu_opt_get_bool(opts, \"lock-key-sync\", true);\n    key_delay_ms = qemu_opt_get_number(opts, \"key-delay-ms\", 10);\n    sasl = qemu_opt_get_bool(opts, \"sasl\", false);\n#ifndef CONFIG_VNC_SASL\n    if (sasl) {\n        error_setg(errp, \"VNC SASL auth requires cyrus-sasl support\");\n        goto fail;\n    }\n#endif /* CONFIG_VNC_SASL */\n    credid = qemu_opt_get(opts, \"tls-creds\");\n    if (credid) {\n        Object *creds;\n        creds = object_resolve_path_component(\n            object_get_objects_root(), credid);\n        if (!creds) {\n            error_setg(errp, \"No TLS credentials with id '%s'\",\n                       credid);\n            goto fail;\n        }\n        vd->tlscreds = (QCryptoTLSCreds *)\n            object_dynamic_cast(creds,\n                                TYPE_QCRYPTO_TLS_CREDS);\n        if (!vd->tlscreds) {\n            error_setg(errp, \"Object with id '%s' is not TLS credentials\",\n                       credid);\n            goto fail;\n        }\n        object_ref(OBJECT(vd->tlscreds));\n\n        if (!qcrypto_tls_creds_check_endpoint(vd->tlscreds,\n                                              QCRYPTO_TLS_CREDS_ENDPOINT_SERVER,\n                                              errp)) {\n            goto fail;\n        }\n    }\n    tlsauthz = qemu_opt_get(opts, \"tls-authz\");\n    if (tlsauthz && !vd->tlscreds) {\n        error_setg(errp, \"'tls-authz' provided but TLS is not enabled\");\n        goto fail;\n    }\n\n    saslauthz = qemu_opt_get(opts, \"sasl-authz\");\n    if (saslauthz && !sasl) {\n        error_setg(errp, \"'sasl-authz' provided but SASL auth is not enabled\");\n        goto fail;\n    }\n\n    share = qemu_opt_get(opts, \"share\");\n    if (share) {\n        if (strcmp(share, \"ignore\") == 0) {\n            vd->share_policy = VNC_SHARE_POLICY_IGNORE;\n        } else if (strcmp(share, \"allow-exclusive\") == 0) {\n            vd->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n        } else if (strcmp(share, \"force-shared\") == 0) {\n            vd->share_policy = VNC_SHARE_POLICY_FORCE_SHARED;\n        } else {\n            error_setg(errp, \"unknown vnc share= option\");\n            goto fail;\n        }\n    } else {\n        vd->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n    }\n    vd->connections_limit = qemu_opt_get_number(opts, \"connections\", 32);\n\n#ifdef CONFIG_VNC_JPEG\n    vd->lossy = qemu_opt_get_bool(opts, \"lossy\", false);\n#endif\n    vd->non_adaptive = qemu_opt_get_bool(opts, \"non-adaptive\", false);\n    /* adaptive updates are only used with tight encoding and\n     * if lossy updates are enabled so we can disable all the\n     * calculations otherwise */\n    if (!vd->lossy) {\n        vd->non_adaptive = true;\n    }\n\n    vd->power_control = qemu_opt_get_bool(opts, \"power-control\", false);\n\n    if (tlsauthz) {\n        vd->tlsauthzid = g_strdup(tlsauthz);\n    }\n#ifdef CONFIG_VNC_SASL\n    if (sasl) {\n        if (saslauthz) {\n            vd->sasl.authzid = g_strdup(saslauthz);\n        }\n    }\n#endif\n\n    if (vnc_display_setup_auth(&vd->auth, &vd->subauth,\n                               vd->tlscreds, password,\n                               sasl, false, errp) < 0) {\n        goto fail;\n    }\n    trace_vnc_auth_init(vd, 0, vd->auth, vd->subauth);\n\n    if (vnc_display_setup_auth(&vd->ws_auth, &vd->ws_subauth,\n                               vd->tlscreds, password,\n                               sasl, true, errp) < 0) {\n        goto fail;\n    }\n    trace_vnc_auth_init(vd, 1, vd->ws_auth, vd->ws_subauth);\n\n#ifdef CONFIG_VNC_SASL\n    if (sasl && !vnc_sasl_server_init(errp)) {\n        goto fail;\n    }\n#endif\n    vd->lock_key_sync = lock_key_sync;\n    if (lock_key_sync) {\n        vd->led = qemu_add_led_event_handler(kbd_leds, vd);\n    }\n    vd->ledstate = 0;\n\n    audiodev = qemu_opt_get(opts, \"audiodev\");\n    if (audiodev) {\n        vd->audio_state = audio_state_by_name(audiodev);\n        if (!vd->audio_state) {\n            error_setg(errp, \"Audiodev '%s' not found\", audiodev);\n            goto fail;\n        }\n    }\n\n    device_id = qemu_opt_get(opts, \"display\");\n    if (device_id) {\n        int head = qemu_opt_get_number(opts, \"head\", 0);\n        Error *err = NULL;\n\n        con = qemu_console_lookup_by_device_name(device_id, head, &err);\n        if (err) {\n            error_propagate(errp, err);\n            goto fail;\n        }\n    } else {\n        con = NULL;\n    }\n\n    if (con != vd->dcl.con) {\n        qkbd_state_free(vd->kbd);\n        unregister_displaychangelistener(&vd->dcl);\n        vd->dcl.con = con;\n        register_displaychangelistener(&vd->dcl);\n        vd->kbd = qkbd_state_init(vd->dcl.con);\n    }\n    qkbd_state_set_delay(vd->kbd, key_delay_ms);\n\n    if (saddr_list == NULL) {\n        return;\n    }\n\n    if (reverse) {\n        if (vnc_display_connect(vd, saddr_list, wsaddr_list, errp) < 0) {\n            goto fail;\n        }\n    } else {\n        if (vnc_display_listen(vd, saddr_list, wsaddr_list, errp) < 0) {\n            goto fail;\n        }\n    }\n\n    if (qemu_opt_get(opts, \"to\")) {\n        vnc_display_print_local_addr(vd);\n    }\n\n    /* Success */\n    return;\n\nfail:\n    vnc_display_close(vd);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_display_add_client(const char *id, int csock, bool skipauth)\n{\n    VncDisplay *vd = vnc_display_find(id);\n    QIOChannelSocket *sioc;\n\n    if (!vd) {\n        return;\n    }\n\n    sioc = qio_channel_socket_new_fd(csock, NULL);\n    if (sioc) {\n        qio_channel_set_name(QIO_CHANNEL(sioc), \"vnc-server\");\n        vnc_connect(vd, sioc, skipauth, false);\n        object_unref(OBJECT(sioc));\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_auto_assign_id(QemuOptsList *olist, QemuOpts *opts)\n{\n    int i = 2;\n    char *id;\n\n    id = g_strdup(\"default\");\n    while (qemu_opts_find(olist, id)) {\n        g_free(id);\n        id = g_strdup_printf(\"vnc%d\", i++);\n    }\n    qemu_opts_set_id(opts, id);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "void vnc_parse(const char *str)\n{\n    QemuOptsList *olist = qemu_find_opts(\"vnc\");\n    QemuOpts *opts = qemu_opts_parse_noisily(olist, str, !is_help_option(str));\n    const char *id;\n\n    if (!opts) {\n        exit(1);\n    }\n\n    id = qemu_opts_id(opts);\n    if (!id) {\n        /* auto-assign id if not present */\n        vnc_auto_assign_id(olist, opts);\n    }\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "int vnc_init_func(void *opaque, QemuOpts *opts, Error **errp)\n{\n    Error *local_err = NULL;\n    char *id = (char *)qemu_opts_id(opts);\n\n    assert(id);\n    vnc_display_init(id, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return -1;\n    }\n    vnc_display_open(id, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        return -1;\n    }\n    return 0;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "vnc.c", "func": "static void vnc_register_config(void)\n{\n    qemu_add_opts(&qemu_vnc_opts);\n}\n", "label": "GUI"}
{"project": "qemu", "file": "x_keymap.c", "func": "static gboolean check_for_xwin(Display *dpy)\n{\n    const char *vendor = ServerVendor(dpy);\n\n    trace_xkeymap_vendor(vendor);\n\n    if (strstr(vendor, \"Cygwin/X\")) {\n        return TRUE;\n    }\n\n    return FALSE;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "x_keymap.c", "func": "static gboolean check_for_xquartz(Display *dpy)\n{\n    int nextensions;\n    int i;\n    gboolean match = FALSE;\n    char **extensions = XListExtensions(dpy, &nextensions);\n    for (i = 0 ; extensions != NULL && i < nextensions ; i++) {\n        trace_xkeymap_extension(extensions[i]);\n        if (strcmp(extensions[i], \"Apple-WM\") == 0 ||\n            strcmp(extensions[i], \"Apple-DRI\") == 0) {\n            match = TRUE;\n        }\n    }\n    if (extensions) {\n        XFreeExtensionList(extensions);\n    }\n\n    return match;\n}\n", "label": "GUI"}
{"project": "qemu", "file": "x_keymap.c", "func": "const guint16 *qemu_xkeymap_mapping_table(Display *dpy, size_t *maplen)\n{\n    XkbDescPtr desc;\n    const gchar *keycodes = NULL;\n    const guint16 *map;\n\n    /* There is no easy way to determine what X11 server\n     * and platform & keyboard driver is in use. Thus we\n     * do best guess heuristics.\n     *\n     * This will need more work for people with other\n     * X servers..... patches welcomed.\n     */\n\n    desc = XkbGetMap(dpy,\n                     XkbGBN_AllComponentsMask,\n                     XkbUseCoreKbd);\n    if (desc) {\n        if (XkbGetNames(dpy, XkbKeycodesNameMask, desc) == Success) {\n            keycodes = XGetAtomName (dpy, desc->names->keycodes);\n            if (!keycodes) {\n                g_warning(\"could not lookup keycode name\");\n            } else {\n                trace_xkeymap_keycodes(keycodes);\n            }\n        }\n        XkbFreeKeyboard(desc, XkbGBN_AllComponentsMask, True);\n    }\n\n    if (check_for_xwin(dpy)) {\n        trace_xkeymap_keymap(\"xwin\");\n        *maplen = qemu_input_map_xorgxwin_to_qcode_len;\n        map = qemu_input_map_xorgxwin_to_qcode;\n    } else if (check_for_xquartz(dpy)) {\n        trace_xkeymap_keymap(\"xquartz\");\n        *maplen = qemu_input_map_xorgxquartz_to_qcode_len;\n        map = qemu_input_map_xorgxquartz_to_qcode;\n    } else if ((keycodes && g_str_has_prefix(keycodes, \"evdev\")) ||\n               (XKeysymToKeycode(dpy, XK_Page_Up) == 0x70)) {\n        trace_xkeymap_keymap(\"evdev\");\n        *maplen = qemu_input_map_xorgevdev_to_qcode_len;\n        map = qemu_input_map_xorgevdev_to_qcode;\n    } else if ((keycodes && g_str_has_prefix(keycodes, \"xfree86\")) ||\n               (XKeysymToKeycode(dpy, XK_Page_Up) == 0x63)) {\n        trace_xkeymap_keymap(\"kbd\");\n        *maplen = qemu_input_map_xorgkbd_to_qcode_len;\n        map = qemu_input_map_xorgkbd_to_qcode;\n    } else {\n        trace_xkeymap_keymap(\"NULL\");\n        g_warning(\"Unknown X11 keycode mapping '%s'.\\n\"\n                  \"Please report to qemu-devel@nongnu.org\\n\"\n                  \"including the following information:\\n\"\n                  \"\\n\"\n                  \"  - Operating system\\n\"\n                  \"  - X11 Server\\n\"\n                  \"  - xprop -root\\n\"\n                  \"  - xdpyinfo\\n\",\n                  keycodes ? keycodes : \"<null>\");\n        map = NULL;\n    }\n    if (keycodes) {\n        XFree((void *)keycodes);\n    }\n    return map;\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "static void PopulateTree(TreeView* treeView, TreeModel* tm) {\n    TreeItem root = tm->Root();\n    PopulateTreeItem(treeView, root, nullptr);\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "TreeItem GetOrSelectTreeItemAtPos(ContextMenuEvent* args, POINT& pt) {\n    TreeView* treeView = (TreeView*)args->w;\n    TreeModel* tm = treeView->treeModel;\n    HWND hwnd = treeView->hwnd;\n\n    TreeItem ti;\n    pt = {args->mouseWindow.x, args->mouseWindow.y};\n    if (pt.x == -1 || pt.y == -1) {\n        // no mouse position when launched via keyboard shortcut\n        // use position of selected item to show menu\n        ti = treeView->GetSelection();\n        if (ti == TreeModel::kNullItem) {\n            return TreeModel::kNullItem;\n        }\n        RECT rcItem;\n        if (treeView->GetItemRect(ti, true, rcItem)) {\n            // rcItem is local to window, map to global screen position\n            MapWindowPoints(hwnd, HWND_DESKTOP, (POINT*)&rcItem, 2);\n            pt.x = rcItem.left;\n            pt.y = rcItem.bottom;\n        }\n    } else {\n        ti = treeView->GetItemAt(pt.x, pt.y);\n        if (ti == TreeModel::kNullItem) {\n            // only show context menu if over a node in tree\n            return TreeModel::kNullItem;\n        }\n        // context menu acts on this item so select it\n        // for better visual feedback to the user\n        treeView->SelectItem(ti);\n        pt.x = args->mouseScreen.x;\n        pt.y = args->mouseScreen.y;\n    }\n    return ti;\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "static void PaintParentBackground(HWND hwnd, HDC hdc) {\n    HWND parent = GetParent(hwnd);\n    POINT pt = {0, 0};\n    MapWindowPoints(hwnd, parent, &pt, 1);\n    SetViewportOrgEx(hdc, -pt.x, -pt.y, &pt);\n    SendMessageW(parent, WM_ERASEBKGND, (WPARAM)hdc, 0);\n    SetViewportOrgEx(hdc, pt.x, pt.y, nullptr);\n\n    // TODO: needed to force repaint of tab area after closing a window\n    InvalidateRect(parent, nullptr, TRUE);\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "static void MaybeUpdateTooltip(HWND hwnd, HWND ttHwnd, const char* text) {\n    if (!ttHwnd) {\n        return;\n    }\n\n    {\n        TOOLINFO ti{0};\n        ti.cbSize = sizeof(ti);\n        ti.hwnd = hwnd;\n        ti.uId = 0;\n        SendMessage(ttHwnd, TTM_DELTOOL, 0, (LPARAM)&ti);\n    }\n\n    {\n        TOOLINFO ti{0};\n        ti.cbSize = sizeof(ti);\n        ti.hwnd = hwnd;\n        ti.uFlags = TTF_SUBCLASS;\n        // ti.lpszText = LPSTR_TEXTCALLBACK;\n        WCHAR* ws = ToWstrTemp(text);\n        ti.lpszText = ws;\n        ti.uId = 0;\n        ti.rect = ClientRECT(hwnd);\n        SendMessage(ttHwnd, TTM_ADDTOOL, 0, (LPARAM)&ti);\n    }\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "static void MaybeUpdateTooltipText(TabsCtrl* tabsCtrl, int idx) {\n    TabInfo* tab = tabsCtrl->GetTab(idx);\n    char* tooltip = tab->tooltip;\n    if (str::Eq(tabsCtrl->currTooltipText, tooltip)) {\n        return;\n    }\n    tabsCtrl->currTooltipText = tooltip;\n#if 1\n    HWND ttHwnd = tabsCtrl->GetToolTipsHwnd();\n    MaybeUpdateTooltip(tabsCtrl->hwnd, ttHwnd, tooltip);\n#else\n    // TODO: why this doesn't work?\n    TOOLINFO ti{0};\n    ti.cbSize = sizeof(ti);\n    ti.hwnd = hwnd;\n    ti.uFlags = TTF_SUBCLASS;\n    ti.lpszText = currTooltipText.Get();\n    ti.uId = 0;\n    ti.rect = ClientRECT(hwnd);\n    SendMessage(ttHwnd, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);\n#endif\n    SendMessage(ttHwnd, TTM_POP, 0, 0);\n    SendMessage(ttHwnd, TTM_POPUP, 0, 0);\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "static void TriggerSelectionChanged(TabsCtrl* tabs) {\n    if (!tabs->onSelectionChanged) {\n        return;\n    }\n    TabsSelectionChangedEvent ev;\n    ev.tabs = tabs;\n    tabs->onSelectionChanged(&ev);\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "static bool TriggerSelectionChanging(TabsCtrl* tabs) {\n    if (!tabs->onSelectionChanging) {\n        // allow changing\n        return false;\n    }\n\n    TabsSelectionChangingEvent ev;\n    ev.tabs = tabs;\n    bool res = tabs->onSelectionChanging(&ev);\n    return (LRESULT)res;\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "static void TriggerTabClosed(TabsCtrl* tabs, int tabIdx) {\n    if ((tabIdx < 0) || !tabs->onTabClosed) {\n        return;\n    }\n    TabClosedEvent ev;\n    ev.tabs = tabs;\n    ev.tabIdx = tabIdx;\n    tabs->onTabClosed(&ev);\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "static void TriggerTabDragged(TabsCtrl* tabs, int tab1, int tab2) {\n    if (!tabs->onTabDragged) {\n        return;\n    }\n    TabDraggedEvent ev;\n    ev.tabs = tabs;\n    ev.tab1 = tab1;\n    ev.tab2 = tab2;\n    tabs->onTabDragged(&ev);\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "static void UpdateAfterDrag(TabsCtrl* tabsCtrl, int tab1, int tab2) {\n    int nTabs = tabsCtrl->GetTabCount();\n    bool badState = (tab1 == tab2) || (tab1 < 0) || (tab2 < 0) || (tab1 >= nTabs) || (tab2 >= nTabs);\n    if (badState) {\n        logfa(\"tab1: %d, tab2: %d, nTabs: %d\\n\", tab1, tab2, nTabs);\n        ReportIf(true);\n        return;\n    }\n\n    auto&& tabs = tabsCtrl->tabs;\n    std::swap(tabs.at(tab1), tabs.at(tab2));\n\n    // TODO: simplify?\n    int current = tabsCtrl->GetSelected();\n    int newSelected = tab1;\n    if (tab1 == current) {\n        newSelected = tab2;\n    }\n    tabsCtrl->SetSelected(newSelected);\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "int RunMessageLoop(HACCEL accelTable, HWND hwndDialog) {\n    MSG msg;\n    while (GetMessage(&msg, nullptr, 0, 0)) {\n        if (PreTranslateMessage(msg)) {\n            continue;\n        }\n        if (TranslateAccelerator(msg.hwnd, accelTable, &msg)) {\n            continue;\n        }\n        if (hwndDialog && IsDialogMessage(hwndDialog, &msg)) {\n            continue;\n        }\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n    return (int)msg.wParam;\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "HWND GetCurrentModelessDialog() {\n    return g_currentModelessDialog;\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "void SetCurrentModelessDialog(HWND hwnd) {\n    g_currentModelessDialog = hwnd;\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "void DeleteWnd(Static** wnd) {\n    delete *wnd;\n    *wnd = nullptr;\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "void DeleteWnd(Button** wnd) {\n    delete *wnd;\n    *wnd = nullptr;\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "void DeleteWnd(Edit** wnd) {\n    delete *wnd;\n    *wnd = nullptr;\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "void DeleteWnd(Checkbox** wnd) {\n    delete *wnd;\n    *wnd = nullptr;\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "void DeleteWnd(Progress** wnd) {\n    delete *wnd;\n    *wnd = nullptr;\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "void DrawCloseButton(const DrawCloseButtonArgs& args) {\n    bool isHover = args.isHover;\n    const Rect& r = args.r;\n    Gdiplus::Graphics g(args.hdc);\n    g.SetCompositingQuality(Gdiplus::CompositingQualityHighQuality);\n    g.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);\n    g.SetPageUnit(Gdiplus::UnitPixel);\n    HWND hwnd = WindowFromDC(args.hdc);\n    // GDI+ doesn't pick up the window's orientation through the device context,\n    // so we have to explicitly mirror all rendering horizontally\n    if (IsRtl(hwnd)) {\n        g.ScaleTransform(-1, 1);\n        g.TranslateTransform((float)ClientRect(hwnd).dx, 0, Gdiplus::MatrixOrderAppend);\n    }\n    Gdiplus::Color c;\n\n    // in onhover state, background is a red-ish circle\n    if (args.isHover) {\n        c.SetFromCOLORREF(args.colHoverBg);\n        Gdiplus::SolidBrush b(c);\n        g.FillEllipse(&b, r.x, r.y, r.dx - 2, r.dy - 2);\n    }\n\n    // draw 'x'\n    c.SetFromCOLORREF(args.isHover ? args.colXHover : args.colX);\n    g.TranslateTransform((float)r.x, (float)r.y);\n    Gdiplus::Pen p(c, 2);\n    if (isHover) {\n        g.DrawLine(&p, Gdiplus::Point(4, 4), Gdiplus::Point(r.dx - 6, r.dy - 6));\n        g.DrawLine(&p, Gdiplus::Point(r.dx - 6, 4), Gdiplus::Point(4, r.dy - 6));\n    } else {\n        g.DrawLine(&p, Gdiplus::Point(4, 5), Gdiplus::Point(r.dx - 6, r.dy - 5));\n        g.DrawLine(&p, Gdiplus::Point(r.dx - 6, 5), Gdiplus::Point(4, r.dy - 5));\n    }\n}\n", "label": "GUI"}
{"project": "sumatrapdf", "file": "WinGui.cpp", "func": "void DrawCloseButton2(const DrawCloseButtonArgs& args) {\n    bool isHover = args.isHover;\n    HDC hdc = args.hdc;\n    const Rect& r = args.r;\n    COLORREF lineCol = args.colX;\n    if (args.isHover) {\n        lineCol = args.colXHover;\n        int p = 3;\n        HWND hwnd = WindowFromDC(hdc);\n        DpiScale(hwnd, p);\n        AutoDeleteBrush brush(CreateSolidBrush(args.colHoverBg));\n        ScopedSelectBrush br(hdc, brush);\n        RECT r2 = ToRECT(r);\n        r2.left -= p;\n        r2.right += p;\n        r2.top -= p;\n        r2.bottom += p;\n        FillRect(hdc, &r2, brush);\n        // Ellipse(hdc, r2.left, r2.top, r2.right, r2.bottom);\n    }\n    AutoDeletePen pen(CreatePen(PS_SOLID, 2, lineCol));\n    ScopedSelectPen p(hdc, pen);\n    MoveToEx(hdc, r.x, r.y, nullptr);\n    LineTo(hdc, r.x + r.dx, r.y + r.dy);\n\n    MoveToEx(hdc, r.x + r.dx, r.y, nullptr);\n    LineTo(hdc, r.x, r.y + r.dy);\n}\n", "label": "GUI"}
{"project": "vlc", "file": "message_test.c", "func": "static void check_msg(struct vlc_http_msg *in,\n                      void (*cb)(const struct vlc_http_msg *))\n{\n    struct vlc_http_msg *out;\n    char *m1;\n    size_t len;\n\n    cb(in);\n\n    m1 = vlc_http_msg_format(in, &len, false, true);\n    assert(m1 != NULL);\n    assert(strlen(m1) == len);\n    out = vlc_http_msg_headers(m1);\n    fprintf(stderr, \"%s\", m1);\n    free(m1);\n    /* XXX: request parsing not implemented/needed yet */\n    if (vlc_http_msg_get_status(in) >= 0)\n    {\n        assert(out != NULL);\n        cb(out);\n        vlc_http_msg_destroy(out);\n    }\n\n    out = (struct vlc_http_msg *)vlc_http_msg_h2_frame(in, 1, true);\n    assert(out != NULL);\n    cb(out);\n    assert(vlc_http_msg_read(out) == NULL);\n    vlc_http_msg_destroy(out);\n\n    cb(in);\n    vlc_http_msg_destroy(in);\n}\n", "label": "network"}
{"project": "vlc", "file": "message_test.c", "func": "static time_t parse_date(const char *str)\n{\n    struct vlc_http_msg *m;\n    time_t t1, t2;\n\n    m = vlc_http_req_create(\"GET\", \"http\", \"www.example.com\", \"/\");\n    assert(m != NULL);\n    assert(vlc_http_msg_add_header(m, \"Date\", \"%s\", str) == 0);\n    t1 = vlc_http_msg_get_atime(m);\n    assert(vlc_http_msg_add_header(m, \"Last-Modified\", \"%s\", str) == 0);\n    t2 = vlc_http_msg_get_mtime(m);\n    assert(vlc_http_msg_get_retry_after(m) == 0);\n    assert(vlc_http_msg_add_header(m, \"Retry-After\", \"%s\", str) == 0);\n    vlc_http_msg_get_retry_after(m);\n    vlc_http_msg_destroy(m);\n\n    assert(t1 == t2);\n    return t1;\n}\n", "label": "network"}
{"project": "vlc", "file": "message_test.c", "func": "static const char *check_realm(const char *line, const char *realm)\n{\n    struct vlc_http_msg *m;\n    char *value;\n\n    m = vlc_http_resp_create(401);\n    assert(m != NULL);\n    assert(vlc_http_msg_add_header(m, \"WWW-Authenticate\", \"%s\", line) == 0);\n    value = vlc_http_msg_get_basic_realm(m);\n    if (realm == NULL)\n        assert(value == NULL);\n    else\n    {\n        assert(value != NULL);\n        assert(!strcmp(value, realm));\n        free(value);\n    }\n    vlc_http_msg_destroy(m);\n    return realm;\n}\n", "label": "network"}
{"project": "vlc", "file": "message_test.c", "func": "int main(void)\n{\n    struct vlc_http_msg *m;\n    const char *str;\n    int ret;\n\n    /* Formatting and parsing */\n    m = vlc_http_req_create(\"GET\", \"http\", \"www.example.com\", \"/\");\n    assert(m != NULL);\n    ret = vlc_http_msg_add_header(m, \"Cache-Control\", \"no-cache\");\n    assert(ret == 0);\n    vlc_http_msg_add_header(m, \"Custom-Key\", \"%s\", \"custom-value\");\n    assert(ret == 0);\n    check_msg(m, check_req);\n\n    m = vlc_http_resp_create(200);\n    assert(m != NULL);\n    ret = vlc_http_msg_add_header(m, \"cache-control\", \"private\");\n    assert(ret == 0);\n    ret = vlc_http_msg_add_header(m, \"date\", \"Mon, 21 Oct 2013 20:13:22 GMT\");\n    assert(ret == 0);\n    ret = vlc_http_msg_add_header(m, \"location\", \"https://www.example.com\");\n    assert(ret == 0);\n    ret = vlc_http_msg_add_header(m, \"content-encoding\", \"gzip\");\n    assert(ret == 0);\n    ret = vlc_http_msg_add_header(m, \"set-cookie\", \"foo=%s; max-age=%u; \"\n                                  \"version=%u\", \"ASDJKHQKBZXOQWEOPIUAXQWEOIU\",\n                                  3600, 1);\n    assert(ret == 0);\n    check_msg(m, check_resp);\n\n    m = vlc_http_req_create(\"CONNECT\", NULL, \"www.example.com\", NULL);\n    assert(m != NULL);\n    check_msg(m, check_connect);\n\n    /* Helpers */\n    assert(parse_date(\"Sun, 06 Nov 1994 08:49:37 GMT\") == 784111777);\n    assert(parse_date(\"Sunday, 06-Nov-94 08:49:37 GMT\") == 784111777);\n    assert(parse_date(\"Sun Nov  6 08:49:37 1994\") == 784111777);\n    assert(parse_date(\"Sunday, 06-Nov-14 08:49:37 GMT\") == 1415263777);\n    assert(parse_date(\"Sun, 06 Bug 1994 08:49:37 GMT\") == -1);\n    assert(parse_date(\"bogus\") == -1);\n\n    assert(check_realm(\"Basic realm=\\\"kingdom\\\"\", \"kingdom\"));\n    assert(check_realm(\"BaSiC REALM= \\\"kingdom\\\"\", \"kingdom\"));\n    assert(check_realm(\"basic Realm\\t=\\\"kingdom\\\"\", \"kingdom\"));\n    assert(check_realm(\"Basic charset=\\\"utf-8\\\", realm=\\\"kingdom\\\"\",\n                       \"kingdom\"));\n    assert(check_realm(\"Basic realm=\\\"Realm is \\\\\\\"Hello world!\\\\\\\"\\\"\",\n                       \"Realm is \\\"Hello world!\\\"\"));\n    assert(check_realm(\"Basic\", NULL) == NULL);\n\n    m = vlc_http_req_create(\"PRI\", \"https\", \"*\", NULL);\n    assert(m != NULL);\n\n    assert(vlc_http_msg_add_agent(m, \"Foo\") == 0);\n    assert(vlc_http_msg_add_agent(m, \"Foo/1.0\") == 0);\n    assert(vlc_http_msg_add_agent(m, \"Foo/1.0 (Hello world) Bar/2.3\") == 0);\n    assert(vlc_http_msg_add_agent(m, \"Foo/1.0 (compatible (\\\\(!))\") == 0);\n\n    assert(vlc_http_msg_add_atime(m) == 0);\n    time_t t = vlc_http_msg_get_atime(m);\n    assert(t != (time_t)-1);\n    assert(vlc_http_msg_add_time(m, \"Last-Modified\", &t) == 0);\n    assert(t == vlc_http_msg_get_mtime(m));\n\n    assert(vlc_http_msg_add_creds_basic(m, false,\n                                        \"Aladdin\", \"open sesame\") == 0);\n    assert(vlc_http_msg_add_creds_basic(m, true, \"test\", \"123\u00a3\") == 0);\n    str = vlc_http_msg_get_header(m, \"Authorization\");\n    assert(str != NULL && !strcmp(str, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\"));\n    str = vlc_http_msg_get_header(m, \"Proxy-Authorization\");\n    assert(str != NULL && !strcmp(str, \"Basic dGVzdDoxMjPCow==\"));\n\n    vlc_http_msg_add_header(m, \"Content-Length\", \"1234\");\n    assert(vlc_http_msg_get_size(m) == 1234);\n\n    /* Folding */\n    vlc_http_msg_add_header(m, \"X-Folded\", \"Hello\\n\\tworld!\");\n    str = vlc_http_msg_get_header(m, \"x-folded\");\n    assert(str != NULL && !strcmp(str, \"Hello \\tworld!\"));\n\n    vlc_http_msg_add_header(m, \"TE\", \"gzip\");\n    vlc_http_msg_add_header(m, \"TE\", \"deflate\");\n    vlc_http_msg_add_header(m, \"Pragma\", \" features=\\\"broadcast,playlist\\\"\");\n    vlc_http_msg_add_header(m, \"Pragma\", \" client-id=123456789 \");\n    vlc_http_msg_add_header(m, \"Pragma\", \"evulz=\\\"foo \\\\\\\"\\\\ bar\\\"\");\n    vlc_http_msg_add_header(m, \"Pragma\", \"no-cache \");\n\n    str = vlc_http_msg_get_header(m, \"TE\");\n    assert(str != NULL && !strcmp(str, \"gzip, deflate\"));\n    str = vlc_http_msg_get_token(m, \"TE\", \"gzip\");\n    assert(str != NULL && !strncmp(str, \"gzip\", 4));\n    str = vlc_http_msg_get_token(m, \"TE\", \"deflate\");\n    assert(str != NULL && !strncmp(str, \"deflate\", 7));\n    str = vlc_http_msg_get_token(m, \"TE\", \"compress\");\n    assert(str == NULL);\n    str = vlc_http_msg_get_token(m, \"TE\", \"zip\");\n    assert(str == NULL);\n    str = vlc_http_msg_get_token(m, \"TE\", \"late\");\n    assert(str == NULL);\n    str = vlc_http_msg_get_token(m, \"Accept-Encoding\", \"gzip\");\n    assert(str == NULL);\n    str = vlc_http_msg_get_token(m, \"Pragma\", \"features\");\n    assert(str != NULL && !strncmp(str, \"features=\\\"\", 10));\n    str = vlc_http_msg_get_token(m, \"Pragma\", \"broadcast\");\n    assert(str == NULL);\n    str = vlc_http_msg_get_token(m, \"Pragma\", \"playlist\");\n    assert(str == NULL);\n    str = vlc_http_msg_get_token(m, \"Pragma\", \"client-id\");\n    assert(str != NULL && !strncmp(str, \"client-id=\", 10));\n    str = vlc_http_msg_get_token(m, \"Pragma\", \"123456789\");\n    assert(str == NULL);\n    str = vlc_http_msg_get_token(m, \"Pragma\", \"no-cache\");\n    assert(str != NULL && !strcmp(str, \"no-cache\"));\n\n    vlc_http_msg_add_header(m, \"Cookie\", \"a=1\");\n    vlc_http_msg_add_header(m, \"Cookie\", \"b=2\");\n    str = vlc_http_msg_get_header(m, \"Cookie\");\n    assert(str != NULL && !strcmp(str, \"a=1; b=2\"));\n\n    /* Error cases */\n    assert(vlc_http_msg_add_header(m, \"/naughty\", \"header\") == -1);\n    assert(vlc_http_msg_add_header(m, \"\", \"void\") == -1);\n\n    assert(vlc_http_msg_add_agent(m, \"\") != 0);\n    assert(vlc_http_msg_add_agent(m, \"/1.0\") != 0);\n    assert(vlc_http_msg_add_agent(m, \"Bad/1.0\\\"\") != 0);\n    assert(vlc_http_msg_add_agent(m, \"Bad/1.0 (\\\\)\") != 0);\n    assert(vlc_http_msg_add_agent(m, \"Bad/1.0 (\\\\\\x08)\") != 0);\n    assert(vlc_http_msg_add_agent(m, \"Bad/1.0 \\\"Evil\\\"\") != 0);\n    assert(vlc_http_msg_add_agent(m, \"(Hello world)\") != 0);\n\n    assert(vlc_http_msg_add_creds_basic(m, false, \"User:name\", \"12345\") != 0);\n    assert(vlc_http_msg_add_creds_basic(m, false, \"Alice\\nand\\nbob\", \"\") != 0);\n    assert(vlc_http_msg_add_creds_basic(m, false, \"john\", \"asdfg\\x7f\") != 0);\n\n    vlc_http_msg_destroy(m);\n\n    const char *bad1[][2] = {\n        { \":status\", \"200\" },\n        { \":status\", \"200\" },\n        { \"Server\",  \"BigBad/1.0\" },\n    };\n\n    m = vlc_http_msg_h2_headers(3, bad1);\n    assert(m == NULL);\n\n    /* HTTP 1.x parser error cases */\n    assert(vlc_http_msg_headers(\"\") == NULL);\n    assert(vlc_http_msg_headers(\"\\r\\n\") == NULL);\n    assert(vlc_http_msg_headers(\"HTTP/1.1 200 OK\") == NULL);\n    assert(vlc_http_msg_headers(\"HTTP/1.1 200 OK\\r\\nH: V\\r\\n\") == NULL);\n    assert(vlc_http_msg_headers(\"HTTP/1.1 200 OK\\r\\n\"\n                                \":status: 200\\r\\n\\r\\n\") == NULL);\n    assert(vlc_http_msg_headers(\"HTTP/1.1 200 OK\\r\\n\"\n                                \"/naughty: invalid\\r\\n\\r\\n\") == NULL);\n\n    return 0;\n}\n", "label": "network"}
{"project": "vlc", "file": "message_test.c", "func": "struct vlc_h2_frame *\nvlc_h2_frame_headers(uint_fast32_t id, uint_fast32_t mtu, bool eos,\n                     unsigned count, const char *const tab[][2])\n{\n    struct vlc_http_msg *m;\n\n    assert(id == 1);\n    assert(mtu == VLC_H2_DEFAULT_MAX_FRAME);\n    assert(eos);\n\n    const char *headers[VLC_H2_MAX_HEADERS][2];\n\n    for (unsigned i = 0; i < count; i++)\n    {\n        headers[i][0] = tab[i][0];\n        headers[i][1] = tab[i][1];\n    }\n\n    m = vlc_http_msg_h2_headers(count, headers);\n    return (struct vlc_h2_frame *)m; /* gruik */\n}\n", "label": "network"}
{"project": "vlc", "file": "outfile.c", "func": "struct vlc_http_outfile *vlc_http_outfile_create(struct vlc_http_mgr *mgr,\n    const char *uri, const char *ua, const char *user, const char *pwd)\n{\n    struct vlc_http_msg *resp = NULL;\n    vlc_url_t url;\n    bool secure;\n\n    if (vlc_UrlParse(&url, uri))\n        goto error;\n    if (url.psz_protocol == NULL || url.psz_host == NULL)\n    {\n        errno = EINVAL;\n        goto error;\n    }\n\n    if (!vlc_ascii_strcasecmp(url.psz_protocol, \"https\"))\n        secure = true;\n    else if (!vlc_ascii_strcasecmp(url.psz_protocol, \"http\"))\n        secure = false;\n    else\n    {\n        errno = ENOTSUP;\n        goto error;\n    }\n\n    char *authority = vlc_http_authority(url.psz_host, url.i_port);\n    if (unlikely(authority == NULL))\n        goto error;\n\n    struct vlc_http_msg *req = vlc_http_req_create(\"PUT\", url.psz_protocol,\n                                                   authority, url.psz_path);\n    free(authority);\n    if (unlikely(req == NULL))\n        goto error;\n\n    vlc_http_msg_add_header(req, \"Expect\", \"100-continue\");\n\n    if (user != NULL && pwd != NULL)\n        vlc_http_msg_add_creds_basic(req, false, user, pwd);\n    if (ua != NULL)\n        vlc_http_msg_add_agent(req, ua);\n\n    vlc_http_msg_add_cookies(req, vlc_http_mgr_get_jar(mgr));\n\n    resp = vlc_http_mgr_request(mgr, secure, url.psz_host, url.i_port, req,\n                                false, true);\n    vlc_http_msg_destroy(req);\n    if (resp == NULL)\n        goto error;\n\n    int status = vlc_http_msg_get_status(resp);\n\n    /* FIXME: check that HTTP version >= 1.1 */\n\n    if (status < 100 || status >= 200)\n    {\n        vlc_http_msg_destroy(resp);\n        resp = NULL;\n    }\n\nerror:\n    vlc_UrlClean(&url);\n    return (struct vlc_http_outfile *)resp;\n}\n", "label": "network"}
{"project": "vlc", "file": "outfile.c", "func": "ssize_t vlc_http_outfile_write(struct vlc_http_outfile *f, block_t *b)\n{\n    struct vlc_http_msg *msg = (struct vlc_http_msg *)f;\n\n    return vlc_http_msg_write(msg, b, false);\n}\n", "label": "network"}
{"project": "vlc", "file": "outfile.c", "func": "int vlc_http_outfile_close(struct vlc_http_outfile *f)\n{\n    struct vlc_http_msg *msg = (struct vlc_http_msg *)f;\n    int ret = vlc_http_msg_write(msg, NULL, true);\n\n    if (ret < 0)\n    {\n        vlc_http_msg_destroy(msg);\n        return -1;\n    }\n\n    msg = vlc_http_msg_iterate(msg);\n    if (msg == NULL)\n        return -1;\n\n    int status = vlc_http_msg_get_status(msg);\n\n    /* TODO: store cookies? */\n    vlc_http_msg_destroy(msg);\n\n    return (status >= 200 && status < 300) ? 0 : -1;\n}\n", "label": "network"}
{"project": "vlc", "file": "ports.c", "func": "static int portcmp(const void *key, const void *entry)\n{\n    const unsigned *port = key;\n    const unsigned short *blocked_port = entry;\n\n    return ((int)*port) - ((int)*blocked_port);\n}\n", "label": "network"}
{"project": "vlc", "file": "ports.c", "func": "bool vlc_http_port_blocked(unsigned port)\n{\n    if (port > 0xffff)\n        return true;\n\n    return bsearch(&port, blocked_ports, ARRAY_SIZE(blocked_ports),\n                   sizeof (unsigned short), portcmp) != NULL;\n}\n", "label": "network"}
{"project": "vlc", "file": "resource.c", "func": "static struct vlc_http_msg *\nvlc_http_res_req(const struct vlc_http_resource *res, void *opaque)\n{\n    struct vlc_http_msg *req;\n\n    req = vlc_http_req_create(\"GET\", res->secure ? \"https\" : \"http\",\n                              res->authority, res->path);\n    if (unlikely(req == NULL))\n        return NULL;\n\n    /* Content negotiation */\n    vlc_http_msg_add_header(req, \"Accept\", \"*/*\");\n\n    if (res->negotiate)\n    {\n        const char *lang = vlc_gettext(\"C\");\n        if (!strcmp(lang, \"C\"))\n            lang = \"en_US\";\n        vlc_http_msg_add_header(req, \"Accept-Language\", \"%s\", lang);\n    }\n\n    /* Authentication */\n    if (res->username != NULL && res->password != NULL)\n        vlc_http_msg_add_creds_basic(req, false, res->username, res->password);\n\n    /* Request context */\n    if (res->agent != NULL)\n        vlc_http_msg_add_agent(req, res->agent);\n\n    if (res->referrer != NULL) /* TODO: validate URL */\n        vlc_http_msg_add_header(req, \"Referer\", \"%s\", res->referrer);\n\n    vlc_http_msg_add_cookies(req, vlc_http_mgr_get_jar(res->manager));\n\n    /* TODO: vlc_http_msg_add_header(req, \"TE\", \"gzip, deflate\"); */\n\n    if (res->cbs->request_format(res, req, opaque))\n    {\n        vlc_http_msg_destroy(req);\n        return NULL;\n    }\n\n    return req;\n}\n", "label": "network"}
{"project": "vlc", "file": "resource.c", "func": "struct vlc_http_msg *vlc_http_res_open(struct vlc_http_resource *res,\n                                       void *opaque)\n{\n    struct vlc_http_msg *req;\nretry:\n    req = vlc_http_res_req(res, opaque);\n    if (unlikely(req == NULL))\n        return NULL;\n\n    struct vlc_http_msg *resp = vlc_http_mgr_request(res->manager, res->secure,\n                                       res->host, res->port, req, true, false);\n    vlc_http_msg_destroy(req);\n\n    resp = vlc_http_msg_get_final(resp);\n    if (resp == NULL)\n        return NULL;\n\n    vlc_http_msg_get_cookies(resp, vlc_http_mgr_get_jar(res->manager),\n                             res->host, res->path);\n\n    int status = vlc_http_msg_get_status(resp);\n    if (status < 200 || status >= 599)\n        goto fail;\n\n    if (status == 406 && res->negotiate)\n    {   /* Not Acceptable: Content negotiation failed. Normally it means\n         * one (or more) Accept or Accept-* header line does not match any\n         * representation of the entity. So we set a flag to remove those\n         * header lines (unless they accept everything), and retry.\n         * In principles, it could be any header line, and the server can\n         * pass Vary to clarify. It cannot be caused by If-*, Range, TE or the\n         * other transfer- rather than representation-affecting header lines.\n         */\n        vlc_http_msg_destroy(resp);\n        res->negotiate = false;\n        goto retry;\n    }\n\n    if (res->cbs->response_validate(res, resp, opaque))\n        goto fail;\n\n    return resp;\nfail:\n    vlc_http_msg_destroy(resp);\n    return NULL;\n}\n", "label": "network"}
{"project": "vlc", "file": "resource.c", "func": "int vlc_http_res_get_status(struct vlc_http_resource *res)\n{\n    if (res->response == NULL)\n    {\n        if (res->failure)\n            return -1;\n\n        res->response = vlc_http_res_open(res, res + 1);\n        if (res->response == NULL)\n        {\n            res->failure = true;\n            return -1;\n        }\n    }\n    return vlc_http_msg_get_status(res->response);\n}\n", "label": "network"}
{"project": "vlc", "file": "resource.c", "func": "static void vlc_http_res_deinit(struct vlc_http_resource *res)\n{\n    free(res->referrer);\n    free(res->agent);\n    free(res->password);\n    free(res->username);\n    free(res->path);\n    free(res->authority);\n    free(res->host);\n\n    if (res->response != NULL)\n        vlc_http_msg_destroy(res->response);\n}\n", "label": "network"}
{"project": "vlc", "file": "resource.c", "func": "void vlc_http_res_destroy(struct vlc_http_resource *res)\n{\n    vlc_http_res_deinit(res);\n    free(res);\n}\n", "label": "network"}
{"project": "vlc", "file": "resource.c", "func": "int vlc_http_res_init(struct vlc_http_resource *restrict res,\n                      const struct vlc_http_resource_cbs *cbs,\n                      struct vlc_http_mgr *mgr,\n                      const char *uri, const char *ua, const char *ref)\n{\n    vlc_url_t url;\n    bool secure;\n\n    if (vlc_UrlParse(&url, uri))\n        goto error;\n    if (url.psz_protocol == NULL || url.psz_host == NULL)\n    {\n        errno = EINVAL;\n        goto error;\n    }\n\n    if (!vlc_ascii_strcasecmp(url.psz_protocol, \"https\"))\n        secure = true;\n    else if (!vlc_ascii_strcasecmp(url.psz_protocol, \"http\"))\n        secure = false;\n    else\n    {\n        errno = ENOTSUP;\n        goto error;\n    }\n\n    res->cbs = cbs;\n    res->response = NULL;\n    res->secure = secure;\n    res->negotiate = true;\n    res->failure = false;\n    res->host = strdup(url.psz_host);\n    res->port = url.i_port;\n    res->authority = vlc_http_authority(url.psz_host, url.i_port);\n    res->username = (url.psz_username != NULL) ? strdup(url.psz_username)\n                                               : NULL;\n    res->password = (url.psz_password != NULL) ? strdup(url.psz_password)\n                                               : NULL;\n    res->agent = (ua != NULL) ? strdup(ua) : NULL;\n    res->referrer = (ref != NULL) ? strdup(ref) : NULL;\n\n    const char *path = url.psz_path;\n    if (path == NULL)\n        path = \"/\";\n\n    if (url.psz_option != NULL)\n    {\n        if (asprintf(&res->path, \"%s?%s\", path, url.psz_option) == -1)\n            res->path = NULL;\n    }\n    else\n        res->path = strdup(path);\n\n    vlc_UrlClean(&url);\n    res->manager = mgr;\n\n    if (unlikely(res->host == NULL || res->authority == NULL\n              || res->path == NULL))\n    {\n        vlc_http_res_deinit(res);\n        return -1;\n    }\n    return 0;\nerror:\n    vlc_UrlClean(&url);\n    return -1;\n}\n", "label": "network"}
{"project": "vlc", "file": "resource.c", "func": "char *vlc_http_res_get_redirect(struct vlc_http_resource *restrict res)\n{\n    int status = vlc_http_res_get_status(res);\n    if (status < 0)\n        return NULL;\n\n    if ((status / 100) == 2 && !res->secure)\n    {\n        char *url;\n\n        /* HACK: Seems like an MMS server. Redirect to MMSH scheme. */\n        const char *pragma = vlc_http_msg_get_header(res->response, \"Pragma\");\n        if (pragma != NULL && !vlc_ascii_strcasecmp(pragma, \"features\")\n         && asprintf(&url, \"mmsh://%s%s\", res->authority, res->path) >= 0)\n            return url;\n\n        /* HACK: Seems like an ICY server. Redirect to ICYX scheme. */\n        if ((vlc_http_msg_get_header(res->response, \"Icy-Name\") != NULL\n          || vlc_http_msg_get_header(res->response, \"Icy-Genre\") != NULL)\n         && asprintf(&url, \"icyx://%s%s\", res->authority, res->path) >= 0)\n            return url;\n    }\n\n    /* TODO: if (status == 426 Upgrade Required) */\n\n    /* Location header is only meaningful for 201 and 3xx */\n    if (status != 201 && (status / 100) != 3)\n        return NULL;\n    if (status == 304 /* Not Modified */\n     || status == 305 /* Use Proxy (deprecated) */\n     || status == 306 /* Switch Proxy (former) */)\n        return NULL;\n\n    const char *location = vlc_http_msg_get_header(res->response, \"Location\");\n    if (location == NULL)\n        return NULL;\n\n    /* TODO: if status is 3xx, check for Retry-After and wait */\n\n    char *base;\n\n    if (unlikely(asprintf(&base, \"http%s://%s%s\", res->secure ? \"s\" : \"\",\n                          res->authority, res->path) == -1))\n        return NULL;\n\n    char *fixed = vlc_uri_fixup(location);\n    if (fixed != NULL)\n        location = fixed;\n\n    char *abs = vlc_uri_resolve(base, location);\n\n    free(fixed);\n    free(base);\n\n    if (likely(abs != NULL))\n    {\n        /* NOTE: The anchor is discarded if it is present as VLC does not support\n         * HTML anchors so far. */\n        size_t len = strcspn(abs, \"#\");\n        abs[len] = '\\0';\n    }\n    return abs;\n}\n", "label": "network"}
{"project": "vlc", "file": "resource.c", "func": "char *vlc_http_res_get_type(struct vlc_http_resource *res)\n{\n    int status = vlc_http_res_get_status(res);\n    if (status < 200 || status >= 300)\n        return NULL;\n\n    const char *type = vlc_http_msg_get_header(res->response, \"Content-Type\");\n    return (type != NULL) ? strdup(type) : NULL;\n}\n", "label": "network"}
{"project": "vlc", "file": "resource.c", "func": "block_t *vlc_http_res_read(struct vlc_http_resource *res)\n{\n    int status = vlc_http_res_get_status(res);\n    if (status < 200 || status >= 300)\n        return NULL; /* do not \"read\" redirect or error message */\n\n    return vlc_http_msg_read(res->response);\n}\n", "label": "network"}
{"project": "vlc", "file": "resource.c", "func": "int vlc_http_res_set_login(struct vlc_http_resource *res,\n                           const char *username, const char *password)\n{\n    char *user = NULL;\n    char *pass = NULL;\n\n    if (username != NULL)\n    {\n        user = strdup(username);\n        if (unlikely(user == NULL))\n            return -1;\n\n        pass = strdup((password != NULL) ? password : \"\");\n        if (unlikely(pass == NULL))\n        {\n            free(user);\n            return -1;\n        }\n    }\n\n    free(res->password);\n    free(res->username);\n    res->username = user;\n    res->password = pass;\n\n    if (res->response != NULL && vlc_http_msg_get_status(res->response) == 401)\n    {\n        vlc_http_msg_destroy(res->response);\n        res->response = NULL;\n    }\n\n    return 0;\n}\n", "label": "network"}
{"project": "vlc", "file": "resource.c", "func": "char *vlc_http_res_get_basic_realm(struct vlc_http_resource *res)\n{\n    int status = vlc_http_res_get_status(res);\n    if (status != 401)\n        return NULL;\n    return vlc_http_msg_get_basic_realm(res->response);\n}\n", "label": "network"}
{"project": "vlc", "file": "tunnel.c", "func": "static struct vlc_http_msg *vlc_http_tunnel_open(struct vlc_http_conn *conn,\n                                                 const char *hostname,\n                                                 unsigned port,\n                                                 const char *username,\n                                                 const char *password)\n{\n    char *authority = vlc_http_authority(hostname, port);\n    if (authority == NULL)\n        return NULL;\n\n    struct vlc_http_msg *req = vlc_http_req_create(\"CONNECT\", NULL, authority,\n                                                   NULL);\n    free(authority);\n    if (unlikely(req == NULL))\n        return NULL;\n\n    vlc_http_msg_add_header(req, \"ALPN\", \"h2, http%%2F1.1\");\n    vlc_http_msg_add_agent(req, PACKAGE_NAME \"/\" PACKAGE_VERSION);\n    if (username != NULL)\n        vlc_http_msg_add_creds_basic(req, true, username,\n                                     (password != NULL) ? password : \"\");\n\n    struct vlc_http_stream *stream = vlc_http_stream_open(conn, req, false);\n\n    vlc_http_msg_destroy(req);\n    if (stream == NULL)\n        return NULL;\n\n    struct vlc_http_msg *resp = vlc_http_msg_get_initial(stream);\n    resp = vlc_http_msg_get_final(resp);\n    if (resp == NULL)\n        return NULL;\n\n    int status = vlc_http_msg_get_status(resp);\n    if ((status / 100) != 2)\n    {\n        vlc_http_msg_destroy(resp);\n        resp = NULL;\n    }\n    return resp;\n}\n", "label": "network"}
{"project": "vlc", "file": "tunnel.c", "func": "static int vlc_tls_ProxyGetFD(vlc_tls_t *tls, short *restrict events)\n{\n    vlc_tls_proxy_t *proxy = (vlc_tls_proxy_t *)tls;\n\n    return vlc_tls_GetPollFD(proxy->sock, events);\n}\n", "label": "network"}
{"project": "vlc", "file": "tunnel.c", "func": "static ssize_t vlc_tls_ProxyRead(vlc_tls_t *tls, struct iovec *iov,\n                                 unsigned count)\n{\n    vlc_tls_proxy_t *proxy = (vlc_tls_proxy_t *)tls;\n    vlc_tls_t *sock = proxy->sock;\n\n    return sock->ops->readv(sock, iov, count);\n}\n", "label": "network"}
{"project": "vlc", "file": "tunnel.c", "func": "static ssize_t vlc_tls_ProxyWrite(vlc_tls_t *tls, const struct iovec *iov,\n                                  unsigned count)\n{\n    vlc_tls_proxy_t *proxy = (vlc_tls_proxy_t *)tls;\n    vlc_tls_t *sock = proxy->sock;\n\n    return sock->ops->writev(sock, iov, count);\n}\n", "label": "network"}
{"project": "vlc", "file": "tunnel.c", "func": "static int vlc_tls_ProxyShutdown(vlc_tls_t *tls, bool duplex)\n{\n    vlc_tls_proxy_t *proxy = (vlc_tls_proxy_t *)tls;\n\n    return vlc_tls_Shutdown(proxy->sock, duplex);\n}\n", "label": "network"}
{"project": "vlc", "file": "tunnel.c", "func": "static void vlc_tls_ProxyClose(vlc_tls_t *tls)\n{\n    vlc_tls_proxy_t *proxy = (vlc_tls_proxy_t *)tls;\n\n    free(proxy);\n}\n", "label": "network"}
{"project": "vlc", "file": "tunnel.c", "func": "vlc_tls_t *vlc_https_connect_proxy(void *ctx, vlc_tls_client_t *creds,\n                                   const char *hostname, unsigned port,\n                                   bool *restrict two, const char *proxy)\n{\n    vlc_url_t url;\n    int canc;\n\n    assert(proxy != NULL);\n\n    if (port == 0)\n        port = 443;\n\n    canc = vlc_savecancel();\n    vlc_UrlParse(&url, proxy);\n    vlc_restorecancel(canc);\n\n    if (url.psz_protocol == NULL || url.psz_host == NULL)\n    {\n        vlc_UrlClean(&url);\n        return NULL;\n    }\n\n    vlc_tls_t *sock = NULL;\n    bool ptwo = false;\n    if (!strcasecmp(url.psz_protocol, \"https\"))\n        sock = vlc_https_connect(creds, url.psz_host, url.i_port, &ptwo);\n    else\n    if (!strcasecmp(url.psz_protocol, \"http\"))\n        sock = vlc_tls_SocketOpenTCP(creds ? vlc_object_parent(creds) : NULL,\n                                     url.psz_host, url.i_port);\n    else\n        sock = NULL;\n\n    if (sock == NULL)\n    {\n        vlc_UrlClean(&url);\n        return NULL;\n    }\n\n    assert(!ptwo); /* HTTP/2 proxy not supported yet */\n\n    vlc_tls_proxy_t *psock = malloc(sizeof (*psock));\n    if (unlikely(psock == NULL))\n    {\n        vlc_UrlClean(&url);\n        goto error;\n    }\n\n    psock->tls.ops = &vlc_tls_proxy_ops;\n    psock->tls.p = NULL;\n    psock->sock = sock;\n\n    struct vlc_http_conn *conn = /*ptwo ? vlc_h2_conn_create(ctx, &psock->tls)\n                               :*/ vlc_h1_conn_create(ctx, &psock->tls, false);\n    if (unlikely(conn == NULL))\n    {\n        vlc_tls_Close(&psock->tls);\n        vlc_UrlClean(&url);\n        goto error;\n    }\n\n    struct vlc_http_msg *resp = vlc_http_tunnel_open(conn, hostname, port,\n                                                     url.psz_username,\n                                                     url.psz_password);\n    vlc_UrlClean(&url);\n\n    /* TODO: reuse connection to HTTP/2 proxy */\n    vlc_http_conn_release(conn); /* psock is destroyed there too */\n\n    if (resp == NULL)\n        goto error;\n\n    vlc_tls_t *tls;\n    const char *alpn[] = { \"h2\", \"http/1.1\", NULL };\n    char *alp;\n\n    tls = vlc_tls_ClientSessionCreate(creds, sock, hostname, \"https\",\n                                      alpn + !*two, &alp);\n    if (tls == NULL)\n        goto error;\n\n    *two = (alp != NULL) && !strcmp(alp, \"h2\");\n    free(alp);\n    return tls;\nerror:\n    vlc_tls_Close(sock);\n    return NULL;\n}\n", "label": "network"}
{"project": "vlc", "file": "tunnel_test.c", "func": "static void proxy_client_process(int fd)\n{\n    char buf[1024];\n    size_t buflen = 0;\n    ssize_t val;\n\n    /* Read request (and possibly more) */\n    while (strnstr(buf, \"\\r\\n\\r\\n\", buflen) == NULL)\n    {\n        val = recv(fd, buf + buflen, sizeof (buf) - buflen - 1, 0);\n        if (val <= 0)\n            assert(!\"Incomplete request\");\n        buflen += val;\n    }\n\n    buf[buflen] = '\\0';\n\n    char host[64];\n    unsigned port, ver;\n    int offset;\n\n    assert(sscanf(buf, \"CONNECT %63[^:]:%u HTTP/1.%1u%n\", host, &port, &ver,\n                  &offset) == 3);\n    assert(!strcmp(host, \"www.example.com\"));\n    assert(port == 443);\n    assert(ver == 1);\n\n    assert(sscanf(buf + offset + 2, \"Host: %63[^:]:%u\", host, &port) == 2);\n    assert(!strcmp(host, \"www.example.com\"));\n    assert(port == 443);\n\n    assert(strstr(buf, \"\\r\\nProxy-Authorization: Basic \"\n                  \"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\\r\\n\") != NULL);\n\n    const char resp[] = \"HTTP/1.1 500 Failure\\r\\n\\r\\n\";\n\n    val = write(fd, resp, strlen(resp));\n    assert((size_t)val == strlen(resp));\n    shutdown(fd, SHUT_WR);\n}\n", "label": "network"}
{"project": "vlc", "file": "tunnel_test.c", "func": "static void *proxy_thread(void *data)\n{\n    int *lfd = data;\n\n    for (;;)\n    {\n        int cfd = accept4(*lfd, NULL, NULL, SOCK_CLOEXEC);\n        if (cfd == -1)\n            continue;\n\n        int canc = vlc_savecancel();\n        proxy_client_process(cfd);\n        vlc_close(cfd);\n        connection_count++;\n        vlc_restorecancel(canc);\n    }\n    vlc_assert_unreachable();\n}\n", "label": "network"}
{"project": "vlc", "file": "tunnel_test.c", "func": "static int server_socket(unsigned *port)\n{\n    int fd = socket(PF_INET6, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_TCP);\n    if (fd == -1)\n        return -1;\n\n    struct sockaddr_in6 addr = {\n        .sin6_family = AF_INET6,\n#ifdef HAVE_SA_LEN\n        .sin6_len = sizeof (addr),\n#endif\n        .sin6_addr = in6addr_loopback,\n    };\n    socklen_t addrlen = sizeof (addr);\n\n    if (bind(fd, (struct sockaddr *)&addr, addrlen)\n     || getsockname(fd, (struct sockaddr *)&addr, &addrlen))\n    {\n        vlc_close(fd);\n        return -1;\n    }\n\n    *port = ntohs(addr.sin6_port);\n    return fd;\n}\n", "label": "network"}
{"project": "vlc", "file": "tunnel_test.c", "func": "int main(void)\n{\n    char *url;\n    unsigned port;\n    bool two = false;\n\n    /* Test bad URLs */\n    vlc_https_connect_proxy(NULL, NULL, \"www.example.com\", 0, &two,\n                            \"/test\");\n    vlc_https_connect_proxy(NULL, NULL, \"www.example.com\", 0, &two,\n                            \"ftp://proxy.example.com/\");\n\n    int *lfd = malloc(sizeof (int));\n    assert(lfd != NULL);\n    *lfd = server_socket(&port);\n    if (*lfd == -1)\n        return 77;\n\n    if (asprintf(&url, \"http://Aladdin:open%%20sesame@[::1]:%u\", port) < 0)\n        url = NULL;\n\n    assert(url != NULL);\n\n    /* Test connection failure */\n    vlc_https_connect_proxy(NULL, NULL, \"www.example.com\", 0, &two, url);\n\n    if (listen(*lfd, 255))\n    {\n        vlc_close(*lfd);\n        return 77;\n    }\n\n    vlc_thread_t th;\n    if (vlc_clone(&th, proxy_thread, lfd, VLC_THREAD_PRIORITY_LOW))\n        assert(!\"Thread error\");\n\n    /* Test proxy error */\n    vlc_https_connect_proxy(NULL, NULL, \"www.example.com\", 0, &two, url);\n\n    vlc_cancel(th);\n    vlc_join(th, NULL);\n    assert(connection_count > 0);\n    free(url);\n    vlc_close(*lfd);\n    free(lfd);\n    return 0;\n}\n", "label": "network"}
{"project": "vlc", "file": "skin_main.cpp", "func": "static void WindowSetState( vout_window_t *pWnd, unsigned i_arg )\n{\n    vout_window_skins_t* sys = (vout_window_skins_t *)pWnd->sys;\n    intf_thread_t *pIntf = sys->pIntf;\n    AsyncQueue *pQueue = AsyncQueue::instance( pIntf );\n    bool on_top = i_arg & VOUT_WINDOW_STATE_ABOVE;\n\n    // Post a SetOnTop command\n    CmdSetOnTop* pCmd = new CmdSetOnTop( pIntf, on_top );\n    pQueue->push( CmdGenericPtr( pCmd ) );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "skin_main.cpp", "func": "static void WindowUnsetFullscreen( vout_window_t *pWnd )\n{\n    vout_window_skins_t* sys = (vout_window_skins_t *)pWnd->sys;\n    intf_thread_t *pIntf = sys->pIntf;\n    AsyncQueue *pQueue = AsyncQueue::instance( pIntf );\n    CmdSetFullscreen* pCmd = new CmdSetFullscreen( pIntf, pWnd, false );\n\n    pQueue->push( CmdGenericPtr( pCmd ) );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "skin_main.cpp", "func": "static void WindowSetFullscreen( vout_window_t *pWnd, const char * )\n{\n    vout_window_skins_t* sys = (vout_window_skins_t *)pWnd->sys;\n    intf_thread_t *pIntf = sys->pIntf;\n    AsyncQueue *pQueue = AsyncQueue::instance( pIntf );\n    // Post a set fullscreen command\n    CmdSetFullscreen* pCmd = new CmdSetFullscreen( pIntf, pWnd, true );\n\n    pQueue->push( CmdGenericPtr( pCmd ) );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "skin_main.cpp", "func": "static int WindowOpen( vout_window_t *pWnd )\n{\n    if( var_InheritBool( pWnd, \"video-wallpaper\" )\n     || !var_InheritBool( pWnd, \"embedded-video\" ) )\n        return VLC_EGENERIC;\n\n    vout_window_skins_t* sys;\n\n    intf_thread_t *pIntf = skin_load_intf;\n\n    if( pIntf == NULL )\n        return VLC_EGENERIC;\n\n    if( !var_InheritBool( pIntf, \"skinned-video\") )\n        return VLC_EGENERIC;\n\n    sys = new (std::nothrow) vout_window_skins_t;\n    if( !sys )\n        return VLC_ENOMEM;\n\n    pWnd->sys = sys;\n    sys->pIntf = pIntf;\n    pWnd->ops = &window_ops;\n    pWnd->type = VOUT_WINDOW_TYPE_DUMMY;\n    return VLC_SUCCESS;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "skin_main.cpp", "func": "static void WindowClose( vout_window_t *pWnd )\n{\n    vout_window_skins_t* sys = (vout_window_skins_t *)pWnd->sys;\n\n    delete sys;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "skin_main.cpp", "func": "vlc_module_begin ()\n    set_subcategory( SUBCAT_INTERFACE_MAIN )\n    add_loadfile(\"skins2-last\", \"\", SKINS2_LAST, SKINS2_LAST_LONG)\n    add_string( \"skins2-config\", \"\", SKINS2_CONFIG, SKINS2_CONFIG_LONG )\n        change_private ()\n#ifdef _WIN32\n    add_bool( \"skins2-systray\", true, SKINS2_SYSTRAY,\n              SKINS2_SYSTRAY_LONG );\n    add_bool( \"skins2-taskbar\", true, SKINS2_TASKBAR,\n              nullptr );\n#endif\n    add_bool( \"skins2-transparency\", false, SKINS2_TRANSPARENCY,\n              SKINS2_TRANSPARENCY_LONG );\n\n    add_bool( \"skinned-playlist\", true, SKINS2_PLAYLIST,\n              nullptr );\n    add_bool( \"skinned-video\", true, SKINS2_VIDEO,\n              SKINS2_VIDEO_LONG );\n    set_shortname( N_(\"Skins\"))\n    set_description( N_(\"Skinnable Interface\") )\n    set_capability( \"interface\", 30 )\n    set_callbacks( Open, Close )\n    add_shortcut( \"skins\" )\n\n    add_submodule ()\n        set_capability( \"vout window\", 51 )\n        set_callback( WindowOpen )\n\nvlc_module_end ()\n", "label": "GUI"}
{"project": "vlc", "file": "theme_loader.cpp", "func": "static int makedir( const char *newdir )\n{\n    char *p, *buffer = strdup( newdir );\n    int  len = strlen( buffer );\n\n    if( len <= 0 )\n    {\n        free( buffer );\n        return 0;\n    }\n\n    if( buffer[len-1] == '/' )\n    {\n        buffer[len-1] = '\\0';\n    }\n\n    if( vlc_mkdir( buffer, 0775 ) == 0 )\n    {\n        free( buffer );\n        return 1;\n    }\n\n    p = buffer + 1;\n    while( 1 )\n    {\n        char hold;\n\n        while( *p && *p != '\\\\' && *p != '/' ) p++;\n        hold = *p;\n        *p = 0;\n        if( ( vlc_mkdir( buffer, 0775 ) == -1 ) && ( errno == ENOENT ) )\n        {\n            fprintf( stderr, \"couldn't create directory %s\\n\", buffer );\n            free( buffer );\n            return 0;\n        }\n        if( hold == 0 ) break;\n        *p++ = hold;\n    }\n    free( buffer );\n    return 1;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "theme_loader.cpp", "func": "bool ThemeLoader::load( const std::string &fileName )\n{\n    std::string path = getFilePath( fileName );\n\n    //Before all, let's see if the file is present\n    struct stat p_stat;\n    if( vlc_stat( fileName.c_str(), &p_stat ) )\n        return false;\n\n    // First, we try to un-targz the file, and if it fails we hope it's a XML\n    // file...\n\n    if( ! extract( fileName ) && ! parse( path, fileName ) )\n        return false;\n\n    Theme *pNewTheme = getIntf()->p_sys->p_theme;\n    if( !pNewTheme )\n        return false;\n\n    // Restore the theme configuration\n    getIntf()->p_sys->p_theme->loadConfig();\n\n    // Retain new loaded skins in config\n    config_PutPsz( \"skins2-last\", fileName.c_str() );\n\n    return true;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "theme_loader.cpp", "func": "bool ThemeLoader::extract( const std::string &fileName )\n{\n    bool result = true;\n    std::string tempPath = getTmpDir();\n    if( tempPath.empty() )\n        return false;\n\n    if( unarchive( fileName, tempPath ) == false )\n    {\n        msg_Err( getIntf(), \"extraction from %s failed\", fileName.c_str() );\n        return false;\n    }\n\n    std::string path;\n    std::string xmlFile;\n    OSFactory *pOsFactory = OSFactory::instance( getIntf() );\n    // Find the XML file in the theme\n    if( findFile( tempPath, DEFAULT_XML_FILE, xmlFile ) )\n    {\n        path = getFilePath( xmlFile );\n    }\n    else\n    {\n        // No XML file, check if it is a winamp2 skin\n        std::string mainBmp;\n        if( findFile( tempPath, \"main.bmp\", mainBmp ) )\n        {\n            msg_Dbg( getIntf(), \"trying to load a winamp2 skin\" );\n            path = getFilePath( mainBmp );\n\n            // Look for winamp2.xml in the resource path\n            std::list<std::string> resPath = pOsFactory->getResourcePath();\n            std::list<std::string>::const_iterator it;\n            for( it = resPath.begin(); it != resPath.end(); ++it )\n            {\n                if( findFile( *it, WINAMP2_XML_FILE, xmlFile ) )\n                    break;\n            }\n        }\n    }\n\n    if( !xmlFile.empty() )\n    {\n        // Parse the XML file\n        if (! parse( path, xmlFile ) )\n        {\n            msg_Err( getIntf(), \"error while parsing %s\", xmlFile.c_str() );\n            result = false;\n        }\n    }\n    else\n    {\n        msg_Err( getIntf(), \"no XML found in theme %s\", fileName.c_str() );\n        result = false;\n    }\n\n    // Clean-up\n    deleteTempFiles( tempPath );\n    return result;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "theme_loader.cpp", "func": "bool ThemeLoader::unarchive( const std::string& fileName, const std::string &tempPath )\n{\n#define UPTR_HELPER(type,deleter) []( type * data ) { \\\n        return std::unique_ptr< type, decltype( deleter )> ( data, deleter ); }\n\n    auto make_input_node_ptr = UPTR_HELPER( input_item_node_t, &input_item_node_Delete );\n    auto make_input_item_ptr = UPTR_HELPER( input_item_t, &input_item_Release );\n    auto make_stream_ptr = UPTR_HELPER( stream_t, &vlc_stream_Delete );\n    auto make_cstr_ptr = UPTR_HELPER( char, &std::free );\n\n#undef UPTR_HELPER\n\n    auto uri = make_cstr_ptr( vlc_path2uri( fileName.c_str(), \"file\" ) );\n    if( !uri )\n    {\n        msg_Err( getIntf(), \"unable to convert %s to local URI\",\n                            fileName.c_str() );\n        return false;\n    }\n\n    auto input = make_stream_ptr( vlc_stream_NewURL( getIntf(), uri.get() ) );\n    if( !input )\n    {\n        msg_Err( getIntf(), \"unable to open %s\", uri.get() );\n        return false;\n    }\n\n    stream_t* stream = input.get();\n    if( vlc_stream_directory_Attach( &stream, NULL ) )\n    {\n        msg_Err( getIntf(), \"unable to attach stream_directory, treat as XML!\" );\n    }\n    else\n    {\n        input.release();\n        input.reset( stream );\n\n        auto item = make_input_item_ptr( input_item_New( \"vlc://dummy\", \"vlc://dummy\" ) );\n        auto node = make_input_node_ptr( (input_item_node_t*)std::calloc( 1, sizeof( input_item_node_t ) ) );\n\n        if( !item || !node )\n            return false;\n\n        input_item_AddOption( item.get(), \"ignore-filetypes=\\\"\\\"\", VLC_INPUT_OPTION_TRUSTED );\n        input_item_AddOption( item.get(), \"extractor-flatten\", VLC_INPUT_OPTION_TRUSTED );\n        node->p_item = item.release();\n\n        if( vlc_stream_ReadDir( input.get(), node.get() ) )\n        {\n            msg_Err( getIntf(), \"unable to read items in %s\", uri.get() );\n            return false;\n        }\n\n        for( int i = 0; i < node->i_children; ++i )\n        {\n            auto child = node->pp_children[i]->p_item;\n            auto child_stream = make_stream_ptr( vlc_stream_NewMRL( getIntf(), child->psz_uri ) );\n            if( !child_stream )\n            {\n                msg_Err( getIntf(), \"unable to open %s for reading\", child->psz_name );\n                return false;\n            }\n\n            auto out_path = tempPath + \"/\" + child->psz_name;\n\n            { /* create directory tree */\n                auto out_directory = out_path.substr( 0, out_path.find_last_of( '/' ) );\n\n                if( makedir( out_directory.c_str() ) == false )\n                {\n                    msg_Err( getIntf(), \"failed to create directory tree for %s (%s)\",\n                             out_path.c_str(), out_directory.c_str() );\n\n                    return false;\n                }\n            }\n\n            { /* write data to disk */\n                std::string contents;\n\n                char buf[1024];\n                ssize_t n;\n\n                while( ( n = vlc_stream_Read( child_stream.get(), buf, sizeof buf ) ) > 0 )\n                    contents.append( buf, n );\n\n                std::ofstream out_stream( out_path, std::ios::binary );\n\n                if( out_stream.write( contents.data(), contents.size() ) )\n                {\n                    msg_Dbg( getIntf(), \"finished writing %zu bytes to %s\",\n                        size_t{ contents.size() }, out_path.c_str() );\n                }\n                else\n                {\n                    msg_Err( getIntf(), \"unable to write %zu bytes to %s\",\n                        size_t{ contents.size() }, out_path.c_str() );\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "theme_loader.cpp", "func": "void ThemeLoader::deleteTempFiles( const std::string &path )\n{\n    OSFactory::instance( getIntf() )->rmDir( path );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "theme_loader.cpp", "func": "bool ThemeLoader::parse( const std::string &path, const std::string &xmlFile )\n{\n    // File loaded\n    msg_Dbg( getIntf(), \"using skin file: %s\", xmlFile.c_str() );\n\n    // Start the parser\n    SkinParser parser( getIntf(), xmlFile, path );\n    if( ! parser.parse() )\n        return false;\n\n    // Build and store the theme\n    Builder builder( getIntf(), parser.getData(), path );\n    getIntf()->p_sys->p_theme = builder.build();\n\n    return true;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "theme_loader.cpp", "func": "std::string ThemeLoader::getFilePath( const std::string &rFullPath )\n{\n    OSFactory *pOsFactory = OSFactory::instance( getIntf() );\n    const std::string &sep = pOsFactory->getDirSeparator();\n    // Find the last separator ('/' or '\\')\n    std::string::size_type p = rFullPath.rfind( sep, rFullPath.size() );\n    std::string basePath;\n    if( p != std::string::npos )\n    {\n        if( p < rFullPath.size() - 1)\n        {\n            basePath = rFullPath.substr( 0, p );\n        }\n        else\n        {\n            basePath = rFullPath;\n        }\n    }\n    return basePath;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "theme_loader.cpp", "func": "bool ThemeLoader::findFile( const std::string &rootDir, const std::string &rFileName,\n                            std::string &themeFilePath )\n{\n    // Path separator\n    const std::string &sep = OSFactory::instance( getIntf() )->getDirSeparator();\n\n    const char *pszDirContent;\n\n    // Open the dir\n    DIR *pCurrDir = vlc_opendir( rootDir.c_str() );\n\n    if( pCurrDir == NULL )\n    {\n        // An error occurred\n        msg_Dbg( getIntf(), \"cannot open directory %s\", rootDir.c_str() );\n        return false;\n    }\n\n    // While we still have entries in the directory\n    while( ( pszDirContent = vlc_readdir( pCurrDir ) ) != NULL )\n    {\n        std::string newURI = rootDir + sep + pszDirContent;\n\n        // Skip . and ..\n        if( std::string( pszDirContent ) != \".\" &&\n            std::string( pszDirContent ) != \"..\" )\n        {\n#if defined( S_ISDIR )\n            struct stat stat_data;\n\n            if( ( vlc_stat( newURI.c_str(), &stat_data ) == 0 )\n             && S_ISDIR(stat_data.st_mode) )\n#elif defined( DT_DIR )\n            if( pDirContent->d_type & DT_DIR )\n#else\n            if( 0 )\n#endif\n            {\n                // Can we find the file in this subdirectory?\n                if( findFile( newURI, rFileName, themeFilePath ) )\n                {\n                    closedir( pCurrDir );\n                    return true;\n                }\n            }\n            else\n            {\n                // Found the theme file?\n                if( rFileName == std::string( pszDirContent ) )\n                {\n                    themeFilePath = newURI;\n                    closedir( pCurrDir );\n                    return true;\n                }\n            }\n        }\n    }\n\n    closedir( pCurrDir );\n    return false;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "theme_loader.cpp", "func": "std::string ThemeLoader::getTmpDir( )\n{\n#if defined( _WIN32 )\n    wchar_t *tmpdir = _wtempnam( NULL, L\"vlt\" );\n    if( tmpdir == NULL )\n        return \"\";\n    char* utf8 = FromWide( tmpdir );\n    free( tmpdir );\n    std::string tempPath( utf8 ? utf8 : \"\" );\n    free( utf8 );\n    return tempPath;\n\n#elif defined( __OS2__ )\n    char *tmpdir = tempnam( NULL, \"vlt\" );\n    if( tmpdir == NULL )\n        return \"\";\n    std::string tempPath( sFromLocale( tmpdir ));\n    free( tmpdir );\n    return tempPath;\n\n#else\n    char templ[] = \"/tmp/vltXXXXXX\";\n    char *tmpdir = mkdtemp( templ );\n    return std::string( tmpdir ? tmpdir : \"\");\n#endif\n}\n", "label": "GUI"}
{"project": "vlc", "file": "theme_repository.cpp", "func": "ThemeRepository *ThemeRepository::instance( intf_thread_t *pIntf )\n{\n    if( pIntf->p_sys->p_repository == NULL )\n    {\n        pIntf->p_sys->p_repository = new ThemeRepository( pIntf );\n    }\n\n    return pIntf->p_sys->p_repository;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "theme_repository.cpp", "func": "void ThemeRepository::destroy( intf_thread_t *pIntf )\n{\n    delete pIntf->p_sys->p_repository;\n    pIntf->p_sys->p_repository = NULL;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "theme_repository.cpp", "func": "void ThemeRepository::parseDirectory( const std::string &rDir )\n{\n    const char *pszDirContent;\n    // Path separator\n    const std::string &sep = OSFactory::instance( getIntf() )->getDirSeparator();\n\n    // Open the dir\n    DIR *pDir = vlc_opendir( rDir.c_str() );\n    if( pDir == NULL )\n    {\n        // An error occurred\n        msg_Dbg( getIntf(), \"cannot open directory %s\", rDir.c_str() );\n        return;\n    }\n\n    // While we still have entries in the directory\n    while( ( pszDirContent = vlc_readdir( pDir ) ) != NULL )\n    {\n        std::string name = pszDirContent;\n        std::string extension;\n        if( name.size() > 4 )\n        {\n            extension = name.substr( name.size() - 4, 4 );\n        }\n        if( extension == \".vlt\" || extension == \".wsz\" )\n        {\n            std::string path = rDir + sep + name;\n            std::string shortname = name.substr( 0, name.size() - 4 );\n            for( std::string::size_type i = 0; i < shortname.size(); i++ )\n                shortname[i] = ( i == 0 ) ?\n                               toupper( (unsigned char)shortname[i] ) :\n                               tolower( (unsigned char)shortname[i] );\n            m_skinsMap[shortname] = path;\n\n            msg_Dbg( getIntf(), \"found skin %s\", path.c_str() );\n        }\n    }\n\n    closedir( pDir );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "theme_repository.cpp", "func": "int ThemeRepository::changeSkin( vlc_object_t *pIntf, char const *pVariable,\n                                 vlc_value_t oldval, vlc_value_t newval,\n                                 void *pData )\n{\n    (void)pIntf; (void)oldval;\n    ThemeRepository *pThis = (ThemeRepository*)(pData);\n\n    if( !strcmp( pVariable, \"intf-skins-interactive\" ) )\n    {\n        CmdDlgChangeSkin cmd( pThis->getIntf() );\n        cmd.execute();\n    }\n    else if( !strcmp( pVariable, \"intf-skins\" ) )\n    {\n        // Try to load the new skin\n        CmdChangeSkin *pCmd = new CmdChangeSkin( pThis->getIntf(),\n                                                 newval.psz_string );\n        AsyncQueue *pQueue = AsyncQueue::instance( pThis->getIntf() );\n        pQueue->push( CmdGenericPtr( pCmd ) );\n    }\n\n    return VLC_SUCCESS;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "theme_repository.cpp", "func": "void ThemeRepository::updateRepository()\n{\n    vlc_value_t val;\n\n    // retrieve the current skin\n    char* psz_current = config_GetPsz( \"skins2-last\" );\n    if( !psz_current )\n        return;\n\n    val.psz_string = psz_current;\n\n    // add this new skins if not yet present in repository\n    std::string current( psz_current );\n    std::map<std::string,std::string>::const_iterator it;\n    for( it = m_skinsMap.begin(); it != m_skinsMap.end(); ++it )\n    {\n        if( it->second == current )\n            break;\n    }\n    if( it == m_skinsMap.end() )\n    {\n        var_Change( getIntf(), \"intf-skins\", VLC_VAR_ADDCHOICE, val,\n                    (const char *)psz_current );\n        std::string name = psz_current;\n        m_skinsMap[name] = name;\n    }\n\n    // mark this current skins as 'checked' in list\n    var_Change( getIntf(), \"intf-skins\", VLC_VAR_SETVALUE, val );\n\n    free( psz_current );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "tooltip.cpp", "func": "void Tooltip::show()\n{\n    // (Re)start the timer\n    m_pTimer->start( m_delay, true );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "tooltip.cpp", "func": "void Tooltip::hide()\n{\n    m_pTimer->stop();\n    m_pOsTooltip->hide();\n    m_xPos = -1;\n    m_yPos = -1;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "tooltip.cpp", "func": "void Tooltip::onUpdate( Subject<VarText> &rVariable, void *arg )\n{\n    (void)arg;\n    // Redisplay the tooltip\n    displayText( ((VarText&)rVariable).get() );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "tooltip.cpp", "func": "void Tooltip::displayText( const UString &rText )\n{\n    // Rebuild the image\n    makeImage( rText );\n\n    // Redraw the window if it is already visible\n    if( m_xPos != -1 )\n    {\n        m_pOsTooltip->show( m_xPos, m_yPos, *m_pImage );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "tooltip.cpp", "func": "void Tooltip::makeImage( const UString &rText )\n{\n    // Render the text on a bitmap\n    GenericBitmap *pBmpTip = m_rFont.drawString( rText, 0 );\n    if( !pBmpTip )\n    {\n        return;\n    }\n    int w = pBmpTip->getWidth() + 10;\n    int h = m_rFont.getSize() + 8;\n\n    // Create the image of the tooltip\n    delete m_pImage;\n    m_pImage = OSFactory::instance( getIntf() )->createOSGraphics( w, h );\n    m_pImage->fillRect( 0, 0, w, h, 0xffffd0 );\n    m_pImage->drawRect( 0, 0, w, h, 0x000000 );\n    m_pImage->drawBitmap( *pBmpTip, 0, 0, 5, 5, -1, -1, true );\n\n    delete pBmpTip;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "tooltip.cpp", "func": "void Tooltip::CmdShow::execute()\n{\n    if( m_pParent->m_pImage )\n    {\n        if( m_pParent->m_xPos == -1 )\n        {\n            // Get the mouse coordinates and the image size\n            OSFactory *pOsFactory = OSFactory::instance( m_pParent->getIntf() );\n            int x, y;\n            pOsFactory->getMousePos( x, y );\n            int scrWidth = pOsFactory->getScreenWidth();\n            int scrHeight = pOsFactory->getScreenHeight();\n            int w = m_pParent->m_pImage->getWidth();\n            int h = m_pParent->m_pImage->getHeight();\n\n            // Compute the position of the tooltip\n            x -= (w / 2 + 4);\n            y += (h + 5);\n            if( x + w > scrWidth )\n                x -= (x + w - scrWidth);\n            else if( x < 0 )\n                x = 0;\n            if( y + h > scrHeight )\n                y -= (2 * h + 20);\n\n            m_pParent->m_xPos = x;\n            m_pParent->m_yPos = y;\n        }\n\n        // Show the tooltip window\n        m_pParent->m_pOsTooltip->show( m_pParent->m_xPos, m_pParent->m_yPos,\n                                   *(m_pParent->m_pImage) );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::processEvent( EvtFocus &rEvtFocus )\n{\n    (void)rEvtFocus;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::processEvent( EvtMenu &rEvtMenu )\n{\n    Popup *pPopup = m_rWindowManager.getActivePopup();\n    // We should never receive a menu event when there is no active popup!\n    if( pPopup == NULL )\n    {\n        msg_Warn( getIntf(), \"unexpected menu event, ignoring\" );\n        return;\n    }\n\n    pPopup->handleEvent( rEvtMenu );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::processEvent( EvtMotion &rEvtMotion )\n{\n    // New control hit by the mouse\n    CtrlGeneric *pNewHitControl =\n        findHitControl( rEvtMotion.getXPos() - getLeft(),\n                        rEvtMotion.getYPos() - getTop() );\n\n    setLastHit( pNewHitControl );\n\n    /// Update the help text\n    VarManager *pVarManager = VarManager::instance( getIntf() );\n    if( pNewHitControl )\n    {\n        pVarManager->getHelpText().set( pNewHitControl->getHelpText() );\n    }\n\n    // Send a motion event to the hit control, or to the control\n    // that captured the mouse, if any\n    CtrlGeneric *pActiveControl = pNewHitControl;\n    if( m_pCapturingControl )\n    {\n        pActiveControl = m_pCapturingControl;\n    }\n    if( pActiveControl )\n    {\n        // Compute the coordinates relative to the window\n        int xPos = rEvtMotion.getXPos() - getLeft();\n        int yPos = rEvtMotion.getYPos() - getTop();\n        // Send a motion event\n        EvtMotion evt( getIntf(), xPos, yPos );\n        pActiveControl->handleEvent( evt );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::processEvent( EvtLeave &rEvtLeave )\n{\n    (void)rEvtLeave;\n\n    // No more hit control\n    setLastHit( NULL );\n    if( !m_pCapturingControl )\n    {\n        m_rWindowManager.hideTooltip();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::processEvent( EvtMouse &rEvtMouse )\n{\n    // Get the control hit by the mouse\n    CtrlGeneric *pNewHitControl = findHitControl( rEvtMouse.getXPos(),\n                                                  rEvtMouse.getYPos() );\n    setLastHit( pNewHitControl );\n\n    // Change the focused control\n    if( rEvtMouse.getAction() == EvtMouse::kDown )\n    {\n        // Raise the window\n        m_rWindowManager.raise( *this );\n\n        if( m_pFocusControl != pNewHitControl )\n        {\n            if( m_pFocusControl )\n            {\n                // The previous control loses the focus\n                EvtFocus evt( getIntf(), false );\n                m_pFocusControl->handleEvent( evt );\n                m_pFocusControl = NULL;\n            }\n\n            if( pNewHitControl && pNewHitControl->isFocusable() )\n            {\n                // The hit control gains the focus\n                m_pFocusControl = pNewHitControl;\n                EvtFocus evt( getIntf(), true );\n                pNewHitControl->handleEvent( evt );\n            }\n        }\n    }\n\n    // Send a mouse event to the hit control, or to the control\n    // that captured the mouse, if any\n    CtrlGeneric *pActiveControl = pNewHitControl;\n    if( m_pCapturingControl )\n    {\n        pActiveControl = m_pCapturingControl;\n    }\n    if( pActiveControl )\n    {\n        pActiveControl->handleEvent( rEvtMouse );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::processEvent( EvtKey &rEvtKey )\n{\n    // Forward the event to the focused control, if any\n    if( m_pFocusControl )\n    {\n        m_pFocusControl->handleEvent( rEvtKey );\n        return;\n    }\n\n    // Only do the action when the key is down\n    if( rEvtKey.getKeyState() == EvtKey::kDown )\n    {\n        getIntf()->p_sys->p_dialogs->sendKey( rEvtKey.getModKey() );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::processEvent( EvtScroll &rEvtScroll )\n{\n    // Raise the windows\n    raise();\n\n    // Get the control hit by the mouse\n    CtrlGeneric *pNewHitControl = findHitControl( rEvtScroll.getXPos(),\n                                                  rEvtScroll.getYPos());\n    setLastHit( pNewHitControl );\n\n    // send a mouse event to the right control when scrollable\n    // if none, send it directly to the vlc core\n    CtrlGeneric *pHitControl = m_pCapturingControl ?\n                               m_pCapturingControl : pNewHitControl;\n\n    if( pHitControl && pHitControl->isScrollable() )\n    {\n        pHitControl->handleEvent( rEvtScroll );\n    }\n    else\n    {\n        // Treat the scroll event as a hotkey plus current modifiers\n        int i = (rEvtScroll.getDirection() == EvtScroll::kUp ?\n                 KEY_MOUSEWHEELUP : KEY_MOUSEWHEELDOWN) | rEvtScroll.getMod();\n\n        getIntf()->p_sys->p_dialogs->sendKey( i );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::processEvent( EvtDragDrop &rEvtDragDrop )\n{\n    // Get the control hit by the mouse\n    int xPos = rEvtDragDrop.getXPos() - getLeft();\n    int yPos = rEvtDragDrop.getYPos() - getTop();\n\n    CtrlGeneric *pHitControl = findHitControl( xPos, yPos );\n    if( pHitControl && pHitControl->getType() == \"tree\" )\n    {\n        // Send a dragDrop event\n        EvtDragDrop evt( getIntf(), xPos, yPos, rEvtDragDrop.getFiles() );\n        pHitControl->handleEvent( evt );\n    }\n    else\n    {\n        bool is_subtitle = false;\n        std::list<std::string> files = rEvtDragDrop.getFiles();\n        // one single media, try it as a subtitle add-on\n        if( files.size() == 1 )\n        {\n            std::list<std::string>::const_iterator it = files.begin();\n            vlc_playlist_Lock( getPL() );\n            vlc_player_t *player = vlc_playlist_GetPlayer( getPL() );\n            is_subtitle =\n                !vlc_player_AddAssociatedMedia( player, SPU_ES, it->c_str(),\n                    true /*select*/, true /* OSD notify*/,\n                    true /*check subtitle extension */ );\n            vlc_playlist_Unlock( getPL() );\n        }\n        // try it as a normal media mrl\n        if( !is_subtitle )\n        {\n            std::list<std::string>::const_iterator it = files.begin();\n            for( bool first = true; it != files.end(); ++it, first = false )\n            {\n                msg_Dbg( getIntf(),\"Dropped item: %s\", it->c_str() );\n                bool playOnDrop = m_playOnDrop && first;\n                CmdAddItem( getIntf(), it->c_str(), playOnDrop ).execute();\n            }\n        }\n    }\n    m_pDragControl = NULL;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::processEvent( EvtDragOver &rEvtDragOver )\n{\n    // Get the control hit by the mouse\n    int xPos = rEvtDragOver.getXPos() - getLeft();\n    int yPos = rEvtDragOver.getYPos() - getTop();\n\n    CtrlGeneric *pHitControl = findHitControl( xPos, yPos );\n\n    if( m_pDragControl && m_pDragControl != pHitControl )\n    {\n        EvtDragLeave evt( getIntf() );\n        m_pDragControl->handleEvent( evt );\n    }\n\n    m_pDragControl = pHitControl;\n\n    if( m_pDragControl )\n    {\n        // Send a dragOver event\n        EvtDragOver evt( getIntf(), xPos, yPos );\n        m_pDragControl->handleEvent( evt );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::processEvent( EvtDragLeave &rEvtDragLeave )\n{\n    (void)rEvtDragLeave;\n    if( m_pDragControl )\n    {\n        EvtDragLeave evt( getIntf() );\n        m_pDragControl->handleEvent( evt );\n        m_pDragControl = NULL;\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::forwardEvent( EvtGeneric &rEvt, CtrlGeneric &rCtrl )\n{\n    // XXX: We should do some checks here\n    rCtrl.handleEvent( rEvt );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::refresh( int left, int top, int width, int height )\n{\n    if( m_pActiveLayout )\n    {\n        m_pActiveLayout->getImage()->copyToWindow( *getOSWindow(), left, top,\n                                                   width, height, left, top );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::setActiveLayout( GenericLayout *pLayout )\n{\n    bool isVisible = getVisibleVar().get();\n    if( m_pActiveLayout )\n    {\n        if( isVisible )\n        {\n            m_pActiveLayout->onHide();\n        }\n        // The current layout becomes inactive\n        m_pActiveLayout->getActiveVar().set( false );\n\n        // if both layouts have the same original size, infer a\n        // subsequent resize of the active layout has to be applied\n        // to the new layout about to become active\n        if( pLayout->isTightlyCoupledWith( *m_pActiveLayout ) )\n            pLayout->resize( m_pActiveLayout->getWidth(),\n                             m_pActiveLayout->getHeight() );\n    }\n\n    pLayout->setWindow( this );\n    m_pActiveLayout = pLayout;\n    // Get the size of the layout and resize the window\n    resize( pLayout->getWidth(), pLayout->getHeight() );\n\n    // The new layout is active\n    pLayout->getActiveVar().set( true );\n\n    if( isVisible )\n    {\n        pLayout->onShow();\n    }\n\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "const GenericLayout& TopWindow::getActiveLayout() const\n{\n    return *m_pActiveLayout;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::innerShow()\n{\n    // First, refresh the layout\n    if( m_pActiveLayout )\n    {\n        m_pActiveLayout->onShow();\n    }\n\n    // Show the window\n    GenericWindow::innerShow();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::innerHide()\n{\n    if( m_pActiveLayout )\n    {\n        // Notify the active layout\n        m_pActiveLayout->onHide();\n    }\n    // Hide the window\n    GenericWindow::innerHide();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::updateShape()\n{\n    // Set the shape of the window\n    if( m_pActiveLayout )\n    {\n        OSGraphics *pImage = m_pActiveLayout->getImage();\n        if( pImage )\n        {\n            pImage->applyMaskToWindow( *getOSWindow() );\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::onControlCapture( const CtrlGeneric &rCtrl )\n{\n    // Set the capturing control\n    m_pCapturingControl = (CtrlGeneric*) &rCtrl;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::onControlRelease( const CtrlGeneric &rCtrl )\n{\n    // Release the capturing control\n    if( m_pCapturingControl == &rCtrl )\n    {\n        m_pCapturingControl = NULL;\n    }\n    else\n    {\n        msg_Dbg( getIntf(), \"control had not captured the mouse\" );\n    }\n\n    // Send an enter event to the control under the mouse, if it doesn't\n    // have received it yet\n    if( m_pLastHitControl && m_pLastHitControl != &rCtrl )\n    {\n        EvtEnter evt( getIntf() );\n        m_pLastHitControl->handleEvent( evt );\n\n        // Show the tooltip\n        m_rWindowManager.hideTooltip();\n        UString tipText = m_pLastHitControl->getTooltipText();\n        if( tipText.length() > 0 )\n        {\n            // Set the tooltip text variable\n            VarManager *pVarManager = VarManager::instance( getIntf() );\n            pVarManager->getTooltipText().set( tipText );\n            m_rWindowManager.showTooltip();\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::onTooltipChange( const CtrlGeneric &rCtrl )\n{\n    // Check that the control is the active one\n    if( m_pLastHitControl && m_pLastHitControl == &rCtrl )\n    {\n        if( rCtrl.getTooltipText().size() )\n        {\n            // Set the tooltip text variable\n            VarManager *pVarManager = VarManager::instance( getIntf() );\n            pVarManager->getTooltipText().set( rCtrl.getTooltipText() );\n            m_rWindowManager.showTooltip();\n        }\n        else\n        {\n            // Nothing to display, so hide the tooltip\n            m_rWindowManager.hideTooltip();\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "CtrlGeneric *TopWindow::findHitControl( int xPos, int yPos )\n{\n    if( m_pActiveLayout == NULL )\n    {\n        return NULL;\n    }\n\n    // Get the controls in the active layout\n    const std::list<LayeredControl> &ctrlList = m_pActiveLayout->getControlList();\n    std::list<LayeredControl>::const_reverse_iterator iter;\n\n    // New control hit by the mouse\n    CtrlGeneric *pNewHitControl = NULL;\n\n    // Loop on the control list to find the uppest hit control\n    for( iter = ctrlList.rbegin(); iter != ctrlList.rend(); ++iter )\n    {\n        // Get the position of the control in the layout\n        const Position *pos = (*iter).m_pControl->getPosition();\n        if( pos != NULL )\n        {\n            // Compute the coordinates of the mouse relative to the control\n            int xRel = xPos - pos->getLeft();\n            int yRel = yPos - pos->getTop();\n\n            CtrlGeneric *pCtrl = (*iter).m_pControl;\n            // Control hit ?\n            if( pCtrl->isVisible() && pCtrl->mouseOver( xRel, yRel ) )\n            {\n                pNewHitControl = (*iter).m_pControl;\n                break;\n            }\n        }\n        else\n        {\n            msg_Dbg( getIntf(), \"control at NULL position\" );\n        }\n    }\n\n    // If the hit control has just been entered, send it an enter event\n    if( pNewHitControl && (pNewHitControl != m_pLastHitControl) )\n    {\n        // Don't send the event if another control captured the mouse\n        if( !m_pCapturingControl || (m_pCapturingControl == pNewHitControl ) )\n        {\n            EvtEnter evt( getIntf() );\n            pNewHitControl->handleEvent( evt );\n\n            if( !m_pCapturingControl )\n            {\n                // Show the tooltip\n                m_rWindowManager.hideTooltip();\n                UString tipText = pNewHitControl->getTooltipText();\n                if( tipText.length() > 0 )\n                {\n                    // Set the tooltip text variable\n                    VarManager *pVarManager = VarManager::instance( getIntf() );\n                    pVarManager->getTooltipText().set( tipText );\n                    m_rWindowManager.showTooltip();\n                }\n            }\n        }\n    }\n\n    return pNewHitControl;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "top_window.cpp", "func": "void TopWindow::setLastHit( CtrlGeneric *pNewHitControl )\n{\n    // Send a leave event to the left control\n    if( m_pLastHitControl && (pNewHitControl != m_pLastHitControl) )\n    {\n        // Don't send the event if another control captured the mouse\n        if( !m_pCapturingControl || (m_pCapturingControl == m_pLastHitControl))\n        {\n            EvtLeave evt( getIntf() );\n            m_pLastHitControl->handleEvent( evt );\n        }\n    }\n\n    m_pLastHitControl = pNewHitControl;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_manager.cpp", "func": "VarManager *VarManager::instance( intf_thread_t *pIntf )\n{\n    if( ! pIntf->p_sys->p_varManager )\n    {\n        VarManager *pVarManager;\n        pVarManager = new (std::nothrow) VarManager( pIntf );\n        if( pVarManager )\n        {\n            pIntf->p_sys->p_varManager = pVarManager;\n        }\n    }\n    return pIntf->p_sys->p_varManager;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_manager.cpp", "func": "void VarManager::destroy( intf_thread_t *pIntf )\n{\n    delete pIntf->p_sys->p_varManager;\n    pIntf->p_sys->p_varManager = NULL;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_manager.cpp", "func": "void VarManager::registerVar( const VariablePtr &rcVar, const std::string &rName )\n{\n    m_varMap[rName] = rcVar;\n    m_varList.push_front( rName );\n\n    m_anonVarList.push_back( rcVar );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_manager.cpp", "func": "void VarManager::registerVar( const VariablePtr &rcVar )\n{\n    m_anonVarList.push_back( rcVar );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_manager.cpp", "func": "Variable *VarManager::getVar( const std::string &rName )\n{\n    if( m_varMap.find( rName ) != m_varMap.end() )\n    {\n        return m_varMap[rName].get();\n    }\n    else\n    {\n        return NULL;\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_manager.cpp", "func": "Variable *VarManager::getVar( const std::string &rName, const std::string &rType )\n{\n    if( m_varMap.find( rName ) != m_varMap.end() )\n    {\n        Variable *pVar = m_varMap[rName].get();\n        // Check the variable type\n        if( pVar->getType() != rType )\n        {\n            msg_Warn( getIntf(), \"variable %s has incorrect type (%s instead\"\n                      \" of (%s)\", rName.c_str(), pVar->getType().c_str(),\n                      rType.c_str() );\n            return NULL;\n        }\n        else\n        {\n            return pVar;\n        }\n    }\n    else\n    {\n        return NULL;\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_manager.cpp", "func": "void VarManager::registerConst( const std::string &rName, const std::string &rValue)\n{\n    m_constMap[rName] = rValue;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_manager.cpp", "func": "std::string VarManager::getConst( const std::string &rName )\n{\n    return m_constMap[rName];\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "VoutManager *VoutManager::instance( intf_thread_t *pIntf )\n{\n    if( pIntf->p_sys->p_voutManager == NULL )\n    {\n        pIntf->p_sys->p_voutManager = new VoutManager( pIntf );\n    }\n\n    return pIntf->p_sys->p_voutManager;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::destroy( intf_thread_t *pIntf )\n{\n    delete pIntf->p_sys->p_voutManager;\n    pIntf->p_sys->p_voutManager = NULL;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::registerCtrlVideo( CtrlVideo* p_CtrlVideo )\n{\n    m_pCtrlVideoVec.push_back( p_CtrlVideo );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::registerFSC( FscWindow* p_Win )\n{\n    m_pFscWindow = p_Win;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::saveVoutConfig( )\n{\n    // Save width/height to be consistent across themes\n    // and detach Video Controls\n    std::vector<SavedWnd>::iterator it;\n    for( it = m_SavedWndVec.begin(); it != m_SavedWndVec.end(); ++it )\n    {\n        if( it->pCtrlVideo )\n        {\n            // detach vout thread from VideoControl\n            it->pCtrlVideo->detachVoutWindow( );\n\n            // memorize width/height before VideoControl is destroyed\n            it->width = it->pCtrlVideo->getPosition()->getWidth();\n            it->height = it->pCtrlVideo->getPosition()->getHeight();\n            it->pCtrlVideo = NULL;\n       }\n    }\n\n    // Create a backup copy and reset original for new theme\n    m_pCtrlVideoVecBackup = m_pCtrlVideoVec;\n    m_pCtrlVideoVec.clear();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::restoreVoutConfig( bool b_success )\n{\n    if( !b_success )\n    {\n        // loading new theme failed, restoring previous theme\n        m_pCtrlVideoVec = m_pCtrlVideoVecBackup;\n    }\n\n    // reattach vout(s) to Video Controls\n    std::vector<SavedWnd>::iterator it;\n    for( it = m_SavedWndVec.begin(); it != m_SavedWndVec.end(); ++it )\n    {\n        CtrlVideo* pCtrlVideo = getBestCtrlVideo();\n        if( pCtrlVideo )\n        {\n            pCtrlVideo->attachVoutWindow( it->pVoutWindow );\n            it->pCtrlVideo = pCtrlVideo;\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::discardVout( CtrlVideo* pCtrlVideo )\n{\n    std::vector<SavedWnd>::iterator it;\n    for( it = m_SavedWndVec.begin(); it != m_SavedWndVec.end(); ++it )\n    {\n        if( it->pCtrlVideo == pCtrlVideo )\n        {\n            // detach vout thread from VideoControl\n            it->pCtrlVideo->detachVoutWindow( );\n            it->width = it->pCtrlVideo->getPosition()->getWidth();\n            it->height = it->pCtrlVideo->getPosition()->getHeight();\n            it->pCtrlVideo = NULL;\n            break;\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::requestVout( CtrlVideo* pCtrlVideo )\n{\n    std::vector<SavedWnd>::iterator it;\n    for( it = m_SavedWndVec.begin(); it != m_SavedWndVec.end(); ++it )\n    {\n        if( it->pCtrlVideo == NULL )\n        {\n            pCtrlVideo->attachVoutWindow( it->pVoutWindow,\n                                          it->width, it->height );\n            it->pCtrlVideo = pCtrlVideo;\n            break;\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "CtrlVideo* VoutManager::getBestCtrlVideo( )\n{\n    std::vector<CtrlVideo*>::const_iterator it;\n\n    // first, look up a video control that is visible and unused\n    for( it = m_pCtrlVideoVec.begin(); it != m_pCtrlVideoVec.end(); ++it )\n    {\n        if( (*it)->isUseable() && !(*it)->isUsed() )\n        {\n            return (*it);\n        }\n    }\n\n    return NULL;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::acceptWnd( vout_window_t* pWnd, int width, int height )\n{\n    // Creation of a dedicated Window per vout thread\n    VoutWindow* pVoutWindow = new VoutWindow( getIntf(), pWnd, width, height,\n                                         (GenericWindow*) m_pVoutMainWindow );\n\n    // try to find a video Control within the theme\n    CtrlVideo* pCtrlVideo = getBestCtrlVideo();\n    if( pCtrlVideo )\n    {\n        // A Video Control is available\n        // directly attach vout thread to it\n        pCtrlVideo->attachVoutWindow( pVoutWindow );\n    }\n    else\n    {\n        pVoutWindow->setCtrlVideo( NULL );\n    }\n\n    // save vout characteristics\n    m_SavedWndVec.push_back( SavedWnd( pWnd, pVoutWindow, pCtrlVideo ) );\n\n    msg_Dbg( pWnd, \"New vout : Ctrl = %p, w x h = %ix%i\",\n                    (void *)pCtrlVideo, width, height );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::releaseWnd( vout_window_t* pWnd )\n{\n    // remove vout thread from savedVec\n    std::vector<SavedWnd>::iterator it;\n    for( it = m_SavedWndVec.begin(); it != m_SavedWndVec.end(); ++it )\n    {\n        if( it->pWnd == pWnd )\n        {\n            msg_Dbg( getIntf(), \"vout released vout=%p, VideoCtrl=%p\",\n                             (void *)pWnd, it->pCtrlVideo );\n\n            // if a video control was being used, detach from it\n            if( it->pCtrlVideo )\n            {\n                it->pCtrlVideo->detachVoutWindow( );\n            }\n\n            // remove resources\n            delete it->pVoutWindow;\n            m_SavedWndVec.erase( it );\n            break;\n        }\n    }\n\n    // force fullscreen to false so that user regains control\n    VlcProc::instance( getIntf() )->setFullscreenVar( false );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::setSizeWnd( vout_window_t *pWnd, int width, int height )\n{\n   msg_Dbg( pWnd, \"setSize (%ix%i) received from vout thread\",\n                  width, height );\n\n   std::vector<SavedWnd>::iterator it;\n   for( it = m_SavedWndVec.begin(); it != m_SavedWndVec.end(); ++it )\n   {\n       if( it->pWnd == pWnd )\n       {\n           VoutWindow* pVoutWindow = it->pVoutWindow;\n\n           pVoutWindow->setOriginalWidth( width );\n           pVoutWindow->setOriginalHeight( height );\n\n           CtrlVideo* pCtrlVideo = pVoutWindow->getCtrlVideo();\n           if( pCtrlVideo )\n           {\n               pCtrlVideo->resizeControl( width, height );\n           }\n           break;\n       }\n   }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::setFullscreenWnd( vout_window_t *pWnd, bool b_fullscreen )\n{\n    msg_Dbg( pWnd, \"setFullscreen (%i) received from vout thread\",\n                   b_fullscreen );\n\n    // reconfigure the fullscreen window (multiple screens)\n    if( b_fullscreen )\n    {\n        std::vector<SavedWnd>::iterator it;\n        for( it = m_SavedWndVec.begin(); it != m_SavedWndVec.end(); ++it )\n        {\n            if( it->pWnd == pWnd )\n            {\n                VoutWindow* pVoutWindow = it->pVoutWindow;\n                configureFullscreen( *pVoutWindow );\n                break;\n            }\n        }\n    }\n\n    // set fullscreen\n    VlcProc::instance( getIntf() )->setFullscreenVar( b_fullscreen );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::hideMouseWnd( vout_window_t *pWnd, bool hide )\n{\n    msg_Dbg( pWnd, \"hide mouse (%i) received from vout thread\", hide );\n    OSFactory *pOsFactory = OSFactory::instance( getIntf() );\n    if( hide )\n        pOsFactory->changeCursor( OSFactory::kNoCursor );\n    else\n        pOsFactory->changeCursor( OSFactory::kDefaultArrow );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::onUpdate( Subject<VarBool> &rVariable, void *arg )\n{\n    (void)arg;\n    VarBool &rFullscreen = VlcProc::instance( getIntf() )->getFullscreenVar();\n    if( &rVariable == &rFullscreen )\n    {\n        if( rFullscreen.get() )\n            m_pVoutMainWindow->show();\n        else\n            m_pVoutMainWindow->hide();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_manager.cpp", "func": "void VoutManager::configureFullscreen( VoutWindow& rWindow )\n{\n    int numScr = var_InheritInteger( getIntf(), \"qt-fullscreen-screennumber\" );\n\n    int x, y, w, h;\n    if( numScr >= 0 )\n    {\n        // select screen requested by user\n        OSFactory *pOsFactory = OSFactory::instance( getIntf() );\n        pOsFactory->getMonitorInfo( numScr, &x, &y, &w, &h );\n    }\n    else\n    {\n        // select screen where display is already occurring\n        rWindow.getMonitorInfo( &x, &y, &w, &h );\n    }\n\n    // move and resize fullscreen\n    m_pVoutMainWindow->move( x, y );\n    m_pVoutMainWindow->resize( w, h );\n\n    // ensure the fs controller is also moved\n    if( m_pFscWindow )\n    {\n        m_pFscWindow->moveTo( x, y, w, h );\n    }\n\n    // place voutWindow within fullscreen\n    rWindow.move( x, y );\n    rWindow.resize( w, h );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_window.cpp", "func": "void VoutWindow::setCtrlVideo( CtrlVideo* pCtrlVideo )\n{\n    if( pCtrlVideo )\n    {\n        hide();\n        const Position *pPos = pCtrlVideo->getPosition();\n        int x = pPos->getLeft();\n        int y = pPos->getTop();\n        int w = pPos->getWidth();\n        int h = pPos->getHeight();\n\n        setParent( pCtrlVideo->getWindow(), x, y, w, h );\n        m_pParentWindow = pCtrlVideo->getWindow();\n\n        resize( w, h );\n        show();\n    }\n    else\n    {\n        hide();\n        setParent( VoutManager::instance( getIntf() )->getVoutMainWindow() );\n        m_pParentWindow =\n                  VoutManager::instance( getIntf() )->getVoutMainWindow();\n        show();\n    }\n\n    m_pCtrlVideo = pCtrlVideo;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_window.cpp", "func": "void VoutWindow::resize( int width, int height )\n{\n    GenericWindow::resize( width, height );\n\n    if( m_pWnd )\n        vout_window_ReportSize( m_pWnd, width, height );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_window.cpp", "func": "void VoutWindow::processEvent( EvtKey &rEvtKey )\n{\n    // Only do the action when the key is down\n    if( rEvtKey.getKeyState() == EvtKey::kDown )\n        getIntf()->p_sys->p_dialogs->sendKey( rEvtKey.getModKey() );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_window.cpp", "func": "void VoutWindow::processEvent( EvtScroll &rEvtScroll )\n{\n    int i = (rEvtScroll.getDirection() == EvtScroll::kUp ?\n            KEY_MOUSEWHEELUP : KEY_MOUSEWHEELDOWN) | rEvtScroll.getMod();\n\n    getIntf()->p_sys->p_dialogs->sendKey( i );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_window.cpp", "func": "void VoutWindow::processEvent( EvtMotion &rEvtMotion )\n{\n    int x = rEvtMotion.getXPos() - m_pParentWindow->getLeft() - getLeft();\n    int y = rEvtMotion.getYPos() - m_pParentWindow->getTop() - getTop();\n\n    vout_window_ReportMouseMoved( m_pWnd, x, y );\n    showMouse();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_window.cpp", "func": "void VoutWindow::processEvent( EvtMouse &rEvtMouse )\n{\n    int button = -1;\n    if( rEvtMouse.getButton() == EvtMouse::kLeft )\n        button = 0;\n    else if( rEvtMouse.getButton() == EvtMouse::kMiddle )\n        button = 1;\n    else if( rEvtMouse.getButton() == EvtMouse::kRight )\n        button = 2;\n\n    if( rEvtMouse.getAction() == EvtMouse::kDown )\n        vout_window_ReportMousePressed( m_pWnd, button );\n    else if( rEvtMouse.getAction() == EvtMouse::kUp )\n        vout_window_ReportMouseReleased( m_pWnd, button );\n    else if( rEvtMouse.getAction() == EvtMouse::kDblClick )\n        vout_window_ReportMouseDoubleClick( m_pWnd, button );\n    showMouse();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_window.cpp", "func": "void VoutWindow::showMouse()\n{\n    m_pTimer->start( mouse_hide_timeout, true );\n    hideMouse( false );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_window.cpp", "func": "void VoutWindow::hideMouse( bool hide )\n{\n    VoutManager::instance( getIntf() )->hideMouseWnd( m_pWnd, hide );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "vout_window.cpp", "func": "void VoutWindow::CmdHideMouse::execute()\n{\n    m_pParent->hideMouse( true );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::registerWindow( TopWindow &rWindow )\n{\n    // Add the window to the set\n    m_allWindows.insert( &rWindow );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::unregisterWindow( TopWindow &rWindow )\n{\n    // Erase every possible reference to the window\n    m_allWindows.erase( &rWindow );\n    m_movingWindows.erase( &rWindow );\n    m_dependencies.erase( &rWindow );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::startMove( TopWindow &rWindow )\n{\n    // Rebuild the set of moving windows\n    m_movingWindows.clear();\n    buildDependSet( m_movingWindows, &rWindow );\n\n    if( isOpacityNeeded() )\n    {\n        // Change the opacity of the moving windows\n        WinSet_t::const_iterator it;\n        for( it = m_movingWindows.begin(); it != m_movingWindows.end(); ++it )\n        {\n            (*it)->setOpacity( m_moveAlpha );\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::stopMove()\n{\n    WinSet_t::const_iterator itWin1, itWin2;\n    AncList_t::const_iterator itAnc1, itAnc2;\n\n    if( isOpacityNeeded() )\n    {\n        // Restore the opacity of the moving windows\n        WinSet_t::const_iterator it;\n        for( it = m_movingWindows.begin(); it != m_movingWindows.end(); ++it )\n        {\n            (*it)->setOpacity( m_alpha );\n        }\n    }\n\n    // Delete the dependencies\n    m_dependencies.clear();\n\n    // Now we rebuild the dependencies.\n    // Iterate through all the windows\n    for( itWin1 = m_allWindows.begin(); itWin1 != m_allWindows.end(); ++itWin1 )\n    {\n        // Get the anchors of the layout associated to the window\n        const AncList_t &ancList1 =\n            (*itWin1)->getActiveLayout().getAnchorList();\n\n        // Iterate through all the windows, starting with (*itWin1)\n        for( itWin2 = itWin1; itWin2 != m_allWindows.end(); ++itWin2 )\n        {\n            // A window can't anchor itself...\n            if( (*itWin2) == (*itWin1) )\n                continue;\n\n            // Now, check for anchoring between the 2 windows\n            const AncList_t &ancList2 =\n                (*itWin2)->getActiveLayout().getAnchorList();\n            for( itAnc1 = ancList1.begin(); itAnc1 != ancList1.end(); ++itAnc1 )\n            {\n                for( itAnc2 = ancList2.begin();\n                     itAnc2 != ancList2.end(); ++itAnc2 )\n                {\n                    if( (*itAnc1)->isHanging( **itAnc2 ) )\n                    {\n                        // (*itWin1) anchors (*itWin2)\n                        m_dependencies[*itWin1].insert( *itWin2 );\n                    }\n                    else if( (*itAnc2)->isHanging( **itAnc1 ) )\n                    {\n                        // (*itWin2) anchors (*itWin1)\n                        m_dependencies[*itWin2].insert( *itWin1 );\n                    }\n                }\n            }\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::move( TopWindow &rWindow, int left, int top ) const\n{\n    // Compute the real move offset\n    int xOffset = left - rWindow.getLeft();\n    int yOffset = top - rWindow.getTop();\n\n    // Check anchoring; this can change the values of xOffset and yOffset\n    checkAnchors( &rWindow, xOffset, yOffset );\n\n    // Move all the windows\n    for( auto *window : m_movingWindows )\n        window->move( window->getLeft() + xOffset, window->getTop() + yOffset );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::startResize( GenericLayout &rLayout, Direction_t direction )\n{\n    m_direction = direction;\n\n    // Rebuild the set of moving windows.\n    // From the resized window, we only take into account the anchors which\n    // are mobile with the current type of resizing, and that are hanging a\n    // window. The hanged windows will come will all their dependencies.\n\n    m_resizeMovingE.clear();\n    m_resizeMovingS.clear();\n    m_resizeMovingSE.clear();\n\n    WinSet_t::const_iterator itWin;\n    AncList_t::const_iterator itAnc1, itAnc2;\n    // Get the anchors of the layout\n    const AncList_t &ancList1 = rLayout.getAnchorList();\n\n    // Iterate through all the hanged windows\n    for( auto *window : m_dependencies[rLayout.getWindow()] )\n    {\n        // Now, check for anchoring between the 2 windows\n        const AncList_t &ancList2 =\n            window->getActiveLayout().getAnchorList();\n        for( auto *anc1 : ancList1 )\n        {\n            for( auto *anc2 : ancList2 )\n            {\n                if( anc1->isHanging( *anc2 ) )\n                {\n                    // Add the dependencies of the hanged window to one of the\n                    // lists of moving windows\n                    Position::Ref_t aRefPos =\n                        anc1->getPosition().getRefLeftTop();\n                    if( aRefPos == Position::kRightTop )\n                        buildDependSet( m_resizeMovingE, window );\n                    else if( aRefPos == Position::kLeftBottom )\n                        buildDependSet( m_resizeMovingS, window );\n                    else if( aRefPos == Position::kRightBottom )\n                        buildDependSet( m_resizeMovingSE, window );\n                    break;\n                }\n            }\n        }\n    }\n\n    // The checkAnchors() method will need to have m_movingWindows properly set\n    // so let's insert in it the contents of the other sets\n    m_movingWindows.clear();\n    m_movingWindows.insert( rLayout.getWindow() );\n    m_movingWindows.insert( m_resizeMovingE.begin(), m_resizeMovingE.end() );\n    m_movingWindows.insert( m_resizeMovingS.begin(), m_resizeMovingS.end() );\n    m_movingWindows.insert( m_resizeMovingSE.begin(), m_resizeMovingSE.end() );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::stopResize()\n{\n    // Nothing different from stopMove(), luckily\n    stopMove();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::resize( GenericLayout &rLayout,\n                            int width, int height ) const\n{\n    // TODO: handle anchored windows\n    // Compute the real resizing offset\n    int xOffset = width - rLayout.getWidth();\n    int yOffset = height - rLayout.getHeight();\n\n    // Check anchoring; this can change the values of xOffset and yOffset\n    checkAnchors( rLayout.getWindow(), xOffset, yOffset );\n    if( m_direction == kResizeS )\n        xOffset = 0;\n    if( m_direction == kResizeE )\n        yOffset = 0;\n\n    int newWidth = rLayout.getWidth() + xOffset;\n    int newHeight = rLayout.getHeight() + yOffset;\n\n    // Check boundaries\n    if( newWidth < rLayout.getMinWidth() )\n    {\n        newWidth = rLayout.getMinWidth();\n    }\n    if( newWidth > rLayout.getMaxWidth() )\n    {\n        newWidth = rLayout.getMaxWidth();\n    }\n    if( newHeight < rLayout.getMinHeight() )\n    {\n        newHeight = rLayout.getMinHeight();\n    }\n    if( newHeight > rLayout.getMaxHeight() )\n    {\n        newHeight = rLayout.getMaxHeight();\n    }\n\n    if( newWidth == rLayout.getWidth() && newHeight == rLayout.getHeight() )\n    {\n        return;\n    }\n\n    // New offset, after the last corrections\n    int xNewOffset = newWidth - rLayout.getWidth();\n    int yNewOffset = newHeight - rLayout.getHeight();\n\n    // Resize the window\n    TopWindow *pWindow = rLayout.getWindow();\n    pWindow->resize( newWidth, newHeight );\n\n    // Do the actual resizing\n    rLayout.resize( newWidth, newHeight );\n\n    // refresh content\n    rLayout.refreshAll();\n\n    // Move all the anchored windows\n    if( m_direction == kResizeE ||\n        m_direction == kResizeSE )\n    {\n        for( auto *window : m_resizeMovingE )\n        {\n            window->move( window->getLeft() + xNewOffset,\n                          window->getTop() );\n        }\n    }\n    if( m_direction == kResizeS ||\n        m_direction == kResizeSE )\n    {\n        for( auto *window : m_resizeMovingS )\n        {\n            window->move( window->getLeft(),\n                          window->getTop( )+ yNewOffset );\n        }\n    }\n    if( m_direction == kResizeE ||\n        m_direction == kResizeS ||\n        m_direction == kResizeSE )\n    {\n        for( auto *window : m_resizeMovingSE )\n        {\n            window->move( window->getLeft() + xNewOffset,\n                          window->getTop() + yNewOffset );\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::maximize( TopWindow &rWindow )\n{\n    // Save the current position/size of the window, to be able to restore it\n    m_maximizeRect = SkinsRect( rWindow.getLeft(), rWindow.getTop(),\n                               rWindow.getLeft() + rWindow.getWidth(),\n                               rWindow.getTop() + rWindow.getHeight() );\n\n    // maximise the window within the current screen (multiple screens allowed)\n    SkinsRect workArea = OSFactory::instance( getIntf() )->getWorkArea();\n\n    // Move the window\n    startMove( rWindow );\n    move( rWindow, workArea.getLeft(), workArea.getTop() );\n    stopMove();\n    // Now resize it\n    // FIXME: Ugly const_cast\n    GenericLayout &rLayout = (GenericLayout&)rWindow.getActiveLayout();\n    startResize( rLayout, kResizeSE );\n    resize( rLayout, workArea.getWidth(), workArea.getHeight() );\n    stopResize();\n    rWindow.m_pVarMaximized->set( true );\n\n    // Make the window unmovable by unregistering it\n//     unregisterWindow( rWindow );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::unmaximize( TopWindow &rWindow )\n{\n    // Register the window to allow moving it\n//     registerWindow( rWindow );\n\n    // Resize the window\n    // FIXME: Ugly const_cast\n    GenericLayout &rLayout = (GenericLayout&)rWindow.getActiveLayout();\n    startResize( rLayout, kResizeSE );\n    resize( rLayout, m_maximizeRect.getWidth(), m_maximizeRect.getHeight() );\n    stopResize();\n    // Now move it\n    startMove( rWindow );\n    move( rWindow, m_maximizeRect.getLeft(), m_maximizeRect.getTop() );\n    stopMove();\n    rWindow.m_pVarMaximized->set( false );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::synchVisibility() const\n{\n    for( auto *window : m_allWindows )\n    {\n        // Show the window if it has to be visible\n        if( window->getVisibleVar().get() )\n        {\n            window->innerShow();\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::saveVisibility()\n{\n    m_savedWindows.clear();\n    for( auto *window : m_allWindows )\n    {\n        // Remember the window if it is visible\n        if( window->getVisibleVar().get() )\n        {\n            m_savedWindows.insert( window );\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::restoreVisibility() const\n{\n    // Warning in case we never called saveVisibility()\n    if( m_savedWindows.size() == 0 )\n    {\n        msg_Warn( getIntf(), \"restoring visibility for no window\" );\n    }\n\n    for( auto *window : m_savedWindows )\n    {\n        window->show();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::raiseAll() const\n{\n    // Raise all the windows\n    for( auto *window : m_allWindows )\n    {\n        window->raise();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::showAll( bool firstTime ) const\n{\n    // Show all the windows\n    for( auto *window : m_allWindows )\n    {\n        // When the theme is opened for the first time,\n        // only show the window if set as visible in the XML\n        if( window->getInitialVisibility() || !firstTime )\n        {\n            window->show();\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::show( TopWindow &rWindow ) const\n{\n    if( isOpacityNeeded() )\n        rWindow.setOpacity( m_alpha );\n\n    rWindow.show();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::hideAll() const\n{\n    for( auto *window : m_allWindows )\n    {\n        window->hide();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::setOnTop( bool b_ontop )\n{\n    // Update the boolean variable\n    VarBoolImpl *pVarOnTop = (VarBoolImpl*)m_cVarOnTop.get();\n    pVarOnTop->set( b_ontop );\n\n    // set/unset the \"on top\" status\n    for( auto *window : m_allWindows )\n    {\n        window->toggleOnTop( b_ontop );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::toggleOnTop()\n{\n    VarBoolImpl *pVarOnTop = (VarBoolImpl*)m_cVarOnTop.get();\n\n    setOnTop( !pVarOnTop->get() );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::buildDependSet( WinSet_t &rWinSet,\n                                    TopWindow *pWindow )\n{\n    // pWindow is in the set\n    rWinSet.insert( pWindow );\n\n    // Iterate through the anchored windows\n    const WinSet_t &anchored = m_dependencies[pWindow];\n    for( auto *window : anchored )\n    {\n        // Check that the window isn't already in the set before adding it\n        if( rWinSet.find( window ) == rWinSet.end() )\n        {\n            buildDependSet( rWinSet, window );\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::checkAnchors( TopWindow *pWindow,\n                                  int &xOffset, int &yOffset ) const\n{\n    (void)pWindow;\n\n    // Check magnetism with screen edges first (actually it is the work area)\n    SkinsRect workArea = OSFactory::instance( getIntf() )->getWorkArea();\n    // Iterate through the moving windows\n    for( auto *moving : m_movingWindows )\n    {\n        // Skip the invisible windows\n        if( !moving->getVisibleVar().get() )\n        {\n            continue;\n        }\n\n        int newLeft = moving->getLeft() + xOffset;\n        int newTop = moving->getTop() + yOffset;\n        if( newLeft > workArea.getLeft() - m_magnet &&\n            newLeft < workArea.getLeft() + m_magnet )\n        {\n            xOffset = workArea.getLeft() - moving->getLeft();\n        }\n        if( newTop > workArea.getTop() - m_magnet &&\n            newTop < workArea.getTop() + m_magnet )\n        {\n            yOffset = workArea.getTop() - moving->getTop();\n        }\n        int right = workArea.getLeft() + workArea.getWidth();\n        if( newLeft + moving->getWidth() > right - m_magnet &&\n            newLeft + moving->getWidth() < right + m_magnet )\n        {\n            xOffset = right - moving->getLeft() - moving->getWidth();\n        }\n        int bottom = workArea.getTop() + workArea.getHeight();\n        if( newTop + moving->getHeight() > bottom - m_magnet &&\n            newTop + moving->getHeight() <  bottom + m_magnet )\n        {\n            yOffset =  bottom - moving->getTop() - moving->getHeight();\n        }\n    }\n\n    // Iterate through the moving windows\n    for( auto *moving : m_movingWindows )\n    {\n        // Skip the invisible windows\n        if( !moving->getVisibleVar().get() )\n        {\n            continue;\n        }\n\n        // Get the anchors in the main layout of this moving window\n        const AncList_t &movAnchors =\n            moving->getActiveLayout().getAnchorList();\n\n        // Iterate through the static windows\n        for( auto *window : m_allWindows )\n        {\n            // Skip the moving windows and the invisible ones\n            if( m_movingWindows.find( window ) != m_movingWindows.end() ||\n                ! window->getVisibleVar().get() )\n            {\n                continue;\n            }\n\n            // Get the anchors in the main layout of this static window\n            const AncList_t &staAnchors =\n                window->getActiveLayout().getAnchorList();\n\n            // Check if there is an anchoring between one of the movAnchors\n            // and one of the staAnchors\n            for( auto *movAnchor : movAnchors )\n            {\n                for( auto *staAnchor : staAnchors )\n                {\n                    if( staAnchor->canHang( *movAnchor, xOffset, yOffset ) )\n                    {\n                        // We have found an anchoring!\n                        // There is nothing to do here, since xOffset and\n                        // yOffset are automatically modified by canHang()\n\n                        // Don't check the other anchors, one is enough...\n                        return;\n                    }\n                    else\n                    {\n                        // Temporary variables\n                        int xOffsetTemp = -xOffset;\n                        int yOffsetTemp = -yOffset;\n                        if( movAnchor->canHang( *staAnchor, xOffsetTemp,\n                                                yOffsetTemp ) )\n                        {\n                            // We have found an anchoring!\n                            // xOffsetTemp and yOffsetTemp have been updated,\n                            // we just need to change xOffset and yOffset\n                            xOffset = -xOffsetTemp;\n                            yOffset = -yOffsetTemp;\n\n                            // Don't check the other anchors, one is enough...\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::createTooltip( const GenericFont &rTipFont )\n{\n    // Create the tooltip window\n    if( !m_pTooltip )\n    {\n        m_pTooltip = std::make_unique<Tooltip>( getIntf(), rTipFont, 500 );\n    }\n    else\n    {\n        msg_Warn( getIntf(), \"tooltip already created!\" );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::showTooltip()\n{\n    if( m_pTooltip )\n    {\n        m_pTooltip->show();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::hideTooltip()\n{\n    if( m_pTooltip )\n    {\n        m_pTooltip->hide();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::addLayout( TopWindow &rWindow, GenericLayout &rLayout )\n{\n    rWindow.setActiveLayout( &rLayout );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "window_manager.cpp", "func": "void WindowManager::setActiveLayout( TopWindow &rWindow,\n                                     GenericLayout &rLayout )\n{\n    rWindow.setActiveLayout( &rLayout );\n    // Rebuild the dependencies\n    stopMove();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "bezier.cpp", "func": "float Bezier::getNearestPercent( int x, int y ) const\n{\n    int nearest = findNearestPoint( x, y );\n    return m_percVect[nearest];\n}\n", "label": "GUI"}
{"project": "vlc", "file": "bezier.cpp", "func": "float Bezier::getMinDist( int x, int y, float xScale, float yScale ) const\n{\n    int nearest = findNearestPoint( x, y );\n    double xDist = xScale * (m_leftVect[nearest] - x);\n    double yDist = yScale * (m_topVect[nearest] - y);\n    return sqrt( xDist * xDist + yDist * yDist );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "bezier.cpp", "func": "void Bezier::getPoint( float t, int &x, int &y ) const\n{\n    // Find the precalculated point whose percentage is nearest from t\n    int refPoint = 0;\n    float minDiff = fabs( m_percVect[0] - t );\n\n    // The percentages are stored in increasing order, so we can stop the loop\n    // as soon as 'diff' starts increasing\n    float diff;\n    while( refPoint < m_nbPoints &&\n           (diff = fabs( m_percVect[refPoint] - t )) <= minDiff )\n    {\n        refPoint++;\n        minDiff = diff;\n    }\n\n    // The searched point is then (refPoint - 1)\n    // We know that refPoint > 0 because we looped at least once\n    x = m_leftVect[refPoint - 1];\n    y = m_topVect[refPoint - 1];\n}\n", "label": "GUI"}
{"project": "vlc", "file": "bezier.cpp", "func": "int Bezier::getWidth() const\n{\n    int width = 0;\n    for( int i = 0; i < m_nbPoints; i++ )\n    {\n        if( m_leftVect[i] >= width )\n        {\n            width = m_leftVect[i] + 1;\n        }\n    }\n    return width;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "bezier.cpp", "func": "int Bezier::getHeight() const\n{\n    int height = 0;\n    for( int i = 0; i < m_nbPoints; i++ )\n    {\n        if( m_topVect[i] >= height )\n        {\n            height = m_topVect[i] + 1;\n        }\n    }\n    return height;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "bezier.cpp", "func": "int Bezier::findNearestPoint( int x, int y ) const\n{\n    // The distance to the first point is taken as the reference\n    int refPoint = 0;\n    int minDist = (m_leftVect[0] - x) * (m_leftVect[0] - x) +\n                  (m_topVect[0] - y) * (m_topVect[0] - y);\n\n    int dist;\n    for( int i = 1; i < m_nbPoints; i++ )\n    {\n        dist = (m_leftVect[i] - x) * (m_leftVect[i] - x) +\n               (m_topVect[i] - y) * (m_topVect[i] - y);\n        if( dist < minDist )\n        {\n            minDist = dist;\n            refPoint = i;\n        }\n    }\n\n    return refPoint;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "bezier.cpp", "func": "inline float Bezier::power( float x, int n )\n{\n#if 0\n    return n <= 0 ? 1 : x * power( x, n - 1 );\n#else\n    return powf( x, n );\n#endif\n}\n", "label": "GUI"}
{"project": "vlc", "file": "bezier.cpp", "func": "inline float Bezier::computeCoeff( int i, int n, float t ) const\n{\n    return (power( t, i ) * power( 1 - t, (n - i) ) *\n        (m_ft[n] / m_ft[i] / m_ft[n - i]));\n}\n", "label": "GUI"}
{"project": "vlc", "file": "bezier.cpp", "func": "void Bezier::computePoint( float t, int &x, int &y ) const\n{\n    // See http://astronomy.swin.edu.au/~pbourke/curves/bezier/ for a simple\n    // explanation of the algorithm\n    float xPos = 0;\n    float yPos = 0;\n    float coeff;\n    for( int i = 0; i < m_nbCtrlPt; i++ )\n    {\n        coeff = computeCoeff( i, m_nbCtrlPt - 1, t );\n        xPos += m_ptx[i] * coeff;\n        yPos += m_pty[i] * coeff;\n    }\n\n    x = lrintf(xPos);\n    y = lrintf(yPos);\n}\n", "label": "GUI"}
{"project": "vlc", "file": "fsm.cpp", "func": "void FSM::addState( const std::string &state )\n{\n    m_states.insert( state );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "fsm.cpp", "func": "void FSM::addTransition( const std::string &state1, const std::string &event,\n                         const std::string &state2, CmdGeneric *pCmd )\n{\n    // Check that we already know the states\n    if( m_states.find( state1 ) == m_states.end() ||\n        m_states.find( state2 ) == m_states.end() )\n    {\n        msg_Warn( getIntf(),\n                  \"FSM: ignoring transition between invalid states\" );\n        return;\n    }\n\n    Key_t key( state1, event );\n    Data_t data( state2, pCmd );\n\n    // Check that the transition doesn't already exist\n    if( m_transitions.find( key ) != m_transitions.end() )\n    {\n        msg_Warn( getIntf(), \"FSM: transition already exists\" );\n        return;\n    }\n\n    m_transitions[key] = data;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "fsm.cpp", "func": "void FSM::setState( const std::string &state )\n{\n    if( m_states.find( state ) == m_states.end() )\n    {\n        msg_Warn( getIntf(), \"FSM: trying to set an invalid state\" );\n        return;\n    }\n    m_currentState = state;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "fsm.cpp", "func": "void FSM::handleTransition( const std::string &event )\n{\n    std::string tmpEvent = event;\n    Key_t key( m_currentState, event );\n    std::map<Key_t, Data_t>::const_iterator it;\n\n    // Find a transition\n    it = m_transitions.find( key );\n\n    // While the matching fails, try to match a more generic transition\n    // For example, if \"key:up:F\" isn't a transition, \"key:up\" or \"key\" may be\n    while( it == m_transitions.end() &&\n           tmpEvent.rfind( \":\", tmpEvent.size() ) != std::string::npos )\n    {\n        // Cut the last part\n        tmpEvent = tmpEvent.substr( 0, tmpEvent.rfind( \":\", tmpEvent.size() ) );\n\n        key.second = tmpEvent;\n        it = m_transitions.find( key );\n    }\n\n    // No transition was found\n    if( it == m_transitions.end() )\n    {\n        return;\n    }\n\n    // Change state\n    m_currentState = (*it).second.first;\n\n    // Call the callback, if any\n    CmdGeneric *pCmd = (*it).second.second;\n    if( pCmd != NULL )\n    {\n        pCmd->execute();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "position.cpp", "func": "int Position::getLeft() const\n{\n    if( m_xKeepRatio )\n    {\n        // Ratio mode\n        // First compute the width of the box minus the width of the control\n        int freeSpace = m_rRect.getWidth() - (m_right - m_left);\n        return m_rRect.getLeft() + (int)(m_xRatio * freeSpace);\n    }\n    else\n    {\n        switch( m_refLeftTop )\n        {\n        case kLeftTop:\n        case kLeftBottom:\n            return m_rRect.getLeft() + m_left;\n        case kRightTop:\n        case kRightBottom:\n            return m_rRect.getLeft() + m_rRect.getWidth() + m_left - 1;\n        }\n        // Avoid a warning\n        return 0;\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "position.cpp", "func": "int Position::getTop() const\n{\n    if( m_yKeepRatio )\n    {\n        // Ratio mode\n        // First compute the height of the box minus the height of the control\n        int freeSpace = m_rRect.getHeight() - (m_bottom - m_top);\n        return m_rRect.getTop() + (int)(m_yRatio * freeSpace);\n    }\n    else\n    {\n        switch( m_refLeftTop )\n        {\n            case kLeftTop:\n            case kRightTop:\n                return m_rRect.getTop() + m_top;\n            case kRightBottom:\n            case kLeftBottom:\n                return m_rRect.getTop() + m_rRect.getHeight() + m_top - 1;\n        }\n        // Avoid a warning\n        return 0;\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "position.cpp", "func": "int Position::getRight() const\n{\n    if( m_xKeepRatio )\n    {\n        // Ratio mode\n        // The width of the control being constant, we can use the result of\n        // getLeft() (this will avoid rounding issues).\n        return getLeft() + m_right - m_left;\n    }\n    else\n    {\n        switch( m_refRighBottom )\n        {\n            case kLeftTop:\n            case kLeftBottom:\n                return m_rRect.getLeft() + m_right;\n            case kRightTop:\n            case kRightBottom:\n                return m_rRect.getLeft() + m_rRect.getWidth() + m_right - 1;\n        }\n        // Avoid a warning\n        return 0;\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "position.cpp", "func": "int Position::getBottom() const\n{\n    if( m_yKeepRatio )\n    {\n        // Ratio mode\n        // The height of the control being constant, we can use the result of\n        // getTop() (this will avoid rounding issues).\n        return getTop() + m_bottom - m_top;\n    }\n    else\n    {\n        switch( m_refRighBottom )\n        {\n            case kLeftTop:\n            case kRightTop:\n                return m_rRect.getTop() + m_bottom;\n            case kLeftBottom:\n            case kRightBottom:\n                return m_rRect.getTop() + m_rRect.getHeight() + m_bottom - 1;\n        }\n        // Avoid a warning\n        return 0;\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "position.cpp", "func": "int Position::getWidth() const\n{\n    return getRight() - getLeft() + 1;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "position.cpp", "func": "int Position::getHeight() const\n{\n    return getBottom() - getTop() + 1;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "position.cpp", "func": "int VarBox::getWidth() const\n{\n    return m_width;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "position.cpp", "func": "int VarBox::getHeight() const\n{\n    return m_height;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "position.cpp", "func": "void VarBox::setSize( int width, int height )\n{\n    m_width = width;\n    m_height = height;\n    notify();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "bool UString::operator ==( const UString &rOther ) const\n{\n    if( size() != rOther.size() )\n    {\n        return false;\n    }\n\n    for( uint32_t i = 0; i < size(); i++ )\n    {\n        if( m_pString[i] != rOther.m_pString[i] )\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "bool UString::operator !=( const UString &rOther ) const\n{\n    return !(*this == rOther);\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "bool UString::operator <( const UString &rOther ) const\n{\n    const uint32_t *pOther = rOther.u_str();\n    uint32_t i;\n    for( i = 0; i < __MIN(m_length, rOther.length()); i++ )\n    {\n        if( m_pString[i] < pOther[i] )\n        {\n            return true;\n        }\n        else if( m_pString[i] > pOther[i] )\n        {\n            return false;\n        }\n    }\n    return( m_pString[i] < pOther[i] );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "bool UString::operator <=( const UString &rOther ) const\n{\n    return !( rOther < *this );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "bool UString::operator >( const UString &rOther ) const\n{\n    return ( rOther < *this );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "bool UString::operator >=( const UString &rOther ) const\n{\n    return !( *this < rOther );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "UString& UString::operator =( const UString &rOther )\n{\n    if( this == &rOther )\n        return *this;\n\n    m_length = rOther.m_length;\n    delete[] m_pString;\n    m_pString = new uint32_t[size() + 1];\n    for( uint32_t i = 0; i <= size(); i++ )\n    {\n        m_pString[i] = rOther.m_pString[i];\n    }\n\n    return *this;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "UString& UString::operator +=( const UString &rOther )\n{\n    if( this == &rOther )\n        return *this;\n\n    int tempLength = this->length() + rOther.length();\n    uint32_t *pTempString = new uint32_t[tempLength + 1];\n    // Copy the first string\n    memcpy( pTempString, this->m_pString, sizeof(uint32_t) * this->size() );\n    // Append the second string\n//     memcpy( pTempString + 4 * size(), rOther.m_pString,\n//             4 * rOther.size() );\n    for( uint32_t i = 0; i < rOther.size(); i++ )\n    {\n        pTempString[this->size() + i] = rOther.m_pString[i];\n    }\n    pTempString[tempLength] = 0;\n\n    // Set the string internally\n    delete[] m_pString;\n    m_pString = pTempString;\n    m_length = tempLength;\n\n    return *this;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "const UString UString::operator +( const UString &rOther ) const\n{\n    UString result( *this );\n    result += rOther;\n\n    return result;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "const UString UString::operator +( const char *pString ) const\n{\n    UString temp( getIntf(), pString );\n    return (*this + temp );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "uint32_t UString::find( const UString &str, uint32_t position ) const\n{\n    uint32_t pos;\n    for( pos = position; pos + str.size() <= size(); pos++ )\n    {\n        bool match = true;\n        for( uint32_t i = 0; i < str.size(); i++ )\n        {\n            if( m_pString[pos + i] != str.m_pString[i] )\n            {\n                match = false;\n                break;\n            }\n        }\n\n        // Found\n        if( match )\n        {\n            return pos;\n        }\n    }\n\n    // Not found\n    return npos;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "uint32_t UString::find( const char *pString, uint32_t position ) const\n{\n    UString tmp( getIntf(), pString );\n    return find( tmp, position );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "void UString::replace( uint32_t position, uint32_t n1, const UString &str )\n{\n    UString start( substr( 0, position ) );\n    UString end( substr( position + n1 ) );\n    *this = start + str + end;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "void UString::replace( uint32_t position, uint32_t n1, const char *pString )\n{\n    replace( position, n1, UString( getIntf(), pString ) );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "UString UString::substr( uint32_t position, uint32_t n) const\n{\n    UString tmp( getIntf(), \"\" );\n    if( position > size() )\n    {\n        msg_Err( getIntf(), \"invalid position in UString::substr()\" );\n        return tmp;\n    }\n    tmp.m_length = (n < size() - position) ? n : size() - position;\n    delete[] tmp.m_pString;\n    tmp.m_pString = new uint32_t[tmp.size() + 1];\n    for( uint32_t i = 0; i < tmp.size(); i++ )\n    {\n        tmp.m_pString[i] = m_pString[position + i];\n    }\n\n    return tmp;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "ustring.cpp", "func": "UString UString::fromInt( intf_thread_t *pIntf, int number)\n{\n    std::stringstream ss;\n    ss << number;\n    return UString( pIntf, ss.str().c_str() );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_bool.cpp", "func": "void VarBoolImpl::set( bool value )\n{\n    if( value != m_value )\n    {\n        m_value = value;\n        notify();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_bool.cpp", "func": "void VarBoolAndBool::onUpdate( Subject<VarBool> &rVariable, void *arg )\n{\n    (void)rVariable; (void)arg;\n    if( m_value != ( m_rVar1.get() && m_rVar2.get() ) )\n    {\n        m_value = ( m_rVar1.get() && m_rVar2.get() );\n        notify();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_bool.cpp", "func": "void VarBoolOrBool::onUpdate( Subject<VarBool> &rVariable, void *arg )\n{\n    (void)rVariable; (void)arg;\n    if( m_value != ( m_rVar1.get() || m_rVar2.get() ) )\n    {\n        m_value = ( m_rVar1.get() || m_rVar2.get() );\n        notify();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_bool.cpp", "func": "void VarNotBool::onUpdate( Subject<VarBool> &rVariable, void *arg )\n{\n    (void)rVariable; (void)arg;\n    notify();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_list.cpp", "func": "void VarList::add( const UStringPtr &rcString )\n{\n    m_list.push_back( Elem_t( rcString ) );\n    notify();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_list.cpp", "func": "void VarList::delSelected()\n{\n    Iterator it = begin();\n    while( it != end() )\n    {\n        if( (*it).m_selected )\n        {\n            Iterator oldIt = it;\n            ++it;\n            m_list.erase( oldIt );\n        }\n        else\n        {\n            ++it;\n        }\n    }\n    notify();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_list.cpp", "func": "void VarList::clear()\n{\n    m_list.clear();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_list.cpp", "func": "VarList::Iterator VarList::operator[]( int n )\n{\n    Iterator it = begin();\n    for( int i = 0; i < n; i++ )\n    {\n        if( it != end() )\n        {\n            it++;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return it;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_list.cpp", "func": "VarList::ConstIterator VarList::operator[]( int n ) const\n{\n    ConstIterator it = begin();\n    for( int i = 0; i < n; i++ )\n    {\n        if( it != end() )\n        {\n            it++;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return it;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_percent.cpp", "func": "void VarPercent::set( float percentage )\n{\n    if( percentage < 0 )\n    {\n        percentage = 0;\n    }\n    if( percentage > 1 )\n    {\n        percentage = 1;\n    }\n\n    // If the value has changed, notify the observers\n    if( m_value != percentage )\n    {\n        m_value = percentage;\n        notify( NULL );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_string.cpp", "func": "void VarString::set( std::string str )\n{\n    // If the value has changed, notify the observers\n    if( m_value != str )\n    {\n        m_value = str;\n        notify( NULL );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_text.cpp", "func": "const UString VarText::get() const\n{\n    if( !m_substVars )\n    {\n        // Do not substitute \"$X\" variables\n        return m_text;\n    }\n\n    uint32_t pos;\n    VlcProc *pVlcProc = VlcProc::instance( getIntf() );\n\n    // Fill a temporary UString object, and replace the escape characters\n    // ($H for help, $T for current time, $L for time left, $D for duration,\n    // $V for volume)\n    UString temp( m_text );\n\n    // $H is processed first, in case the help string contains other variables\n    // to replace. And it is replaced only once, in case one of these other\n    // variables is $H...\n    if( (pos = temp.find( \"$H\" )) != UString::npos )\n    {\n        VarManager *pVarManager = VarManager::instance( getIntf() );\n        temp.replace( pos, 2, pVarManager->getHelpText().get() );\n    }\n    while( (pos = temp.find( \"$T\" )) != UString::npos )\n    {\n        temp.replace( pos, 2,\n                      pVlcProc->getTimeVar().getAsStringCurrTime().c_str() );\n    }\n    while( (pos = temp.find( \"$t\" )) != UString::npos )\n    {\n        temp.replace( pos, 2,\n                      pVlcProc->getTimeVar().getAsStringCurrTime(true).c_str() );\n    }\n    while( (pos = temp.find( \"$L\" )) != UString::npos )\n    {\n        temp.replace( pos, 2,\n                      pVlcProc->getTimeVar().getAsStringTimeLeft().c_str() );\n    }\n    while( (pos = temp.find( \"$l\" )) != UString::npos )\n    {\n        temp.replace( pos, 2,\n                      pVlcProc->getTimeVar().getAsStringTimeLeft(true).c_str() );\n    }\n    while( (pos = temp.find( \"$D\" )) != UString::npos )\n    {\n        temp.replace( pos, 2,\n                      pVlcProc->getTimeVar().getAsStringDuration().c_str() );\n    }\n    while( (pos = temp.find( \"$d\" )) != UString::npos )\n    {\n        temp.replace( pos, 2,\n                      pVlcProc->getTimeVar().getAsStringDuration(true).c_str() );\n    }\n    while( (pos = temp.find( \"$V\" )) != UString::npos )\n    {\n        temp.replace( pos, 2,\n                      pVlcProc->getVolumeVar().getAsStringPercent().c_str() );\n    }\n    while( (pos = temp.find( \"$N\" )) != UString::npos )\n    {\n        temp.replace( pos, 2, pVlcProc->getStreamNameVar().get() );\n    }\n    while( (pos = temp.find( \"$F\" )) != UString::npos )\n    {\n        temp.replace( pos, 2, pVlcProc->getStreamURIVar().get() );\n    }\n    while( (pos = temp.find( \"$B\" )) != UString::npos )\n    {\n        temp.replace( pos, 2, pVlcProc->getStreamBitRateVar().get() );\n    }\n    while( (pos = temp.find( \"$S\" )) != UString::npos )\n    {\n        temp.replace( pos, 2, pVlcProc->getStreamSampleRateVar().get() );\n    }\n    while( (pos = temp.find( \"$R\" )) != UString::npos )\n    {\n        temp.replace( pos, 2, pVlcProc->getSpeedVar().get() );\n    }\n\n    return temp;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_text.cpp", "func": "void VarText::set( const UString &rText )\n{\n    // Avoid an infinite loop\n    if( rText == m_text )\n    {\n        return;\n    }\n\n    m_text = rText;\n\n    if( m_substVars )\n    {\n        // Stop observing other variables\n        delObservers();\n\n        VlcProc *pVlcProc = VlcProc::instance( getIntf() );\n        VarManager *pVarManager = VarManager::instance( getIntf() );\n\n        // Observe needed variables\n        if( m_text.find( \"$H\" ) != UString::npos )\n        {\n            pVarManager->getHelpText().addObserver( this );\n        }\n        if( m_text.find( \"$T\" ) != UString::npos ||\n            m_text.find( \"$t\" ) != UString::npos ||\n            m_text.find( \"$L\" ) != UString::npos ||\n            m_text.find( \"$l\" ) != UString::npos ||\n            m_text.find( \"$D\" ) != UString::npos ||\n            m_text.find( \"$d\" ) != UString::npos )\n        {\n            pVlcProc->getTimeVar().addObserver( this );\n        }\n        if( m_text.find( \"$V\" ) != UString::npos )\n        {\n            pVlcProc->getVolumeVar().addObserver( this );\n        }\n        if( m_text.find( \"$N\" ) != UString::npos )\n        {\n            pVlcProc->getStreamNameVar().addObserver( this );\n        }\n        if( m_text.find( \"$F\" ) != UString::npos )\n        {\n            pVlcProc->getStreamURIVar().addObserver( this );\n        }\n        if( m_text.find( \"$B\" ) != UString::npos )\n        {\n            pVlcProc->getStreamBitRateVar().addObserver( this );\n        }\n        if( m_text.find( \"$S\" ) != UString::npos )\n        {\n            pVlcProc->getStreamSampleRateVar().addObserver( this );\n        }\n        if( m_text.find( \"$R\" ) != UString::npos )\n        {\n            pVlcProc->getSpeedVar().addObserver( this );\n        }\n    }\n\n    notify();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_text.cpp", "func": "void VarText::onUpdate( Subject<VarPercent> &rVariable, void *arg )\n{\n    (void)rVariable; (void)arg;\n    UString newText = get();\n    // If the text has changed, notify the observers\n    if( newText != m_lastText )\n    {\n        m_lastText = newText;\n        notify();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_text.cpp", "func": "void VarText::onUpdate( Subject<VarText> &rVariable, void *arg )\n{\n    (void)rVariable; (void)arg;\n    UString newText = get();\n    // If the text has changed, notify the observers\n    if( newText != m_lastText )\n    {\n        m_lastText = newText;\n        notify();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_text.cpp", "func": "void VarText::delObservers()\n{\n    // Stop observing other variables\n\n    VlcProc *pVlcProc = getIntf()->p_sys->p_vlcProc;\n    VarManager *pVarManager = getIntf()->p_sys->p_varManager;\n\n    if( pVlcProc )\n    {\n        pVlcProc->getTimeVar().delObserver( this );\n        pVlcProc->getVolumeVar().delObserver( this );\n        pVlcProc->getSpeedVar().delObserver( this );\n        pVlcProc->getStreamNameVar().delObserver( this );\n        pVlcProc->getStreamURIVar().delObserver( this );\n        pVlcProc->getStreamBitRateVar().delObserver( this );\n        pVlcProc->getStreamSampleRateVar().delObserver( this );\n    }\n\n    if( pVarManager )\n        pVarManager->getHelpText().delObserver( this );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "void VarTree::setMedia( input_item_t *media )\n{\n    if( m_media )\n        input_item_Release( m_media );\n    m_media = media;\n    if( m_media )\n        input_item_Hold( m_media );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::add( input_item_t* media, const UStringPtr &rcString,\n                  bool selected, bool playing, bool expanded, bool readonly,\n                  int pos )\n{\n    Iterator it;\n    if( pos == -1 )\n    {\n        it = m_children.end();\n    }\n    else\n    {\n        it = m_children.begin();\n        for( int i = 0; i < pos && it != m_children.end(); ++it, i++ );\n    }\n\n    return m_children.insert( it,\n                              VarTree( getIntf(), this, media, rcString,\n                                       selected, playing,\n                                       expanded, readonly ) );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "void VarTree::delSelected()\n{\n    for( Iterator it = m_children.begin(); it != m_children.end(); )\n    {\n        if( it->m_selected )\n        {\n            Iterator oldIt = it;\n            ++it;\n            m_children.erase( oldIt );\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "void VarTree::clear()\n{\n    m_children.clear();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::getNextSiblingOrUncle()\n{\n    VarTree *p_parent = parent();\n    if( p_parent )\n    {\n        Iterator it = ++(getSelf());\n        if( it != p_parent->m_children.end() )\n            return it;\n        else\n            return next_uncle();\n    }\n    return root()->m_children.end();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::getPrevSiblingOrUncle()\n{\n    VarTree *p_parent = parent();\n    if( p_parent )\n    {\n        Iterator it = getSelf();\n        if( it != p_parent->m_children.begin() )\n            return --it;\n        else\n            return prev_uncle();\n    }\n    return root()->m_children.end();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::next_uncle()\n{\n    VarTree *p_parent = parent();\n    if( p_parent )\n    {\n        VarTree *p_grandparent = p_parent->parent();\n        while( p_grandparent )\n        {\n            Iterator it = ++(p_parent->getSelf());\n            if( it != p_grandparent->m_children.end() )\n                return it;\n            p_parent = p_grandparent;\n            p_grandparent = p_parent->parent();\n        }\n    }\n\n    /* if we didn't return before, it means that we've reached the end */\n    return root()->m_children.end();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::prev_uncle()\n{\n    VarTree *p_parent = parent();\n    if( p_parent )\n    {\n        VarTree *p_grandparent = p_parent->parent();\n        while( p_grandparent )\n        {\n            Iterator it = p_parent->getSelf();\n            if( it != p_grandparent->m_children.begin() )\n                return --it;\n            p_parent = p_grandparent;\n            p_grandparent = p_parent->parent();\n        }\n    }\n\n    /* if we didn't return before, it means that we've reached the end */\n    return root()->m_children.end();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "int VarTree::visibleItems()\n{\n    int i_count = size();\n    for( Iterator it = m_children.begin(); it != m_children.end(); ++it )\n    {\n        if( it->m_expanded )\n        {\n            i_count += it->visibleItems();\n        }\n    }\n    return i_count;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::getVisibleItem( int n )\n{\n    Iterator it = m_children.begin();\n    while( it != m_children.end() )\n    {\n        n--;\n        if( n <= 0 )\n            return it;\n        if( it->m_expanded )\n        {\n            int i;\n            i = n - it->visibleItems();\n            if( i <= 0 ) return it->getVisibleItem( n );\n            n = i;\n        }\n        ++it;\n    }\n    return m_children.end();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::getLeaf( int n )\n{\n    Iterator it = m_children.begin();\n    while( it != m_children.end() )\n    {\n        if( it->size() )\n        {\n            int i;\n            i = n - it->countLeafs();\n            if( i <= 0 ) return it->getLeaf( n );\n            n = i;\n        }\n        else\n        {\n            n--;\n            if( n <= 0 )\n                return it;\n        }\n        ++it;\n    }\n    return m_children.end();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::getNextVisibleItem( Iterator it )\n{\n    if( it->m_expanded && it->size() )\n    {\n        it = it->m_children.begin();\n    }\n    else\n    {\n        Iterator it_old = it;\n        ++it;\n        // Was 'it' the last brother? If so, look for uncles\n        if( it_old->parent() && it_old->parent()->m_children.end() == it )\n        {\n            it = it_old->next_uncle();\n        }\n    }\n    return it;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::getPrevVisibleItem( Iterator it )\n{\n    if( it == root()->m_children.begin() )\n        return it;\n\n    if( it == root()->m_children.end() )\n    {\n        --it;\n        while( it->size() && it->m_expanded )\n            it = --(it->m_children.end());\n        return it;\n    }\n\n    /* Was it the first child of its parent ? */\n    VarTree *p_parent = it->parent();\n    if( it == p_parent->m_children.begin() )\n    {\n        /* Yes, get its parent's it */\n        it = p_parent->getSelf();\n    }\n    else\n    {\n        --it;\n        /* We have found an older brother, take its last visible child */\n        while( it->size() && it->m_expanded )\n            it = --(it->m_children.end());\n    }\n    return it;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::getNextItem( Iterator it )\n{\n    if( it->size() )\n    {\n        it = it->m_children.begin();\n    }\n    else\n    {\n        Iterator it_old = it;\n        ++it;\n        // Was 'it' the last brother? If so, look for uncles\n        if( it_old->parent() && it_old->parent()->m_children.end() == it )\n        {\n            it = it_old->next_uncle();\n        }\n    }\n    return it;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::getPrevItem( Iterator it )\n{\n    if( it == root()->m_children.begin() )\n        return it;\n\n    if( it == root()->m_children.end() )\n    {\n        --it;\n        while( it->size() )\n            it = --(it->m_children.end());\n        return it;\n    }\n    /* Was it the first child of its parent ? */\n    VarTree *p_parent = it->parent();\n    if( it == p_parent->m_children.begin() )\n    {\n        /* Yes, get its parent's it */\n        it = p_parent->getSelf();\n    }\n    else\n    {\n        --it;\n        /* We have found an older brother, take its last child */\n        while( it->size() )\n            it = --(it->m_children.end());\n    }\n    return it;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::getNextLeaf( Iterator it )\n{\n    do\n    {\n        it = getNextItem( it );\n    }\n    while( it != root()->m_children.end() && it->size() );\n    return it;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::getPrevLeaf( Iterator it )\n{\n    Iterator it_new = it->getPrevSiblingOrUncle();\n    if( it_new == root()->end() )\n        return it_new;\n    while( it_new->size() )\n        it_new = --(it_new->m_children.end());\n    return it_new;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::getParent( Iterator it )\n{\n    if( it->parent() )\n    {\n        return it->parent()->getSelf();\n    }\n    return m_children.end();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "void VarTree::ensureExpanded( const Iterator& it )\n{\n    /// Don't expand ourselves, only our parents\n    VarTree *current = &(*it);\n    current = current->parent();\n    while( current->parent() )\n    {\n        current->m_expanded = true;\n        current = current->parent();\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "int VarTree::countLeafs()\n{\n    if( size() == 0 )\n        return 1;\n\n    int i_count = 0;\n    for( Iterator it = m_children.begin(); it != m_children.end(); ++it )\n    {\n        i_count += it->countLeafs();\n    }\n    return i_count;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::firstLeaf()\n{\n    Iterator b = root()->m_children.begin();\n    if( b->size() ) return getNextLeaf( b );\n    return b;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "int VarTree::getIndex( const Iterator& item )\n{\n    int index = 0;\n    Iterator it;\n    for( it = m_flat ? firstLeaf() : m_children.begin();\n         it != m_children.end();\n         it = m_flat ? getNextLeaf( it ) : getNextVisibleItem( it ) )\n    {\n        if( it == item )\n            break;\n        index++;\n    }\n    return (it == item) ? index : -1;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::Iterator VarTree::getItemFromSlider()\n{\n    // a simple (int)(...) causes rounding errors !\n#ifdef _MSC_VER\n#       define lrint (int)\n#endif\n    VarPercent &rVarPos = getPositionVar();\n    double percentage = rVarPos.get();\n\n    int indexMax = m_flat ? (countLeafs() - 1)\n                          : (visibleItems() - 1);\n\n    int index = lrint( (1.0 - percentage)*(double)indexMax );\n\n    Iterator it_first = m_flat ? getLeaf( index + 1 )\n                               : getVisibleItem( index + 1 );\n    return it_first;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "void VarTree::setSliderFromItem( const Iterator& it )\n{\n    VarPercent &rVarPos = getPositionVar();\n\n    int indexMax = m_flat ? (countLeafs() - 1)\n                          : (visibleItems() - 1);\n\n    int index = getIndex( it );\n    double percentage = (1.0 - (double)index/(double)indexMax);\n\n    m_dontMove = true;\n    rVarPos.set( (float)percentage );\n    m_dontMove = false;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "void VarTree::onUpdate( Subject<VarPercent> &rPercent, void* arg )\n{\n    (void)rPercent; (void)arg;\n    onUpdateSlider();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "void VarTree::unselectTree()\n{\n    m_selected = false;\n    for( Iterator it = m_children.begin(); it != m_children.end(); ++it )\n        it->unselectTree();\n}\n", "label": "GUI"}
{"project": "vlc", "file": "var_tree.cpp", "func": "VarTree::IteratorVisible VarTree::getItem( int index )\n{\n   Iterator it =\n        m_flat ? getLeaf( index + 1 )\n               : getVisibleItem( index + 1 );\n\n   return IteratorVisible( it, this );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "playtree.cpp", "func": "void Playtree::delSelected()\n{\n    for( Iterator it = m_children.begin(); it != m_children.end(); )\n    {\n        if( it->isSelected() && !it->isReadonly() )\n        {\n            vlc_playlist_Lock( getPL() );\n            ssize_t idx = vlc_playlist_IndexOfMedia( getPL(), it->getMedia() );\n            if( idx != -1 )\n                vlc_playlist_Remove( getPL(), idx, 1 ),\n            vlc_playlist_Unlock( getPL() );\n\n            it = it->getNextSiblingOrUncle();\n        }\n        else\n        {\n            it = getNextItem( it );\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "playtree.cpp", "func": "void Playtree::action( VarTree *pElem )\n{\n    if( !pElem->getMedia() )\n        return;\n    vlc_playlist_Lock( getPL() );\n    ssize_t idx = vlc_playlist_IndexOfMedia( getPL(), pElem->getMedia() );\n    if( idx != -1 )\n        vlc_playlist_PlayAt( getPL(), idx );\n    vlc_playlist_Unlock( getPL() );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "playtree.cpp", "func": "void Playtree::onChange()\n{\n    buildTree();\n    tree_update descr( tree_update::ResetAll, end() );\n    notify( &descr );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "playtree.cpp", "func": "void Playtree::onUpdateItem( int pos )\n{\n    Iterator it = getPlaylistIt( pos  );\n    if( it != m_children.end() )\n    {\n        vlc_playlist_Lock( getPL() );\n        vlc_playlist_item_t *item = vlc_playlist_Get( getPL(), pos );\n        input_item_t* media = vlc_playlist_item_GetMedia( item ) ;\n        if( media != it->getMedia() )\n            it->setMedia( media );\n        vlc_playlist_Unlock( getPL() );\n\n        bool updateNeeded = false;\n\n        bool isPlaying = (pos == m_currentIndex);\n        if( it->isPlaying() != isPlaying )\n        {\n            it->setPlaying( isPlaying );\n            updateNeeded = true;\n        }\n\n        UString *pName = getTitle( media );\n        if( *pName != *(it->getString()) )\n        {\n            it->setString( UStringPtr( pName ) );\n            updateNeeded = true;\n        }\n        else\n        {\n            delete pName;\n        }\n\n        if( updateNeeded )\n        {\n            tree_update descr(\n                tree_update::ItemUpdated, IteratorVisible( it, this ) );\n            notify( &descr );\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "playtree.cpp", "func": "void Playtree::onUpdatePlaying( int pos )\n{\n    if( m_currentIndex != -1 && m_currentIndex != pos )\n    {\n        // de-highlight previous item\n        Iterator it = getPlaylistIt( m_currentIndex );\n        it->setPlaying( false );\n\n        tree_update descr(\n            tree_update::ItemUpdated, IteratorVisible( it, this ) );\n        notify( &descr );\n    }\n    m_currentIndex = pos;\n    if( m_currentIndex != -1 )\n    {\n        // highlight new item\n        Iterator it = getPlaylistIt( m_currentIndex );\n        it->setPlaying( true );\n\n        tree_update descr(\n            tree_update::ItemUpdated, IteratorVisible( it, this ) );\n        notify( &descr );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "playtree.cpp", "func": "void Playtree::onDelete( int pos )\n{\n    Iterator it = getPlaylistIt( pos );\n    if( it != m_children.end() )\n    {\n        VarTree* parent = it->parent();\n        if( parent )\n        {\n            tree_update descr(\n                tree_update::DeletingItem, IteratorVisible( it, this ) );\n            notify( &descr );\n\n            parent->removeChild( it );\n\n            tree_update descr2(\n                tree_update::ItemDeleted, end() );\n            notify( &descr2 );\n        }\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "playtree.cpp", "func": "void Playtree::onAppend( int pos )\n{\n    Iterator it_node = m_children.begin();\n    it_node->setExpanded( true );\n\n    vlc_playlist_Lock( getPL() );\n    vlc_playlist_item_t *item = vlc_playlist_Get( getPL(), pos );\n    input_item_t* media = vlc_playlist_item_GetMedia( item ) ;\n    bool isPlaying = pos == vlc_playlist_GetCurrentIndex( getPL() );\n    vlc_playlist_Unlock( getPL() );\n\n    UString *pName = getTitle( media );\n    Iterator it = it_node->add( media, UStringPtr( pName ),\n                                false, isPlaying, false, false, pos );\n\n    tree_update descr( tree_update::ItemInserted,\n                       IteratorVisible( it, this ) );\n    notify( &descr );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "playtree.cpp", "func": "void Playtree::buildNode( int pos, VarTree &rTree )\n{\n    vlc_playlist_item_t *item = vlc_playlist_Get( getPL(), pos );\n    input_item_t *media = vlc_playlist_item_GetMedia( item );\n    UString *pName = getTitle( media );\n    bool isPlaying = pos == vlc_playlist_GetCurrentIndex(getPL());\n    (void)rTree.add( media, UStringPtr( pName ),\n                     false, isPlaying, false, false, -1 );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "playtree.cpp", "func": "void Playtree::buildTree()\n{\n    clear();\n\n    // build playlist entry\n    UString *pName = new UString( getIntf(), _( \"Playlist\" ) );\n    Iterator it = add( NULL, UStringPtr( pName ),\n                       false, false, false, false, -1 );\n\n    vlc_playlist_Lock( getPL() );\n    size_t count = vlc_playlist_Count( getPL() );\n    for( size_t pos = 0; pos < count; pos++ )\n    {\n        if( pos == 0 )\n            it->setExpanded( true );\n        buildNode( pos , *it );\n    }\n    vlc_playlist_Unlock( getPL() );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "playtree.cpp", "func": "void Playtree::onUpdateSlider()\n{\n    tree_update descr( tree_update::SliderChanged, end() );\n    notify( &descr );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "playtree.cpp", "func": "void Playtree::insertItems( VarTree& elem, const std::list<std::string>& files, bool start )\n{\n    bool first = start;\n    VarTree* p_elem = &elem;\n    VarTree* pNode = NULL;\n    int i_pos = -1;\n\n    if( p_elem == this )\n        p_elem = &*getPlaylistIt();\n\n    if( p_elem == &*getPlaylistIt() )\n    {\n        pNode = p_elem;\n        i_pos = 0;\n        p_elem->setExpanded( true );\n    }\n    else\n    if( p_elem->size() && p_elem->isExpanded() )\n    {\n        pNode = p_elem;\n        i_pos = 0;\n    }\n    else\n    {\n        pNode = p_elem->parent() ? p_elem->parent() : p_elem;\n        i_pos = p_elem->getIndex();\n        i_pos++;\n    }\n\n    assert( pNode != NULL );\n\n    vlc_playlist_Lock( getPL() );\n    for( std::list<std::string>::const_iterator it = files.begin();\n         it != files.end(); ++it, i_pos++ )\n    {\n        input_item_t *pItem;\n\n        if( strstr( it->c_str(), \"://\" ) )\n            pItem = input_item_New( it->c_str(), NULL );\n        else\n        {\n            char *psz_uri = vlc_path2uri( it->c_str(), NULL );\n            if( psz_uri == NULL )\n                continue;\n            pItem = input_item_New( psz_uri, NULL );\n            free( psz_uri );\n        }\n\n        if( pItem == NULL)\n            continue;\n\n        vlc_playlist_Insert( getPL(),i_pos, &pItem, 1 );\n        if( first )\n        {\n            first = false;\n            vlc_playlist_PlayAt( getPL(),i_pos );\n        }\n    }\n    vlc_playlist_Unlock( getPL() );\n\n}\n", "label": "GUI"}
{"project": "vlc", "file": "playtree.cpp", "func": "UString* Playtree::getTitle( input_item_t *pItem )\n{\n    char *psz_name = input_item_GetTitleFbName( pItem );\n    UString *pTitle = new UString( getIntf(), psz_name );\n    free( psz_name );\n    return pTitle;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "playtree.cpp", "func": "VarTree::Iterator Playtree::getPlaylistIt( int pos )\n{\n    // Playlist Node\n    Iterator it = m_children.begin();\n    if( pos == -1 )\n        return it;\n\n    // first playlist item  (pos=0)\n    it = getNextItem( it );\n    for( int i = 0; i < pos; i++ )\n        it = getNextItem( it );\n    return it;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "time.cpp", "func": "inline bool StreamTime::havePosition() const {\n\n    float position = 0.0;\n    vlc_player_t *player = vlc_playlist_GetPlayer( getPL() );\n\n    if( player )\n    {\n        vlc_playlist_Lock( getPL() );\n        position = vlc_player_GetPosition( player );\n        vlc_playlist_Unlock( getPL() );\n    }\n    return player && (position != 0.0);\n}\n", "label": "GUI"}
{"project": "vlc", "file": "time.cpp", "func": "void StreamTime::set( float percentage, bool updateVLC )\n{\n    VarPercent::set( percentage );\n\n    // Avoid looping forever...\n    if( updateVLC )\n    {\n        vlc_player_t *player = vlc_playlist_GetPlayer( getPL() );\n        vlc_playlist_Lock( getPL() );\n        vlc_player_SetPosition( player, percentage );\n        vlc_playlist_Unlock( getPL() );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "time.cpp", "func": "std::string StreamTime::getAsStringPercent() const\n{\n    int value = (int)(100. * get());\n    // 0 <= value <= 100, so we need 4 chars\n    char str[4];\n    snprintf( str, 4, \"%d\", value );\n    return std::string(str);\n}\n", "label": "GUI"}
{"project": "vlc", "file": "time.cpp", "func": "std::string StreamTime::formatTime( int seconds, bool bShortFormat ) const\n{\n    char psz_time[MSTRTIME_MAX_SIZE];\n    if( bShortFormat && (seconds < 60 * 60) )\n    {\n        snprintf( psz_time, MSTRTIME_MAX_SIZE, \"%02d:%02d\",\n                  (int) (seconds / 60 % 60),\n                  (int) (seconds % 60) );\n    }\n    else\n    {\n        snprintf( psz_time, MSTRTIME_MAX_SIZE, \"%d:%02d:%02d\",\n                  (int) (seconds / (60 * 60)),\n                  (int) (seconds / 60 % 60),\n                  (int) (seconds % 60) );\n    }\n    return std::string(psz_time);\n}\n", "label": "GUI"}
{"project": "vlc", "file": "time.cpp", "func": "std::string StreamTime::getAsStringCurrTime( bool bShortFormat ) const\n{\n    vlc_player_t *player = vlc_playlist_GetPlayer( getPL() );\n    if( !havePosition() )\n        return \"-:--:--\";\n\n    vlc_playlist_Lock( getPL() );\n    vlc_tick_t time = vlc_player_GetTime( player );\n    vlc_playlist_Unlock( getPL() );\n    return formatTime( SEC_FROM_VLC_TICK(time), bShortFormat );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "time.cpp", "func": "std::string StreamTime::getAsStringTimeLeft( bool bShortFormat ) const\n{\n    vlc_player_t *player = vlc_playlist_GetPlayer( getPL() );\n    if( !havePosition() )\n        return \"-:--:--\";\n\n    vlc_playlist_Lock( getPL() );\n    vlc_tick_t time = vlc_player_GetTime( player );\n    vlc_tick_t duration = vlc_player_GetLength( player );\n    vlc_playlist_Unlock( getPL() );\n    return formatTime( SEC_FROM_VLC_TICK(duration - time), bShortFormat );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "time.cpp", "func": "std::string StreamTime::getAsStringDuration( bool bShortFormat ) const\n{\n    vlc_player_t *player = vlc_playlist_GetPlayer( getPL() );\n    if( !havePosition() )\n        return \"-:--:--\";\n\n    vlc_playlist_Lock( getPL() );\n    vlc_tick_t duration = vlc_player_GetLength( player );\n    vlc_playlist_Unlock( getPL() );\n    return formatTime( SEC_FROM_VLC_TICK(duration), bShortFormat );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "volume.cpp", "func": "void Volume::set( float percentage, bool updateVLC )\n{\n    VarPercent::set( percentage );\n    if( updateVLC )\n    {\n        vlc_player_t *player = vlc_playlist_GetPlayer( getPL());\n        vlc_player_aout_SetVolume( player, getVolume() );\n    }\n}\n", "label": "GUI"}
{"project": "vlc", "file": "volume.cpp", "func": "void Volume::setVolume( float volume, bool updateVLC )\n{\n    // translate from [0.,AOUT_VOLUME_MAX/AOUT_VOLUME_DEFAULT] into [0.,1.]\n    float percentage = (volume > 0.f ) ?\n                       volume * AOUT_VOLUME_DEFAULT / AOUT_VOLUME_MAX :\n                       0.f;\n    set( percentage, updateVLC );\n}\n", "label": "GUI"}
{"project": "vlc", "file": "volume.cpp", "func": "float Volume::getVolume() const\n{\n    // translate from [0.,1.] into [0.,AOUT_VOLUME_MAX/AOUT_VOLUME_DEFAULT]\n    return get() * AOUT_VOLUME_MAX / AOUT_VOLUME_DEFAULT;\n}\n", "label": "GUI"}
{"project": "vlc", "file": "volume.cpp", "func": "std::string Volume::getAsStringPercent() const\n{\n    int value = lround( getVolume() * 100. );\n    // 0 <= value <= 200, so we need 4 chars\n    char str[4];\n    snprintf( str, 4, \"%i\", value );\n    return std::string(str);\n}\n", "label": "GUI"}
{"project": "vlc", "file": "udp.c", "func": "static int net_ListenSingle (vlc_object_t *obj, const char *host, unsigned port,\n                             int protocol)\n{\n    struct addrinfo hints = {\n        .ai_socktype = SOCK_DGRAM,\n        .ai_protocol = protocol,\n        .ai_flags = AI_PASSIVE | AI_NUMERICSERV | AI_IDN,\n    }, *res;\n\n    if (host && !*host)\n        host = NULL;\n\n    msg_Dbg (obj, \"net: opening %s datagram port %u\",\n             host ? host : \"any\", port);\n\n    int val = vlc_getaddrinfo (host, port, &hints, &res);\n    if (val)\n    {\n        msg_Err (obj, \"Cannot resolve %s port %u : %s\", host, port,\n                 gai_strerror (val));\n        return -1;\n    }\n\n    val = -1;\n\n    for (const struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)\n    {\n        int fd = net_Socket (obj, ptr->ai_family, ptr->ai_socktype,\n                             ptr->ai_protocol);\n        if (fd == -1)\n        {\n            msg_Dbg (obj, \"socket error: %s\", vlc_strerror_c(net_errno));\n            continue;\n        }\n\n#ifdef IPV6_V6ONLY\n        /* Try dual-mode IPv6 if available. */\n        if (ptr->ai_family == AF_INET6)\n            setsockopt (fd, SOL_IPV6, IPV6_V6ONLY, &(int){ 0 }, sizeof (int));\n#endif\n        fd = net_SetupDgramSocket( obj, fd, ptr );\n        if( fd == -1 )\n            continue;\n\n        if (net_SockAddrIsMulticast (ptr->ai_addr, ptr->ai_addrlen)\n         && net_Subscribe (obj, fd, ptr->ai_addr, ptr->ai_addrlen))\n        {\n            net_Close (fd);\n            continue;\n        }\n\n        val = fd;\n        break;\n    }\n\n    freeaddrinfo (res);\n    return val;\n}\n", "label": "network"}
{"project": "vlc", "file": "udp.c", "func": "static int net_SetMcastHopLimit( vlc_object_t *p_this,\n                                 int fd, int family, int hlim )\n{\n    int proto, cmd;\n\n    /* There is some confusion in the world whether IP_MULTICAST_TTL\n     * takes a byte or an int as an argument.\n     * BSD seems to indicate byte so we are going with that and use\n     * int as a fallback to be safe */\n    switch( family )\n    {\n#ifdef IP_MULTICAST_TTL\n        case AF_INET:\n            proto = SOL_IP;\n            cmd = IP_MULTICAST_TTL;\n            break;\n#endif\n\n#ifdef IPV6_MULTICAST_HOPS\n        case AF_INET6:\n            proto = SOL_IPV6;\n            cmd = IPV6_MULTICAST_HOPS;\n            break;\n#endif\n\n        default:\n            errno = EAFNOSUPPORT;\n            msg_Warn( p_this, \"%s\", vlc_strerror_c(EAFNOSUPPORT) );\n            return VLC_EGENERIC;\n    }\n\n    if( setsockopt( fd, proto, cmd, &hlim, sizeof( hlim ) ) < 0 )\n    {\n        /* BSD compatibility */\n        unsigned char buf;\n\n        msg_Dbg( p_this, \"cannot set hop limit (%d): %s\", hlim,\n                 vlc_strerror_c(net_errno) );\n        buf = (unsigned char)(( hlim > 255 ) ? 255 : hlim);\n        if( setsockopt( fd, proto, cmd, &buf, sizeof( buf ) ) )\n        {\n            msg_Err( p_this, \"cannot set hop limit (%d): %s\", hlim,\n                     vlc_strerror_c(net_errno) );\n            return VLC_EGENERIC;\n        }\n    }\n\n    return VLC_SUCCESS;\n}\n", "label": "network"}
{"project": "vlc", "file": "udp.c", "func": "static int net_SetMcastOut (vlc_object_t *p_this, int fd, int family,\n                            const char *iface)\n{\n    int scope = if_nametoindex (iface);\n    if (scope == 0)\n    {\n        msg_Err (p_this, \"invalid multicast interface: %s\", iface);\n        return -1;\n    }\n\n    switch (family)\n    {\n#ifdef IPV6_MULTICAST_IF\n        case AF_INET6:\n            if (setsockopt (fd, SOL_IPV6, IPV6_MULTICAST_IF,\n                            &scope, sizeof (scope)) == 0)\n                return 0;\n            break;\n#endif\n\n#ifdef __linux__\n        case AF_INET:\n        {\n            struct ip_mreqn req = { .imr_ifindex = scope };\n            if (setsockopt (fd, SOL_IP, IP_MULTICAST_IF,\n                            &req, sizeof (req)) == 0)\n                return 0;\n            break;\n        }\n#endif\n        default:\n            errno = EAFNOSUPPORT;\n    }\n    msg_Err (p_this, \"cannot force multicast interface %s: %s\", iface,\n             vlc_strerror_c(errno));\n    return -1;\n}\n", "label": "network"}
{"project": "vlc", "file": "udp.c", "func": "static unsigned var_GetIfIndex (vlc_object_t *obj)\n{\n    char *ifname = var_InheritString (obj, \"miface\");\n    if (ifname == NULL)\n        return 0;\n\n    unsigned ifindex = if_nametoindex (ifname);\n    if (ifindex == 0)\n        msg_Err (obj, \"invalid multicast interface: %s\", ifname);\n    free (ifname);\n    return ifindex;\n}\n", "label": "network"}
{"project": "vlc", "file": "udp.c", "func": "static int\nnet_SourceSubscribe (vlc_object_t *obj, int fd,\n                     const struct sockaddr *src, socklen_t srclen,\n                     const struct sockaddr *grp, socklen_t grplen)\n{\n/* MCAST_JOIN_SOURCE_GROUP was introduced to OS X in v10.7, but it doesn't work,\n * so ignore it to use the same code path as on 10.5 or 10.6 */\n#if defined (MCAST_JOIN_SOURCE_GROUP) && !defined (__APPLE__)\n    /* Family-agnostic Source-Specific Multicast join */\n    int level;\n    struct group_source_req gsr;\n\n    memset (&gsr, 0, sizeof (gsr));\n    gsr.gsr_interface = var_GetIfIndex (obj);\n\n    switch (grp->sa_family)\n    {\n#ifdef AF_INET6\n        case AF_INET6:\n            level = SOL_IPV6;\n            break;\n#endif\n        case AF_INET:\n            level = SOL_IP;\n            break;\n        default:\n            errno = EAFNOSUPPORT;\n            return -1;\n    }\n\n    assert(grplen <= (socklen_t)sizeof (gsr.gsr_group));\n    memcpy (&gsr.gsr_source, src, srclen);\n    assert(srclen <= (socklen_t)sizeof (gsr.gsr_source));\n    memcpy (&gsr.gsr_group,  grp, grplen);\n\n#ifdef AF_INET6\n    if (grp->sa_family == AF_INET6)\n    {\n        uint32_t scope_id;\n\n        assert(grplen >= (socklen_t)sizeof (struct sockaddr_in6));\n        memcpy(&scope_id, ((unsigned char *)grp)\n                          + offsetof (struct sockaddr_in6, sin6_scope_id), 4);\n        if (scope_id != 0)\n            gsr.gsr_interface = scope_id;\n    }\n#endif\n\n    if (setsockopt (fd, level, MCAST_JOIN_SOURCE_GROUP,\n                    &gsr, sizeof (gsr)) == 0)\n        return 0;\n\n#else\n    if (src->sa_family != grp->sa_family)\n    {\n        errno = EAFNOSUPPORT;\n        return -1;\n    }\n\n    switch (grp->sa_family)\n    {\n# ifdef IP_ADD_SOURCE_MEMBERSHIP\n        /* IPv4-specific API */\n        case AF_INET:\n        {\n            struct ip_mreq_source imr;\n\n            memset (&imr, 0, sizeof (imr));\n            assert(grplen >= (socklen_t)sizeof (struct sockaddr_in));\n            imr.imr_multiaddr = ((const struct sockaddr_in *)grp)->sin_addr;\n            assert(srclen >= (socklen_t)sizeof (struct sockaddr_in));\n            imr.imr_sourceaddr = ((const struct sockaddr_in *)src)->sin_addr;\n            if (setsockopt (fd, SOL_IP, IP_ADD_SOURCE_MEMBERSHIP,\n                            &imr, sizeof (imr)) == 0)\n                return 0;\n            break;\n        }\n# endif\n        default:\n            errno = EAFNOSUPPORT;\n    }\n\n#endif\n    msg_Err (obj, \"cannot join source multicast group: %s\",\n             vlc_strerror_c(net_errno));\n    msg_Warn (obj, \"trying ASM instead of SSM...\");\n    return net_Subscribe (obj, fd, grp, grplen);\n}\n", "label": "network"}
{"project": "vlc", "file": "udp.c", "func": "static int net_Subscribe(vlc_object_t *obj, int fd,\n                         const struct sockaddr *grp, socklen_t grplen)\n{\n/* MCAST_JOIN_GROUP was introduced to OS X in v10.7, but it doesn't work,\n * so ignore it to use the same code as on 10.5 or 10.6 */\n#if defined (MCAST_JOIN_GROUP) && !defined (__APPLE__)\n    /* Family-agnostic Any-Source Multicast join */\n    int level;\n    struct group_req gr;\n\n    memset (&gr, 0, sizeof (gr));\n    gr.gr_interface = var_GetIfIndex (obj);\n\n    switch (grp->sa_family)\n    {\n#ifdef AF_INET6\n        case AF_INET6:\n            level = SOL_IPV6;\n            break;\n#endif\n        case AF_INET:\n            level = SOL_IP;\n            break;\n        default:\n            errno = EAFNOSUPPORT;\n            return -1;\n    }\n\n    assert(grplen <= (socklen_t)sizeof (gr.gr_group));\n    memcpy (&gr.gr_group, grp, grplen);\n\n#ifdef AF_INET6\n    if (grp->sa_family == AF_INET6)\n    {\n        uint32_t scope_id;\n\n        assert(grplen >= (socklen_t)sizeof (struct sockaddr_in6));\n        memcpy(&scope_id, ((unsigned char *)grp)\n                          + offsetof (struct sockaddr_in6, sin6_scope_id), 4);\n        if (scope_id != 0)\n            gr.gr_interface = scope_id;\n    }\n#endif\n\n    if (setsockopt (fd, level, MCAST_JOIN_GROUP, &gr, sizeof (gr)) == 0)\n        return 0;\n\n#else\n    switch (grp->sa_family)\n    {\n# ifdef IPV6_JOIN_GROUP\n        case AF_INET6:\n        {\n            struct ipv6_mreq ipv6mr;\n            const struct sockaddr_in6 *g6 = (const struct sockaddr_in6 *)grp;\n\n            memset (&ipv6mr, 0, sizeof (ipv6mr));\n            assert(grplen >= (socklen_t)sizeof (struct sockaddr_in6));\n            ipv6mr.ipv6mr_multiaddr = g6->sin6_addr;\n            ipv6mr.ipv6mr_interface = g6->sin6_scope_id;\n            if (!setsockopt (fd, SOL_IPV6, IPV6_JOIN_GROUP,\n                             &ipv6mr, sizeof (ipv6mr)))\n                return 0;\n            break;\n        }\n# endif\n# ifdef IP_ADD_MEMBERSHIP\n        case AF_INET:\n        {\n            struct ip_mreq imr;\n\n            memset (&imr, 0, sizeof (imr));\n            assert(grplen >= (socklen_t)sizeof (struct sockaddr_in));\n            imr.imr_multiaddr = ((const struct sockaddr_in *)grp)->sin_addr;\n            if (setsockopt (fd, SOL_IP, IP_ADD_MEMBERSHIP,\n                            &imr, sizeof (imr)) == 0)\n                return 0;\n            break;\n        }\n# endif\n        default:\n            errno = EAFNOSUPPORT;\n    }\n\n#endif\n    msg_Err (obj, \"cannot join multicast group: %s\",\n             vlc_strerror_c(net_errno));\n    return -1;\n}\n", "label": "network"}
{"project": "vlc", "file": "udp.c", "func": "static int net_SetDSCP( int fd, uint8_t dscp )\n{\n    union {\n        struct sockaddr a;\n        struct sockaddr_in in;\n#ifdef IPV6_TCLASS\n        struct sockaddr_in in6;\n#endif\n    } addr;\n\n    if (getsockname(fd, &addr.a, &(socklen_t){ sizeof (addr) }))\n        return -1;\n\n    int level, cmd;\n\n    switch (addr.a.sa_family)\n    {\n#ifdef IPV6_TCLASS\n        case AF_INET6:\n            level = SOL_IPV6;\n            cmd = IPV6_TCLASS;\n            break;\n#endif\n\n        case AF_INET:\n            level = SOL_IP;\n            cmd = IP_TOS;\n            break;\n\n        default:\n#ifdef ENOPROTOOPT\n            errno = ENOPROTOOPT;\n#endif\n            return -1;\n    }\n\n    return setsockopt( fd, level, cmd, &(int){ dscp }, sizeof (int));\n}\n", "label": "network"}
{"project": "vlc", "file": "udp.c", "func": "int net_ConnectDgram( vlc_object_t *p_this, const char *psz_host, unsigned i_port,\n                      int i_hlim, int proto )\n{\n    struct addrinfo hints = {\n        .ai_socktype = SOCK_DGRAM,\n        .ai_protocol = proto,\n        .ai_flags = AI_NUMERICSERV | AI_IDN,\n    }, *res;\n    int       i_handle = -1;\n    bool      b_unreach = false;\n\n    if( i_hlim < 0 )\n        i_hlim = var_InheritInteger( p_this, \"ttl\" );\n\n    msg_Dbg( p_this, \"net: connecting to [%s]:%u\", psz_host, i_port );\n\n    int val = vlc_getaddrinfo (psz_host, i_port, &hints, &res);\n    if (val)\n    {\n        msg_Err (p_this, \"cannot resolve [%s]:%u : %s\", psz_host, i_port,\n                 gai_strerror (val));\n        return -1;\n    }\n\n    for (struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)\n    {\n        char *str;\n        int fd = net_Socket (p_this, ptr->ai_family, ptr->ai_socktype,\n                             ptr->ai_protocol);\n        if (fd == -1)\n            continue;\n\n        /* Allow broadcast sending */\n        setsockopt (fd, SOL_SOCKET, SO_BROADCAST, &(int){ 1 }, sizeof (int));\n\n        if( i_hlim >= 0 )\n            net_SetMcastHopLimit( p_this, fd, ptr->ai_family, i_hlim );\n\n        str = var_InheritString (p_this, \"miface\");\n        if (str != NULL)\n        {\n            net_SetMcastOut (p_this, fd, ptr->ai_family, str);\n            free (str);\n        }\n\n        net_SetDSCP (fd, var_InheritInteger (p_this, \"dscp\"));\n\n        if( connect( fd, ptr->ai_addr, ptr->ai_addrlen ) == 0 )\n        {\n            /* success */\n            i_handle = fd;\n            break;\n        }\n\n#if defined( _WIN32 )\n        if( WSAGetLastError () == WSAENETUNREACH )\n#else\n        if( errno == ENETUNREACH )\n#endif\n            b_unreach = true;\n        else\n            msg_Warn( p_this, \"%s port %u : %s\", psz_host, i_port,\n                      vlc_strerror_c(errno) );\n        net_Close( fd );\n    }\n\n    freeaddrinfo( res );\n\n    if( i_handle == -1 )\n    {\n        if( b_unreach )\n            msg_Err( p_this, \"Host %s port %u is unreachable\", psz_host,\n                     i_port );\n        return -1;\n    }\n\n    return i_handle;\n}\n", "label": "network"}
{"project": "vlc", "file": "udp.c", "func": "int net_OpenDgram( vlc_object_t *obj, const char *psz_bind, unsigned i_bind,\n                   const char *psz_server, unsigned i_server, int protocol )\n{\n    if ((psz_server == NULL) || (psz_server[0] == '\\0'))\n        return net_ListenSingle (obj, psz_bind, i_bind, protocol);\n\n    msg_Dbg (obj, \"net: connecting to [%s]:%u from [%s]:%u\",\n             psz_server, i_server, psz_bind, i_bind);\n\n    struct addrinfo hints = {\n        .ai_socktype = SOCK_DGRAM,\n        .ai_protocol = protocol,\n        .ai_flags = AI_NUMERICSERV | AI_IDN,\n    }, *loc, *rem;\n\n    int val = vlc_getaddrinfo (psz_server, i_server, &hints, &rem);\n    if (val)\n    {\n        msg_Err (obj, \"cannot resolve %s port %u : %s\", psz_server, i_server,\n                 gai_strerror (val));\n        return -1;\n    }\n\n    hints.ai_flags |= AI_PASSIVE;\n    val = vlc_getaddrinfo (psz_bind, i_bind, &hints, &loc);\n    if (val)\n    {\n        msg_Err (obj, \"cannot resolve %s port %u : %s\", psz_bind, i_bind,\n                 gai_strerror (val));\n        freeaddrinfo (rem);\n        return -1;\n    }\n\n    val = -1;\n    for (struct addrinfo *ptr = loc; ptr != NULL; ptr = ptr->ai_next)\n    {\n        int fd = net_Socket (obj, ptr->ai_family, ptr->ai_socktype,\n                             ptr->ai_protocol);\n        if (fd == -1)\n            continue; // usually, address family not supported\n\n        fd = net_SetupDgramSocket( obj, fd, ptr );\n        if( fd == -1 )\n            continue;\n\n        for (struct addrinfo *ptr2 = rem; ptr2 != NULL; ptr2 = ptr2->ai_next)\n        {\n            if ((ptr2->ai_family != ptr->ai_family)\n             || (ptr2->ai_socktype != ptr->ai_socktype)\n             || (ptr2->ai_protocol != ptr->ai_protocol))\n                continue;\n\n            if (net_SockAddrIsMulticast (ptr->ai_addr, ptr->ai_addrlen)\n              ? net_SourceSubscribe (obj, fd,\n                                     ptr2->ai_addr, ptr2->ai_addrlen,\n                                     ptr->ai_addr, ptr->ai_addrlen)\n              : connect (fd, ptr2->ai_addr, ptr2->ai_addrlen))\n            {\n                msg_Err (obj, \"cannot connect to %s port %u: %s\",\n                         psz_server, i_server, vlc_strerror_c(net_errno));\n                continue;\n            }\n            val = fd;\n            break;\n        }\n\n        if (val != -1)\n            break;\n\n        net_Close (fd);\n    }\n\n    freeaddrinfo (rem);\n    freeaddrinfo (loc);\n    return val;\n}\n", "label": "network"}
{"project": "vlc", "file": "udp.c", "func": "int net_SetCSCov (int fd, int sendcov, int recvcov)\n{\n    int type;\n\n    if (getsockopt (fd, SOL_SOCKET, SO_TYPE,\n                    &type, &(socklen_t){ sizeof (type) }))\n        return VLC_EGENERIC;\n\n    switch (type)\n    {\n#ifdef UDPLITE_RECV_CSCOV\n        case SOCK_DGRAM: /* UDP-Lite */\n            if (sendcov == -1)\n                sendcov = 0;\n            else\n                sendcov += 8; /* partial */\n            if (setsockopt (fd, SOL_UDPLITE, UDPLITE_SEND_CSCOV, &sendcov,\n                            sizeof (sendcov)))\n                return VLC_EGENERIC;\n\n            if (recvcov == -1)\n                recvcov = 0;\n            else\n                recvcov += 8;\n            if (setsockopt (fd, SOL_UDPLITE, UDPLITE_RECV_CSCOV,\n                            &recvcov, sizeof (recvcov)))\n                return VLC_EGENERIC;\n\n            return VLC_SUCCESS;\n#endif\n#ifdef DCCP_SOCKOPT_SEND_CSCOV\n        case SOCK_DCCP: /* DCCP and its ill-named socket type */\n            if ((sendcov == -1) || (sendcov > 56))\n                sendcov = 0;\n            else\n                sendcov = (sendcov + 3) / 4;\n            if (setsockopt (fd, SOL_DCCP, DCCP_SOCKOPT_SEND_CSCOV,\n                            &sendcov, sizeof (sendcov)))\n                return VLC_EGENERIC;\n\n            if ((recvcov == -1) || (recvcov > 56))\n                recvcov = 0;\n            else\n                recvcov = (recvcov + 3) / 4;\n            if (setsockopt (fd, SOL_DCCP, DCCP_SOCKOPT_RECV_CSCOV,\n                            &recvcov, sizeof (recvcov)))\n                return VLC_EGENERIC;\n\n            return VLC_SUCCESS;\n#endif\n    }\n#if !defined( UDPLITE_RECV_CSCOV ) && !defined( DCCP_SOCKOPT_SEND_CSCOV )\n    VLC_UNUSED(sendcov);\n    VLC_UNUSED(recvcov);\n#endif\n\n    return VLC_EGENERIC;\n}\n", "label": "network"}
