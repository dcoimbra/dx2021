{"project": "openssl", "file": "aes_cbc.c", "func": "void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,\n                     size_t len, const AES_KEY *key,\n                     unsigned char *ivec, const int enc)\n{\n\n    if (enc)\n        CRYPTO_cbc128_encrypt(in, out, len, key, ivec,\n                              (block128_f) AES_encrypt);\n    else\n        CRYPTO_cbc128_decrypt(in, out, len, key, ivec,\n                              (block128_f) AES_decrypt);\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_cfb.c", "func": "void AES_cfb128_encrypt(const unsigned char *in, unsigned char *out,\n                        size_t length, const AES_KEY *key,\n                        unsigned char *ivec, int *num, const int enc)\n{\n\n    CRYPTO_cfb128_encrypt(in, out, length, key, ivec, num, enc,\n                          (block128_f) AES_encrypt);\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_cfb.c", "func": "void AES_cfb1_encrypt(const unsigned char *in, unsigned char *out,\n                      size_t length, const AES_KEY *key,\n                      unsigned char *ivec, int *num, const int enc)\n{\n    CRYPTO_cfb128_1_encrypt(in, out, length, key, ivec, num, enc,\n                            (block128_f) AES_encrypt);\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_cfb.c", "func": "void AES_cfb8_encrypt(const unsigned char *in, unsigned char *out,\n                      size_t length, const AES_KEY *key,\n                      unsigned char *ivec, int *num, const int enc)\n{\n    CRYPTO_cfb128_8_encrypt(in, out, length, key, ivec, num, enc,\n                            (block128_f) AES_encrypt);\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_core.c", "func": "int AES_set_encrypt_key(const unsigned char *userKey, const int bits,\n                        AES_KEY *key)\n{\n\n    u32 *rk;\n    int i = 0;\n    u32 temp;\n\n    if (!userKey || !key)\n        return -1;\n    if (bits != 128 && bits != 192 && bits != 256)\n        return -2;\n\n    rk = key->rd_key;\n\n    if (bits == 128)\n        key->rounds = 10;\n    else if (bits == 192)\n        key->rounds = 12;\n    else\n        key->rounds = 14;\n\n    rk[0] = GETU32(userKey     );\n    rk[1] = GETU32(userKey +  4);\n    rk[2] = GETU32(userKey +  8);\n    rk[3] = GETU32(userKey + 12);\n    if (bits == 128) {\n        while (1) {\n            temp  = rk[3];\n            rk[4] = rk[0] ^\n                (Te2[(temp >> 16) & 0xff] & 0xff000000) ^\n                (Te3[(temp >>  8) & 0xff] & 0x00ff0000) ^\n                (Te0[(temp      ) & 0xff] & 0x0000ff00) ^\n                (Te1[(temp >> 24)       ] & 0x000000ff) ^\n                rcon[i];\n            rk[5] = rk[1] ^ rk[4];\n            rk[6] = rk[2] ^ rk[5];\n            rk[7] = rk[3] ^ rk[6];\n            if (++i == 10) {\n                return 0;\n            }\n            rk += 4;\n        }\n    }\n    rk[4] = GETU32(userKey + 16);\n    rk[5] = GETU32(userKey + 20);\n    if (bits == 192) {\n        while (1) {\n            temp = rk[ 5];\n            rk[ 6] = rk[ 0] ^\n                (Te2[(temp >> 16) & 0xff] & 0xff000000) ^\n                (Te3[(temp >>  8) & 0xff] & 0x00ff0000) ^\n                (Te0[(temp      ) & 0xff] & 0x0000ff00) ^\n                (Te1[(temp >> 24)       ] & 0x000000ff) ^\n                rcon[i];\n            rk[ 7] = rk[ 1] ^ rk[ 6];\n            rk[ 8] = rk[ 2] ^ rk[ 7];\n            rk[ 9] = rk[ 3] ^ rk[ 8];\n            if (++i == 8) {\n                return 0;\n            }\n            rk[10] = rk[ 4] ^ rk[ 9];\n            rk[11] = rk[ 5] ^ rk[10];\n            rk += 6;\n        }\n    }\n    rk[6] = GETU32(userKey + 24);\n    rk[7] = GETU32(userKey + 28);\n    if (bits == 256) {\n        while (1) {\n            temp = rk[ 7];\n            rk[ 8] = rk[ 0] ^\n                (Te2[(temp >> 16) & 0xff] & 0xff000000) ^\n                (Te3[(temp >>  8) & 0xff] & 0x00ff0000) ^\n                (Te0[(temp      ) & 0xff] & 0x0000ff00) ^\n                (Te1[(temp >> 24)       ] & 0x000000ff) ^\n                rcon[i];\n            rk[ 9] = rk[ 1] ^ rk[ 8];\n            rk[10] = rk[ 2] ^ rk[ 9];\n            rk[11] = rk[ 3] ^ rk[10];\n            if (++i == 7) {\n                return 0;\n            }\n            temp = rk[11];\n            rk[12] = rk[ 4] ^\n                (Te2[(temp >> 24)       ] & 0xff000000) ^\n                (Te3[(temp >> 16) & 0xff] & 0x00ff0000) ^\n                (Te0[(temp >>  8) & 0xff] & 0x0000ff00) ^\n                (Te1[(temp      ) & 0xff] & 0x000000ff);\n            rk[13] = rk[ 5] ^ rk[12];\n            rk[14] = rk[ 6] ^ rk[13];\n            rk[15] = rk[ 7] ^ rk[14];\n\n            rk += 8;\n            }\n    }\n    return 0;\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_core.c", "func": "int AES_set_decrypt_key(const unsigned char *userKey, const int bits,\n                        AES_KEY *key)\n{\n\n    u32 *rk;\n    int i, j, status;\n    u32 temp;\n\n    /* first, start with an encryption schedule */\n    status = AES_set_encrypt_key(userKey, bits, key);\n    if (status < 0)\n        return status;\n\n    rk = key->rd_key;\n\n    /* invert the order of the round keys: */\n    for (i = 0, j = 4*(key->rounds); i < j; i += 4, j -= 4) {\n        temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;\n        temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\n        temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\n        temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\n    }\n    /* apply the inverse MixColumn transform to all round keys but the first and the last: */\n    for (i = 1; i < (key->rounds); i++) {\n        rk += 4;\n        rk[0] =\n            Td0[Te1[(rk[0] >> 24)       ] & 0xff] ^\n            Td1[Te1[(rk[0] >> 16) & 0xff] & 0xff] ^\n            Td2[Te1[(rk[0] >>  8) & 0xff] & 0xff] ^\n            Td3[Te1[(rk[0]      ) & 0xff] & 0xff];\n        rk[1] =\n            Td0[Te1[(rk[1] >> 24)       ] & 0xff] ^\n            Td1[Te1[(rk[1] >> 16) & 0xff] & 0xff] ^\n            Td2[Te1[(rk[1] >>  8) & 0xff] & 0xff] ^\n            Td3[Te1[(rk[1]      ) & 0xff] & 0xff];\n        rk[2] =\n            Td0[Te1[(rk[2] >> 24)       ] & 0xff] ^\n            Td1[Te1[(rk[2] >> 16) & 0xff] & 0xff] ^\n            Td2[Te1[(rk[2] >>  8) & 0xff] & 0xff] ^\n            Td3[Te1[(rk[2]      ) & 0xff] & 0xff];\n        rk[3] =\n            Td0[Te1[(rk[3] >> 24)       ] & 0xff] ^\n            Td1[Te1[(rk[3] >> 16) & 0xff] & 0xff] ^\n            Td2[Te1[(rk[3] >>  8) & 0xff] & 0xff] ^\n            Td3[Te1[(rk[3]      ) & 0xff] & 0xff];\n    }\n    return 0;\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_core.c", "func": "void AES_encrypt(const unsigned char *in, unsigned char *out,\n                 const AES_KEY *key) {\n\n    const u32 *rk;\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n#ifndef FULL_UNROLL\n    int r;\n#endif /* ?FULL_UNROLL */\n\n    assert(in && out && key);\n    rk = key->rd_key;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(in     ) ^ rk[0];\n    s1 = GETU32(in +  4) ^ rk[1];\n    s2 = GETU32(in +  8) ^ rk[2];\n    s3 = GETU32(in + 12) ^ rk[3];\n#ifdef FULL_UNROLL\n    /* round 1: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7];\n    /* round 2: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];\n    /* round 3: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15];\n    /* round 4: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19];\n    /* round 5: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[20];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[21];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[22];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[23];\n    /* round 6: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[24];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[25];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[26];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[27];\n    /* round 7: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[28];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[29];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[30];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[31];\n    /* round 8: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[32];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[33];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[34];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[35];\n    /* round 9: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[36];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[37];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[38];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[39];\n    if (key->rounds > 10) {\n        /* round 10: */\n        s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[40];\n        s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[41];\n        s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[42];\n        s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[43];\n        /* round 11: */\n        t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[44];\n        t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[45];\n        t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[46];\n        t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[47];\n        if (key->rounds > 12) {\n            /* round 12: */\n            s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[48];\n            s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[49];\n            s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[50];\n            s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[51];\n            /* round 13: */\n            t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[52];\n            t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[53];\n            t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[54];\n            t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[55];\n        }\n    }\n    rk += key->rounds << 2;\n#else  /* !FULL_UNROLL */\n    /*\n     * Nr - 1 full rounds:\n     */\n    r = key->rounds >> 1;\n    for (;;) {\n        t0 =\n            Te0[(s0 >> 24)       ] ^\n            Te1[(s1 >> 16) & 0xff] ^\n            Te2[(s2 >>  8) & 0xff] ^\n            Te3[(s3      ) & 0xff] ^\n            rk[4];\n        t1 =\n            Te0[(s1 >> 24)       ] ^\n            Te1[(s2 >> 16) & 0xff] ^\n            Te2[(s3 >>  8) & 0xff] ^\n            Te3[(s0      ) & 0xff] ^\n            rk[5];\n        t2 =\n            Te0[(s2 >> 24)       ] ^\n            Te1[(s3 >> 16) & 0xff] ^\n            Te2[(s0 >>  8) & 0xff] ^\n            Te3[(s1      ) & 0xff] ^\n            rk[6];\n        t3 =\n            Te0[(s3 >> 24)       ] ^\n            Te1[(s0 >> 16) & 0xff] ^\n            Te2[(s1 >>  8) & 0xff] ^\n            Te3[(s2      ) & 0xff] ^\n            rk[7];\n\n        rk += 8;\n        if (--r == 0) {\n            break;\n        }\n\n        s0 =\n            Te0[(t0 >> 24)       ] ^\n            Te1[(t1 >> 16) & 0xff] ^\n            Te2[(t2 >>  8) & 0xff] ^\n            Te3[(t3      ) & 0xff] ^\n            rk[0];\n        s1 =\n            Te0[(t1 >> 24)       ] ^\n            Te1[(t2 >> 16) & 0xff] ^\n            Te2[(t3 >>  8) & 0xff] ^\n            Te3[(t0      ) & 0xff] ^\n            rk[1];\n        s2 =\n            Te0[(t2 >> 24)       ] ^\n            Te1[(t3 >> 16) & 0xff] ^\n            Te2[(t0 >>  8) & 0xff] ^\n            Te3[(t1      ) & 0xff] ^\n            rk[2];\n        s3 =\n            Te0[(t3 >> 24)       ] ^\n            Te1[(t0 >> 16) & 0xff] ^\n            Te2[(t1 >>  8) & 0xff] ^\n            Te3[(t2      ) & 0xff] ^\n            rk[3];\n    }\n#endif /* ?FULL_UNROLL */\n    /*\n     * apply last round and\n     * map cipher state to byte array block:\n     */\n    s0 =\n        (Te2[(t0 >> 24)       ] & 0xff000000) ^\n        (Te3[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te0[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te1[(t3      ) & 0xff] & 0x000000ff) ^\n        rk[0];\n    PUTU32(out     , s0);\n    s1 =\n        (Te2[(t1 >> 24)       ] & 0xff000000) ^\n        (Te3[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te0[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te1[(t0      ) & 0xff] & 0x000000ff) ^\n        rk[1];\n    PUTU32(out +  4, s1);\n    s2 =\n        (Te2[(t2 >> 24)       ] & 0xff000000) ^\n        (Te3[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te0[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te1[(t1      ) & 0xff] & 0x000000ff) ^\n        rk[2];\n    PUTU32(out +  8, s2);\n    s3 =\n        (Te2[(t3 >> 24)       ] & 0xff000000) ^\n        (Te3[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te0[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te1[(t2      ) & 0xff] & 0x000000ff) ^\n        rk[3];\n    PUTU32(out + 12, s3);\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_core.c", "func": "void AES_decrypt(const unsigned char *in, unsigned char *out,\n                 const AES_KEY *key)\n{\n\n    const u32 *rk;\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n#ifndef FULL_UNROLL\n    int r;\n#endif /* ?FULL_UNROLL */\n\n    assert(in && out && key);\n    rk = key->rd_key;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(in     ) ^ rk[0];\n    s1 = GETU32(in +  4) ^ rk[1];\n    s2 = GETU32(in +  8) ^ rk[2];\n    s3 = GETU32(in + 12) ^ rk[3];\n#ifdef FULL_UNROLL\n    /* round 1: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7];\n    /* round 2: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11];\n    /* round 3: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15];\n    /* round 4: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[16];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[17];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[18];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[19];\n    /* round 5: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[20];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[21];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[22];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[23];\n    /* round 6: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[24];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[25];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[26];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[27];\n    /* round 7: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[28];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[29];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[30];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[31];\n    /* round 8: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[32];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[33];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[34];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[35];\n    /* round 9: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[36];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[37];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[38];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[39];\n    if (key->rounds > 10) {\n        /* round 10: */\n        s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[40];\n        s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[41];\n        s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[42];\n        s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[43];\n        /* round 11: */\n        t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[44];\n        t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[45];\n        t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[46];\n        t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[47];\n        if (key->rounds > 12) {\n            /* round 12: */\n            s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[48];\n            s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[49];\n            s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[50];\n            s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[51];\n            /* round 13: */\n            t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[52];\n            t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[53];\n            t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[54];\n            t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[55];\n        }\n    }\n    rk += key->rounds << 2;\n#else  /* !FULL_UNROLL */\n    /*\n     * Nr - 1 full rounds:\n     */\n    r = key->rounds >> 1;\n    for (;;) {\n        t0 =\n            Td0[(s0 >> 24)       ] ^\n            Td1[(s3 >> 16) & 0xff] ^\n            Td2[(s2 >>  8) & 0xff] ^\n            Td3[(s1      ) & 0xff] ^\n            rk[4];\n        t1 =\n            Td0[(s1 >> 24)       ] ^\n            Td1[(s0 >> 16) & 0xff] ^\n            Td2[(s3 >>  8) & 0xff] ^\n            Td3[(s2      ) & 0xff] ^\n            rk[5];\n        t2 =\n            Td0[(s2 >> 24)       ] ^\n            Td1[(s1 >> 16) & 0xff] ^\n            Td2[(s0 >>  8) & 0xff] ^\n            Td3[(s3      ) & 0xff] ^\n            rk[6];\n        t3 =\n            Td0[(s3 >> 24)       ] ^\n            Td1[(s2 >> 16) & 0xff] ^\n            Td2[(s1 >>  8) & 0xff] ^\n            Td3[(s0      ) & 0xff] ^\n            rk[7];\n\n        rk += 8;\n        if (--r == 0) {\n            break;\n        }\n\n        s0 =\n            Td0[(t0 >> 24)       ] ^\n            Td1[(t3 >> 16) & 0xff] ^\n            Td2[(t2 >>  8) & 0xff] ^\n            Td3[(t1      ) & 0xff] ^\n            rk[0];\n        s1 =\n            Td0[(t1 >> 24)       ] ^\n            Td1[(t0 >> 16) & 0xff] ^\n            Td2[(t3 >>  8) & 0xff] ^\n            Td3[(t2      ) & 0xff] ^\n            rk[1];\n        s2 =\n            Td0[(t2 >> 24)       ] ^\n            Td1[(t1 >> 16) & 0xff] ^\n            Td2[(t0 >>  8) & 0xff] ^\n            Td3[(t3      ) & 0xff] ^\n            rk[2];\n        s3 =\n            Td0[(t3 >> 24)       ] ^\n            Td1[(t2 >> 16) & 0xff] ^\n            Td2[(t1 >>  8) & 0xff] ^\n            Td3[(t0      ) & 0xff] ^\n            rk[3];\n    }\n#endif /* ?FULL_UNROLL */\n    /*\n     * apply last round and\n     * map cipher state to byte array block:\n     */\n    s0 =\n        ((u32)Td4[(t0 >> 24)       ] << 24) ^\n        ((u32)Td4[(t3 >> 16) & 0xff] << 16) ^\n        ((u32)Td4[(t2 >>  8) & 0xff] <<  8) ^\n        ((u32)Td4[(t1      ) & 0xff])       ^\n        rk[0];\n    PUTU32(out     , s0);\n    s1 =\n        ((u32)Td4[(t1 >> 24)       ] << 24) ^\n        ((u32)Td4[(t0 >> 16) & 0xff] << 16) ^\n        ((u32)Td4[(t3 >>  8) & 0xff] <<  8) ^\n        ((u32)Td4[(t2      ) & 0xff])       ^\n        rk[1];\n    PUTU32(out +  4, s1);\n    s2 =\n        ((u32)Td4[(t2 >> 24)       ] << 24) ^\n        ((u32)Td4[(t1 >> 16) & 0xff] << 16) ^\n        ((u32)Td4[(t0 >>  8) & 0xff] <<  8) ^\n        ((u32)Td4[(t3      ) & 0xff])       ^\n        rk[2];\n    PUTU32(out +  8, s2);\n    s3 =\n        ((u32)Td4[(t3 >> 24)       ] << 24) ^\n        ((u32)Td4[(t2 >> 16) & 0xff] << 16) ^\n        ((u32)Td4[(t1 >>  8) & 0xff] <<  8) ^\n        ((u32)Td4[(t0      ) & 0xff])       ^\n        rk[3];\n    PUTU32(out + 12, s3);\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_ecb.c", "func": "void AES_ecb_encrypt(const unsigned char *in, unsigned char *out,\n                     const AES_KEY *key, const int enc)\n{\n\n    assert(in && out && key);\n    assert((AES_ENCRYPT == enc) || (AES_DECRYPT == enc));\n\n    if (AES_ENCRYPT == enc)\n        AES_encrypt(in, out, key);\n    else\n        AES_decrypt(in, out, key);\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_ige.c", "func": "void AES_ige_encrypt(const unsigned char *in, unsigned char *out,\n                     size_t length, const AES_KEY *key,\n                     unsigned char *ivec, const int enc)\n{\n    size_t n;\n    size_t len = length / AES_BLOCK_SIZE;\n\n    if (length == 0)\n        return;\n\n    OPENSSL_assert(in && out && key && ivec);\n    OPENSSL_assert((AES_ENCRYPT == enc) || (AES_DECRYPT == enc));\n    OPENSSL_assert((length % AES_BLOCK_SIZE) == 0);\n\n    if (AES_ENCRYPT == enc) {\n        if (in != out &&\n            (UNALIGNED_MEMOPS_ARE_FAST\n             || ((size_t)in | (size_t)out | (size_t)ivec) % sizeof(long) ==\n             0)) {\n            aes_block_t *ivp = (aes_block_t *) ivec;\n            aes_block_t *iv2p = (aes_block_t *) (ivec + AES_BLOCK_SIZE);\n\n            while (len) {\n                aes_block_t *inp = (aes_block_t *) in;\n                aes_block_t *outp = (aes_block_t *) out;\n\n                for (n = 0; n < N_WORDS; ++n)\n                    outp->data[n] = inp->data[n] ^ ivp->data[n];\n                AES_encrypt((unsigned char *)outp->data,\n                            (unsigned char *)outp->data, key);\n                for (n = 0; n < N_WORDS; ++n)\n                    outp->data[n] ^= iv2p->data[n];\n                ivp = outp;\n                iv2p = inp;\n                --len;\n                in += AES_BLOCK_SIZE;\n                out += AES_BLOCK_SIZE;\n            }\n            memcpy(ivec, ivp->data, AES_BLOCK_SIZE);\n            memcpy(ivec + AES_BLOCK_SIZE, iv2p->data, AES_BLOCK_SIZE);\n        } else {\n            aes_block_t tmp, tmp2;\n            aes_block_t iv;\n            aes_block_t iv2;\n\n            load_block(iv, ivec);\n            load_block(iv2, ivec + AES_BLOCK_SIZE);\n\n            while (len) {\n                load_block(tmp, in);\n                for (n = 0; n < N_WORDS; ++n)\n                    tmp2.data[n] = tmp.data[n] ^ iv.data[n];\n                AES_encrypt((unsigned char *)tmp2.data,\n                            (unsigned char *)tmp2.data, key);\n                for (n = 0; n < N_WORDS; ++n)\n                    tmp2.data[n] ^= iv2.data[n];\n                store_block(out, tmp2);\n                iv = tmp2;\n                iv2 = tmp;\n                --len;\n                in += AES_BLOCK_SIZE;\n                out += AES_BLOCK_SIZE;\n            }\n            memcpy(ivec, iv.data, AES_BLOCK_SIZE);\n            memcpy(ivec + AES_BLOCK_SIZE, iv2.data, AES_BLOCK_SIZE);\n        }\n    } else {\n        if (in != out &&\n            (UNALIGNED_MEMOPS_ARE_FAST\n             || ((size_t)in | (size_t)out | (size_t)ivec) % sizeof(long) ==\n             0)) {\n            aes_block_t *ivp = (aes_block_t *) ivec;\n            aes_block_t *iv2p = (aes_block_t *) (ivec + AES_BLOCK_SIZE);\n\n            while (len) {\n                aes_block_t tmp;\n                aes_block_t *inp = (aes_block_t *) in;\n                aes_block_t *outp = (aes_block_t *) out;\n\n                for (n = 0; n < N_WORDS; ++n)\n                    tmp.data[n] = inp->data[n] ^ iv2p->data[n];\n                AES_decrypt((unsigned char *)tmp.data,\n                            (unsigned char *)outp->data, key);\n                for (n = 0; n < N_WORDS; ++n)\n                    outp->data[n] ^= ivp->data[n];\n                ivp = inp;\n                iv2p = outp;\n                --len;\n                in += AES_BLOCK_SIZE;\n                out += AES_BLOCK_SIZE;\n            }\n            memcpy(ivec, ivp->data, AES_BLOCK_SIZE);\n            memcpy(ivec + AES_BLOCK_SIZE, iv2p->data, AES_BLOCK_SIZE);\n        } else {\n            aes_block_t tmp, tmp2;\n            aes_block_t iv;\n            aes_block_t iv2;\n\n            load_block(iv, ivec);\n            load_block(iv2, ivec + AES_BLOCK_SIZE);\n\n            while (len) {\n                load_block(tmp, in);\n                tmp2 = tmp;\n                for (n = 0; n < N_WORDS; ++n)\n                    tmp.data[n] ^= iv2.data[n];\n                AES_decrypt((unsigned char *)tmp.data,\n                            (unsigned char *)tmp.data, key);\n                for (n = 0; n < N_WORDS; ++n)\n                    tmp.data[n] ^= iv.data[n];\n                store_block(out, tmp);\n                iv = tmp2;\n                iv2 = tmp;\n                --len;\n                in += AES_BLOCK_SIZE;\n                out += AES_BLOCK_SIZE;\n            }\n            memcpy(ivec, iv.data, AES_BLOCK_SIZE);\n            memcpy(ivec + AES_BLOCK_SIZE, iv2.data, AES_BLOCK_SIZE);\n        }\n    }\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_ige.c", "func": "void AES_bi_ige_encrypt(const unsigned char *in, unsigned char *out,\n                        size_t length, const AES_KEY *key,\n                        const AES_KEY *key2, const unsigned char *ivec,\n                        const int enc)\n{\n    size_t n;\n    size_t len = length;\n    unsigned char tmp[AES_BLOCK_SIZE];\n    unsigned char tmp2[AES_BLOCK_SIZE];\n    unsigned char tmp3[AES_BLOCK_SIZE];\n    unsigned char prev[AES_BLOCK_SIZE];\n    const unsigned char *iv;\n    const unsigned char *iv2;\n\n    OPENSSL_assert(in && out && key && ivec);\n    OPENSSL_assert((AES_ENCRYPT == enc) || (AES_DECRYPT == enc));\n    OPENSSL_assert((length % AES_BLOCK_SIZE) == 0);\n\n    if (AES_ENCRYPT == enc) {\n        /*\n         * XXX: Do a separate case for when in != out (strictly should check\n         * for overlap, too)\n         */\n\n        /* First the forward pass */\n        iv = ivec;\n        iv2 = ivec + AES_BLOCK_SIZE;\n        while (len >= AES_BLOCK_SIZE) {\n            for (n = 0; n < AES_BLOCK_SIZE; ++n)\n                out[n] = in[n] ^ iv[n];\n            AES_encrypt(out, out, key);\n            for (n = 0; n < AES_BLOCK_SIZE; ++n)\n                out[n] ^= iv2[n];\n            iv = out;\n            memcpy(prev, in, AES_BLOCK_SIZE);\n            iv2 = prev;\n            len -= AES_BLOCK_SIZE;\n            in += AES_BLOCK_SIZE;\n            out += AES_BLOCK_SIZE;\n        }\n\n        /* And now backwards */\n        iv = ivec + AES_BLOCK_SIZE * 2;\n        iv2 = ivec + AES_BLOCK_SIZE * 3;\n        len = length;\n        while (len >= AES_BLOCK_SIZE) {\n            out -= AES_BLOCK_SIZE;\n            /*\n             * XXX: reduce copies by alternating between buffers\n             */\n            memcpy(tmp, out, AES_BLOCK_SIZE);\n            for (n = 0; n < AES_BLOCK_SIZE; ++n)\n                out[n] ^= iv[n];\n            /*\n             * hexdump(stdout, \"out ^ iv\", out, AES_BLOCK_SIZE);\n             */\n            AES_encrypt(out, out, key);\n            /*\n             * hexdump(stdout,\"enc\", out, AES_BLOCK_SIZE);\n             */\n            /*\n             * hexdump(stdout,\"iv2\", iv2, AES_BLOCK_SIZE);\n             */\n            for (n = 0; n < AES_BLOCK_SIZE; ++n)\n                out[n] ^= iv2[n];\n            /*\n             * hexdump(stdout,\"out\", out, AES_BLOCK_SIZE);\n             */\n            iv = out;\n            memcpy(prev, tmp, AES_BLOCK_SIZE);\n            iv2 = prev;\n            len -= AES_BLOCK_SIZE;\n        }\n    } else {\n        /* First backwards */\n        iv = ivec + AES_BLOCK_SIZE * 2;\n        iv2 = ivec + AES_BLOCK_SIZE * 3;\n        in += length;\n        out += length;\n        while (len >= AES_BLOCK_SIZE) {\n            in -= AES_BLOCK_SIZE;\n            out -= AES_BLOCK_SIZE;\n            memcpy(tmp, in, AES_BLOCK_SIZE);\n            memcpy(tmp2, in, AES_BLOCK_SIZE);\n            for (n = 0; n < AES_BLOCK_SIZE; ++n)\n                tmp[n] ^= iv2[n];\n            AES_decrypt(tmp, out, key);\n            for (n = 0; n < AES_BLOCK_SIZE; ++n)\n                out[n] ^= iv[n];\n            memcpy(tmp3, tmp2, AES_BLOCK_SIZE);\n            iv = tmp3;\n            iv2 = out;\n            len -= AES_BLOCK_SIZE;\n        }\n\n        /* And now forwards */\n        iv = ivec;\n        iv2 = ivec + AES_BLOCK_SIZE;\n        len = length;\n        while (len >= AES_BLOCK_SIZE) {\n            memcpy(tmp, out, AES_BLOCK_SIZE);\n            memcpy(tmp2, out, AES_BLOCK_SIZE);\n            for (n = 0; n < AES_BLOCK_SIZE; ++n)\n                tmp[n] ^= iv2[n];\n            AES_decrypt(tmp, out, key);\n            for (n = 0; n < AES_BLOCK_SIZE; ++n)\n                out[n] ^= iv[n];\n            memcpy(tmp3, tmp2, AES_BLOCK_SIZE);\n            iv = tmp3;\n            iv2 = out;\n            len -= AES_BLOCK_SIZE;\n            in += AES_BLOCK_SIZE;\n            out += AES_BLOCK_SIZE;\n        }\n    }\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_misc.c", "func": "const char *AES_options(void)\n{\n# ifdef FULL_UNROLL\n    return \"aes(full)\";\n# else\n    return \"aes(partial)\";\n# endif\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_ofb.c", "func": "void AES_ofb128_encrypt(const unsigned char *in, unsigned char *out,\n                        size_t length, const AES_KEY *key,\n                        unsigned char *ivec, int *num)\n{\n    CRYPTO_ofb128_encrypt(in, out, length, key, ivec, num,\n                          (block128_f) AES_encrypt);\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_wrap.c", "func": "int AES_wrap_key(AES_KEY *key, const unsigned char *iv,\n                 unsigned char *out,\n                 const unsigned char *in, unsigned int inlen)\n{\n    return CRYPTO_128_wrap(key, iv, out, in, inlen, (block128_f) AES_encrypt);\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_wrap.c", "func": "int AES_unwrap_key(AES_KEY *key, const unsigned char *iv,\n                   unsigned char *out,\n                   const unsigned char *in, unsigned int inlen)\n{\n    return CRYPTO_128_unwrap(key, iv, out, in, inlen,\n                             (block128_f) AES_decrypt);\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_x86core.c", "func": "static void prefetch256(const void *table)\n{\n    volatile unsigned long *t = (void *)table, ret;\n    unsigned long sum;\n    int i;\n\n    /* 32 is common least cache-line size */\n    for (sum = 0, i = 0; i < 256/sizeof(t[0]); i += 32/sizeof(t[0]))\n        sum ^= t[i];\n\n    ret = sum;\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_x86core.c", "func": "int AES_set_encrypt_key(const unsigned char *userKey, const int bits,\n                        AES_KEY *key)\n{\n\n    u32 *rk;\n    int i = 0;\n    u32 temp;\n\n    if (!userKey || !key)\n        return -1;\n    if (bits != 128 && bits != 192 && bits != 256)\n        return -2;\n\n    rk = key->rd_key;\n\n    if (bits==128)\n        key->rounds = 10;\n    else if (bits==192)\n        key->rounds = 12;\n    else\n        key->rounds = 14;\n\n    rk[0] = GETU32(userKey     );\n    rk[1] = GETU32(userKey +  4);\n    rk[2] = GETU32(userKey +  8);\n    rk[3] = GETU32(userKey + 12);\n    if (bits == 128) {\n        while (1) {\n            temp  = rk[3];\n            rk[4] = rk[0] ^\n                ((u32)Te4[(temp >>  8) & 0xff]      ) ^\n                ((u32)Te4[(temp >> 16) & 0xff] <<  8) ^\n                ((u32)Te4[(temp >> 24)       ] << 16) ^\n                ((u32)Te4[(temp      ) & 0xff] << 24) ^\n                rcon[i];\n            rk[5] = rk[1] ^ rk[4];\n            rk[6] = rk[2] ^ rk[5];\n            rk[7] = rk[3] ^ rk[6];\n            if (++i == 10) {\n                return 0;\n            }\n            rk += 4;\n        }\n    }\n    rk[4] = GETU32(userKey + 16);\n    rk[5] = GETU32(userKey + 20);\n    if (bits == 192) {\n        while (1) {\n            temp = rk[ 5];\n            rk[ 6] = rk[ 0] ^\n                ((u32)Te4[(temp >>  8) & 0xff]      ) ^\n                ((u32)Te4[(temp >> 16) & 0xff] <<  8) ^\n                ((u32)Te4[(temp >> 24)       ] << 16) ^\n                ((u32)Te4[(temp      ) & 0xff] << 24) ^\n                rcon[i];\n            rk[ 7] = rk[ 1] ^ rk[ 6];\n            rk[ 8] = rk[ 2] ^ rk[ 7];\n            rk[ 9] = rk[ 3] ^ rk[ 8];\n            if (++i == 8) {\n                return 0;\n            }\n            rk[10] = rk[ 4] ^ rk[ 9];\n            rk[11] = rk[ 5] ^ rk[10];\n            rk += 6;\n        }\n    }\n    rk[6] = GETU32(userKey + 24);\n    rk[7] = GETU32(userKey + 28);\n    if (bits == 256) {\n        while (1) {\n            temp = rk[ 7];\n            rk[ 8] = rk[ 0] ^\n                ((u32)Te4[(temp >>  8) & 0xff]      ) ^\n                ((u32)Te4[(temp >> 16) & 0xff] <<  8) ^\n                ((u32)Te4[(temp >> 24)       ] << 16) ^\n                ((u32)Te4[(temp      ) & 0xff] << 24) ^\n                rcon[i];\n            rk[ 9] = rk[ 1] ^ rk[ 8];\n            rk[10] = rk[ 2] ^ rk[ 9];\n            rk[11] = rk[ 3] ^ rk[10];\n            if (++i == 7) {\n                return 0;\n            }\n            temp = rk[11];\n            rk[12] = rk[ 4] ^\n                ((u32)Te4[(temp      ) & 0xff]      ) ^\n                ((u32)Te4[(temp >>  8) & 0xff] <<  8) ^\n                ((u32)Te4[(temp >> 16) & 0xff] << 16) ^\n                ((u32)Te4[(temp >> 24)       ] << 24);\n            rk[13] = rk[ 5] ^ rk[12];\n            rk[14] = rk[ 6] ^ rk[13];\n            rk[15] = rk[ 7] ^ rk[14];\n\n            rk += 8;\n            }\n    }\n    return 0;\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_x86core.c", "func": "int AES_set_decrypt_key(const unsigned char *userKey, const int bits,\n                        AES_KEY *key)\n{\n\n    u32 *rk;\n    int i, j, status;\n    u32 temp;\n\n    /* first, start with an encryption schedule */\n    status = AES_set_encrypt_key(userKey, bits, key);\n    if (status < 0)\n        return status;\n\n    rk = key->rd_key;\n\n    /* invert the order of the round keys: */\n    for (i = 0, j = 4*(key->rounds); i < j; i += 4, j -= 4) {\n        temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;\n        temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\n        temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\n        temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\n    }\n    /* apply the inverse MixColumn transform to all round keys but the first and the last: */\n    for (i = 1; i < (key->rounds); i++) {\n        rk += 4;\n#if 1\n        for (j = 0; j < 4; j++) {\n            u32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\n\n            tp1 = rk[j];\n            m = tp1 & 0x80808080;\n            tp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\n                ((m - (m >> 7)) & 0x1b1b1b1b);\n            m = tp2 & 0x80808080;\n            tp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\n                ((m - (m >> 7)) & 0x1b1b1b1b);\n            m = tp4 & 0x80808080;\n            tp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\n                ((m - (m >> 7)) & 0x1b1b1b1b);\n            tp9 = tp8 ^ tp1;\n            tpb = tp9 ^ tp2;\n            tpd = tp9 ^ tp4;\n            tpe = tp8 ^ tp4 ^ tp2;\n#if defined(ROTATE)\n            rk[j] = tpe ^ ROTATE(tpd,16) ^\n                ROTATE(tp9,8) ^ ROTATE(tpb,24);\n#else\n            rk[j] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^\n                (tp9 >> 24) ^ (tp9 << 8) ^\n                (tpb >> 8) ^ (tpb << 24);\n#endif\n        }\n#else\n        rk[0] =\n            Td0[Te2[(rk[0]      ) & 0xff] & 0xff] ^\n            Td1[Te2[(rk[0] >>  8) & 0xff] & 0xff] ^\n            Td2[Te2[(rk[0] >> 16) & 0xff] & 0xff] ^\n            Td3[Te2[(rk[0] >> 24)       ] & 0xff];\n        rk[1] =\n            Td0[Te2[(rk[1]      ) & 0xff] & 0xff] ^\n            Td1[Te2[(rk[1] >>  8) & 0xff] & 0xff] ^\n            Td2[Te2[(rk[1] >> 16) & 0xff] & 0xff] ^\n            Td3[Te2[(rk[1] >> 24)       ] & 0xff];\n        rk[2] =\n            Td0[Te2[(rk[2]      ) & 0xff] & 0xff] ^\n            Td1[Te2[(rk[2] >>  8) & 0xff] & 0xff] ^\n            Td2[Te2[(rk[2] >> 16) & 0xff] & 0xff] ^\n            Td3[Te2[(rk[2] >> 24)       ] & 0xff];\n        rk[3] =\n            Td0[Te2[(rk[3]      ) & 0xff] & 0xff] ^\n            Td1[Te2[(rk[3] >>  8) & 0xff] & 0xff] ^\n            Td2[Te2[(rk[3] >> 16) & 0xff] & 0xff] ^\n            Td3[Te2[(rk[3] >> 24)       ] & 0xff];\n#endif\n    }\n    return 0;\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_x86core.c", "func": "void AES_encrypt(const unsigned char *in, unsigned char *out,\n                 const AES_KEY *key)\n{\n\n    const u32 *rk;\n    u32 s0, s1, s2, s3, t[4];\n    int r;\n\n    assert(in && out && key);\n    rk = key->rd_key;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(in     ) ^ rk[0];\n    s1 = GETU32(in +  4) ^ rk[1];\n    s2 = GETU32(in +  8) ^ rk[2];\n    s3 = GETU32(in + 12) ^ rk[3];\n\n#if defined(AES_COMPACT_IN_OUTER_ROUNDS)\n    prefetch256(Te4);\n\n    t[0] = (u32)Te4[(s0      ) & 0xff]       ^\n           (u32)Te4[(s1 >>  8) & 0xff] <<  8 ^\n           (u32)Te4[(s2 >> 16) & 0xff] << 16 ^\n           (u32)Te4[(s3 >> 24)       ] << 24;\n    t[1] = (u32)Te4[(s1      ) & 0xff]       ^\n           (u32)Te4[(s2 >>  8) & 0xff] <<  8 ^\n           (u32)Te4[(s3 >> 16) & 0xff] << 16 ^\n           (u32)Te4[(s0 >> 24)       ] << 24;\n    t[2] = (u32)Te4[(s2      ) & 0xff]       ^\n           (u32)Te4[(s3 >>  8) & 0xff] <<  8 ^\n           (u32)Te4[(s0 >> 16) & 0xff] << 16 ^\n           (u32)Te4[(s1 >> 24)       ] << 24;\n    t[3] = (u32)Te4[(s3      ) & 0xff]       ^\n           (u32)Te4[(s0 >>  8) & 0xff] <<  8 ^\n           (u32)Te4[(s1 >> 16) & 0xff] << 16 ^\n           (u32)Te4[(s2 >> 24)       ] << 24;\n\n    /* now do the linear transform using words */\n    {   int i;\n        u32 r0, r1, r2;\n\n        for (i = 0; i < 4; i++) {\n            r0 = t[i];\n            r1 = r0 & 0x80808080;\n            r2 = ((r0 & 0x7f7f7f7f) << 1) ^\n                ((r1 - (r1 >> 7)) & 0x1b1b1b1b);\n#if defined(ROTATE)\n            t[i] = r2 ^ ROTATE(r2,24) ^ ROTATE(r0,24) ^\n                ROTATE(r0,16) ^ ROTATE(r0,8);\n#else\n            t[i] = r2 ^ ((r2 ^ r0) << 24) ^ ((r2 ^ r0) >> 8) ^\n                (r0 << 16) ^ (r0 >> 16) ^\n                (r0 << 8) ^ (r0 >> 24);\n#endif\n            t[i] ^= rk[4+i];\n        }\n    }\n#else\n    t[0] =  Te0[(s0      ) & 0xff] ^\n        Te1[(s1 >>  8) & 0xff] ^\n        Te2[(s2 >> 16) & 0xff] ^\n        Te3[(s3 >> 24)       ] ^\n        rk[4];\n    t[1] =  Te0[(s1      ) & 0xff] ^\n        Te1[(s2 >>  8) & 0xff] ^\n        Te2[(s3 >> 16) & 0xff] ^\n        Te3[(s0 >> 24)       ] ^\n        rk[5];\n    t[2] =  Te0[(s2      ) & 0xff] ^\n        Te1[(s3 >>  8) & 0xff] ^\n        Te2[(s0 >> 16) & 0xff] ^\n        Te3[(s1 >> 24)       ] ^\n        rk[6];\n    t[3] =  Te0[(s3      ) & 0xff] ^\n        Te1[(s0 >>  8) & 0xff] ^\n        Te2[(s1 >> 16) & 0xff] ^\n        Te3[(s2 >> 24)       ] ^\n        rk[7];\n#endif\n    s0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\n\n    /*\n     * Nr - 2 full rounds:\n     */\n    for (rk+=8,r=key->rounds-2; r>0; rk+=4,r--) {\n#if defined(AES_COMPACT_IN_INNER_ROUNDS)\n        t[0] = (u32)Te4[(s0      ) & 0xff]       ^\n               (u32)Te4[(s1 >>  8) & 0xff] <<  8 ^\n               (u32)Te4[(s2 >> 16) & 0xff] << 16 ^\n               (u32)Te4[(s3 >> 24)       ] << 24;\n        t[1] = (u32)Te4[(s1      ) & 0xff]       ^\n               (u32)Te4[(s2 >>  8) & 0xff] <<  8 ^\n               (u32)Te4[(s3 >> 16) & 0xff] << 16 ^\n               (u32)Te4[(s0 >> 24)       ] << 24;\n        t[2] = (u32)Te4[(s2      ) & 0xff]       ^\n               (u32)Te4[(s3 >>  8) & 0xff] <<  8 ^\n               (u32)Te4[(s0 >> 16) & 0xff] << 16 ^\n               (u32)Te4[(s1 >> 24)       ] << 24;\n        t[3] = (u32)Te4[(s3      ) & 0xff]       ^\n               (u32)Te4[(s0 >>  8) & 0xff] <<  8 ^\n               (u32)Te4[(s1 >> 16) & 0xff] << 16 ^\n               (u32)Te4[(s2 >> 24)       ] << 24;\n\n        /* now do the linear transform using words */\n        {\n            int i;\n            u32 r0, r1, r2;\n\n            for (i = 0; i < 4; i++) {\n                r0 = t[i];\n                r1 = r0 & 0x80808080;\n                r2 = ((r0 & 0x7f7f7f7f) << 1) ^\n                    ((r1 - (r1 >> 7)) & 0x1b1b1b1b);\n#if defined(ROTATE)\n                t[i] = r2 ^ ROTATE(r2,24) ^ ROTATE(r0,24) ^\n                    ROTATE(r0,16) ^ ROTATE(r0,8);\n#else\n                t[i] = r2 ^ ((r2 ^ r0) << 24) ^ ((r2 ^ r0) >> 8) ^\n                    (r0 << 16) ^ (r0 >> 16) ^\n                    (r0 << 8) ^ (r0 >> 24);\n#endif\n                t[i] ^= rk[i];\n            }\n        }\n#else\n        t[0] =  Te0[(s0      ) & 0xff] ^\n            Te1[(s1 >>  8) & 0xff] ^\n            Te2[(s2 >> 16) & 0xff] ^\n            Te3[(s3 >> 24)       ] ^\n            rk[0];\n        t[1] =  Te0[(s1      ) & 0xff] ^\n            Te1[(s2 >>  8) & 0xff] ^\n            Te2[(s3 >> 16) & 0xff] ^\n            Te3[(s0 >> 24)       ] ^\n            rk[1];\n        t[2] =  Te0[(s2      ) & 0xff] ^\n            Te1[(s3 >>  8) & 0xff] ^\n            Te2[(s0 >> 16) & 0xff] ^\n            Te3[(s1 >> 24)       ] ^\n            rk[2];\n        t[3] =  Te0[(s3      ) & 0xff] ^\n            Te1[(s0 >>  8) & 0xff] ^\n            Te2[(s1 >> 16) & 0xff] ^\n            Te3[(s2 >> 24)       ] ^\n            rk[3];\n#endif\n        s0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\n    }\n    /*\n     * apply last round and\n     * map cipher state to byte array block:\n     */\n#if defined(AES_COMPACT_IN_OUTER_ROUNDS)\n    prefetch256(Te4);\n\n    *(u32*)(out+0) =\n           (u32)Te4[(s0      ) & 0xff]       ^\n           (u32)Te4[(s1 >>  8) & 0xff] <<  8 ^\n           (u32)Te4[(s2 >> 16) & 0xff] << 16 ^\n           (u32)Te4[(s3 >> 24)       ] << 24 ^\n        rk[0];\n    *(u32*)(out+4) =\n           (u32)Te4[(s1      ) & 0xff]       ^\n           (u32)Te4[(s2 >>  8) & 0xff] <<  8 ^\n           (u32)Te4[(s3 >> 16) & 0xff] << 16 ^\n           (u32)Te4[(s0 >> 24)       ] << 24 ^\n        rk[1];\n    *(u32*)(out+8) =\n           (u32)Te4[(s2      ) & 0xff]       ^\n           (u32)Te4[(s3 >>  8) & 0xff] <<  8 ^\n           (u32)Te4[(s0 >> 16) & 0xff] << 16 ^\n           (u32)Te4[(s1 >> 24)       ] << 24 ^\n        rk[2];\n    *(u32*)(out+12) =\n           (u32)Te4[(s3      ) & 0xff]       ^\n           (u32)Te4[(s0 >>  8) & 0xff] <<  8 ^\n           (u32)Te4[(s1 >> 16) & 0xff] << 16 ^\n           (u32)Te4[(s2 >> 24)       ] << 24 ^\n        rk[3];\n#else\n    *(u32*)(out+0) =\n        (Te2[(s0      ) & 0xff] & 0x000000ffU) ^\n        (Te3[(s1 >>  8) & 0xff] & 0x0000ff00U) ^\n        (Te0[(s2 >> 16) & 0xff] & 0x00ff0000U) ^\n        (Te1[(s3 >> 24)       ] & 0xff000000U) ^\n        rk[0];\n    *(u32*)(out+4) =\n        (Te2[(s1      ) & 0xff] & 0x000000ffU) ^\n        (Te3[(s2 >>  8) & 0xff] & 0x0000ff00U) ^\n        (Te0[(s3 >> 16) & 0xff] & 0x00ff0000U) ^\n        (Te1[(s0 >> 24)       ] & 0xff000000U) ^\n        rk[1];\n    *(u32*)(out+8) =\n        (Te2[(s2      ) & 0xff] & 0x000000ffU) ^\n        (Te3[(s3 >>  8) & 0xff] & 0x0000ff00U) ^\n        (Te0[(s0 >> 16) & 0xff] & 0x00ff0000U) ^\n        (Te1[(s1 >> 24)       ] & 0xff000000U) ^\n        rk[2];\n    *(u32*)(out+12) =\n        (Te2[(s3      ) & 0xff] & 0x000000ffU) ^\n        (Te3[(s0 >>  8) & 0xff] & 0x0000ff00U) ^\n        (Te0[(s1 >> 16) & 0xff] & 0x00ff0000U) ^\n        (Te1[(s2 >> 24)       ] & 0xff000000U) ^\n        rk[3];\n#endif\n}\n", "label": "crypto", "set": "test"}
{"project": "openssl", "file": "aes_x86core.c", "func": "void AES_decrypt(const unsigned char *in, unsigned char *out,\n                 const AES_KEY *key)\n{\n\n    const u32 *rk;\n    u32 s0, s1, s2, s3, t[4];\n    int r;\n\n    assert(in && out && key);\n    rk = key->rd_key;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(in     ) ^ rk[0];\n    s1 = GETU32(in +  4) ^ rk[1];\n    s2 = GETU32(in +  8) ^ rk[2];\n    s3 = GETU32(in + 12) ^ rk[3];\n\n#if defined(AES_COMPACT_IN_OUTER_ROUNDS)\n    prefetch256(Td4);\n\n    t[0] = (u32)Td4[(s0      ) & 0xff]       ^\n           (u32)Td4[(s3 >>  8) & 0xff] <<  8 ^\n           (u32)Td4[(s2 >> 16) & 0xff] << 16 ^\n           (u32)Td4[(s1 >> 24)       ] << 24;\n    t[1] = (u32)Td4[(s1      ) & 0xff]       ^\n           (u32)Td4[(s0 >>  8) & 0xff] <<  8 ^\n           (u32)Td4[(s3 >> 16) & 0xff] << 16 ^\n           (u32)Td4[(s2 >> 24)       ] << 24;\n    t[2] = (u32)Td4[(s2      ) & 0xff]       ^\n           (u32)Td4[(s1 >>  8) & 0xff] <<  8 ^\n           (u32)Td4[(s0 >> 16) & 0xff] << 16 ^\n           (u32)Td4[(s3 >> 24)       ] << 24;\n    t[3] = (u32)Td4[(s3      ) & 0xff]       ^\n           (u32)Td4[(s2 >>  8) & 0xff] <<  8 ^\n           (u32)Td4[(s1 >> 16) & 0xff] << 16 ^\n           (u32)Td4[(s0 >> 24)       ] << 24;\n\n    /* now do the linear transform using words */\n    {\n        int i;\n        u32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\n\n        for (i = 0; i < 4; i++) {\n            tp1 = t[i];\n            m = tp1 & 0x80808080;\n            tp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\n                ((m - (m >> 7)) & 0x1b1b1b1b);\n            m = tp2 & 0x80808080;\n            tp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\n                ((m - (m >> 7)) & 0x1b1b1b1b);\n            m = tp4 & 0x80808080;\n            tp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\n                ((m - (m >> 7)) & 0x1b1b1b1b);\n            tp9 = tp8 ^ tp1;\n            tpb = tp9 ^ tp2;\n            tpd = tp9 ^ tp4;\n            tpe = tp8 ^ tp4 ^ tp2;\n#if defined(ROTATE)\n            t[i] = tpe ^ ROTATE(tpd,16) ^\n                ROTATE(tp9,8) ^ ROTATE(tpb,24);\n#else\n            t[i] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^\n                (tp9 >> 24) ^ (tp9 << 8) ^\n                (tpb >> 8) ^ (tpb << 24);\n#endif\n            t[i] ^= rk[4+i];\n        }\n    }\n#else\n    t[0] =  Td0[(s0      ) & 0xff] ^\n        Td1[(s3 >>  8) & 0xff] ^\n        Td2[(s2 >> 16) & 0xff] ^\n        Td3[(s1 >> 24)       ] ^\n        rk[4];\n    t[1] =  Td0[(s1      ) & 0xff] ^\n        Td1[(s0 >>  8) & 0xff] ^\n        Td2[(s3 >> 16) & 0xff] ^\n        Td3[(s2 >> 24)       ] ^\n        rk[5];\n    t[2] =  Td0[(s2      ) & 0xff] ^\n        Td1[(s1 >>  8) & 0xff] ^\n        Td2[(s0 >> 16) & 0xff] ^\n        Td3[(s3 >> 24)       ] ^\n        rk[6];\n    t[3] =  Td0[(s3      ) & 0xff] ^\n        Td1[(s2 >>  8) & 0xff] ^\n        Td2[(s1 >> 16) & 0xff] ^\n        Td3[(s0 >> 24)       ] ^\n        rk[7];\n#endif\n    s0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\n\n    /*\n     * Nr - 2 full rounds:\n     */\n    for (rk+=8,r=key->rounds-2; r>0; rk+=4,r--) {\n#if defined(AES_COMPACT_IN_INNER_ROUNDS)\n        t[0] = (u32)Td4[(s0      ) & 0xff]       ^\n               (u32)Td4[(s3 >>  8) & 0xff] <<  8 ^\n               (u32)Td4[(s2 >> 16) & 0xff] << 16 ^\n               (u32)Td4[(s1 >> 24)       ] << 24;\n        t[1] = (u32)Td4[(s1      ) & 0xff]       ^\n               (u32)Td4[(s0 >>  8) & 0xff] <<  8 ^\n               (u32)Td4[(s3 >> 16) & 0xff] << 16 ^\n               (u32)Td4[(s2 >> 24)       ] << 24;\n        t[2] = (u32)Td4[(s2      ) & 0xff]       ^\n               (u32)Td4[(s1 >>  8) & 0xff] <<  8 ^\n               (u32)Td4[(s0 >> 16) & 0xff] << 16 ^\n               (u32)Td4[(s3 >> 24)       ] << 24;\n        t[3] = (u32)Td4[(s3      ) & 0xff]       ^\n               (u32)Td4[(s2 >>  8) & 0xff] <<  8 ^\n               (u32)Td4[(s1 >> 16) & 0xff] << 16 ^\n               (u32)Td4[(s0 >> 24)       ] << 24;\n\n    /* now do the linear transform using words */\n    {\n        int i;\n        u32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\n\n        for (i = 0; i < 4; i++) {\n            tp1 = t[i];\n            m = tp1 & 0x80808080;\n            tp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\n                ((m - (m >> 7)) & 0x1b1b1b1b);\n            m = tp2 & 0x80808080;\n            tp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\n                ((m - (m >> 7)) & 0x1b1b1b1b);\n            m = tp4 & 0x80808080;\n            tp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\n                ((m - (m >> 7)) & 0x1b1b1b1b);\n            tp9 = tp8 ^ tp1;\n            tpb = tp9 ^ tp2;\n            tpd = tp9 ^ tp4;\n            tpe = tp8 ^ tp4 ^ tp2;\n#if defined(ROTATE)\n            t[i] = tpe ^ ROTATE(tpd,16) ^\n                ROTATE(tp9,8) ^ ROTATE(tpb,24);\n#else\n            t[i] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^\n                (tp9 >> 24) ^ (tp9 << 8) ^\n                (tpb >> 8) ^ (tpb << 24);\n#endif\n            t[i] ^= rk[i];\n        }\n    }\n#else\n    t[0] =  Td0[(s0      ) & 0xff] ^\n        Td1[(s3 >>  8) & 0xff] ^\n        Td2[(s2 >> 16) & 0xff] ^\n        Td3[(s1 >> 24)       ] ^\n        rk[0];\n    t[1] =  Td0[(s1      ) & 0xff] ^\n        Td1[(s0 >>  8) & 0xff] ^\n        Td2[(s3 >> 16) & 0xff] ^\n        Td3[(s2 >> 24)       ] ^\n        rk[1];\n    t[2] =  Td0[(s2      ) & 0xff] ^\n        Td1[(s1 >>  8) & 0xff] ^\n        Td2[(s0 >> 16) & 0xff] ^\n        Td3[(s3 >> 24)       ] ^\n        rk[2];\n    t[3] =  Td0[(s3      ) & 0xff] ^\n        Td1[(s2 >>  8) & 0xff] ^\n        Td2[(s1 >> 16) & 0xff] ^\n        Td3[(s0 >> 24)       ] ^\n        rk[3];\n#endif\n    s0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\n    }\n    /*\n     * apply last round and\n     * map cipher state to byte array block:\n     */\n    prefetch256(Td4);\n\n    *(u32*)(out+0) =\n        ((u32)Td4[(s0      ) & 0xff])    ^\n        ((u32)Td4[(s3 >>  8) & 0xff] <<  8) ^\n        ((u32)Td4[(s2 >> 16) & 0xff] << 16) ^\n        ((u32)Td4[(s1 >> 24)       ] << 24) ^\n        rk[0];\n    *(u32*)(out+4) =\n        ((u32)Td4[(s1      ) & 0xff])     ^\n        ((u32)Td4[(s0 >>  8) & 0xff] <<  8) ^\n        ((u32)Td4[(s3 >> 16) & 0xff] << 16) ^\n        ((u32)Td4[(s2 >> 24)       ] << 24) ^\n        rk[1];\n    *(u32*)(out+8) =\n        ((u32)Td4[(s2      ) & 0xff])     ^\n        ((u32)Td4[(s1 >>  8) & 0xff] <<  8) ^\n        ((u32)Td4[(s0 >> 16) & 0xff] << 16) ^\n        ((u32)Td4[(s3 >> 24)       ] << 24) ^\n        rk[2];\n    *(u32*)(out+12) =\n        ((u32)Td4[(s3      ) & 0xff])     ^\n        ((u32)Td4[(s2 >>  8) & 0xff] <<  8) ^\n        ((u32)Td4[(s1 >> 16) & 0xff] << 16) ^\n        ((u32)Td4[(s0 >> 24)       ] << 24) ^\n        rk[3];\n}\n", "label": "crypto", "set": "test"}
